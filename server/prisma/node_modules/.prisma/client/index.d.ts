
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Report
 */

export type Report = {
  id: number
  email: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserGeo
 */

export type UserGeo = {
  id: number
  userId: string
  lat: Prisma.Decimal | null
  lon: Prisma.Decimal | null
  work_lat: Prisma.Decimal | null
  work_lon: Prisma.Decimal | null
  school_lat: Prisma.Decimal | null
  school_lon: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserAddress
 */

export type UserAddress = {
  id: number
  userId: string
  streetAddress: string | null
  streetAddress2: string | null
  city: string | null
  country: string | null
  postalCode: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model User
 */

export type User = {
  id: string
  userType: UserType
  email: string
  password: string
  fname: string | null
  lname: string | null
  createdAt: Date
  updatedAt: Date
  imagePath: string | null
  passCode: string | null
  banned: boolean
}

/**
 * Model UserSegments
 */

export type UserSegments = {
  id: string
  userId: string
  homeSuperSegId: number | null
  homeSuperSegName: string | null
  workSuperSegId: number | null
  workSuperSegName: string | null
  schoolSuperSegId: number | null
  schoolSuperSegName: string | null
  homeSegmentId: number | null
  homeSegmentName: string | null
  workSegmentId: number | null
  workSegmentName: string | null
  schoolSegmentId: number | null
  schoolSegmentName: string | null
  homeSubSegmentId: number | null
  homeSubSegmentName: string | null
  workSubSegmentId: number | null
  workSubSegmentName: string | null
  schoolSubSegmentId: number | null
  schoolSubSegmentName: string | null
}

/**
 * Model Category
 */

export type Category = {
  id: number
  title: string
  description: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Geo
 */

export type Geo = {
  id: number
  ideaId: number | null
  proposalId: number | null
  lat: Prisma.Decimal | null
  lon: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Address
 */

export type Address = {
  id: number
  ideaId: number | null
  proposalId: number | null
  streetAddress: string | null
  streetAddress2: string | null
  city: string | null
  country: string | null
  postalCode: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Idea
 */

export type Idea = {
  id: number
  authorId: string
  championId: string | null
  categoryId: number
  superSegmentId: number
  segmentId: number | null
  subSegmentId: number | null
  title: string
  description: string
  userType: string
  communityImpact: string | null
  natureImpact: string | null
  artsImpact: string | null
  energyImpact: string | null
  manufacturingImpact: string | null
  state: IdeaState
  active: boolean
  imagePath: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Proposal
 */

export type Proposal = {
  id: number
  authorId: string
  championId: string | null
  categoryId: number
  superSegmentId: number
  segmentId: number | null
  subSegmentId: number | null
  title: string
  description: string
  userType: string
  communityImpact: string | null
  natureImpact: string | null
  artsImpact: string | null
  energyImpact: string | null
  manufacturingImpact: string | null
  state: IdeaState
  active: boolean
  imagePath: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Project
 */

export type Project = {
  id: number
  ideaId: number
  description: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Rating
 */

export type Rating = {
  id: number
  ideaId: number | null
  proposalId: number | null
  authorId: string
  rating: number
  ratingExplanation: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Comment
 */

export type Comment = {
  id: number
  ideaId: number | null
  proposalId: number | null
  authorId: string
  userSegId: string
  superSegmentId: number | null
  segmentId: number | null
  subSegmentId: number | null
  content: string
  active: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model UserCommentLikes
 */

export type UserCommentLikes = {
  id: number
  ideaCommentId: number | null
  authorId: string | null
}

/**
 * Model UserCommentDislikes
 */

export type UserCommentDislikes = {
  id: number
  ideaCommentId: number | null
  authorId: string | null
}

/**
 * Model Advertisements
 */

export type Advertisements = {
  id: number
  ownerId: string
  createAt: Date
  updateAt: Date | null
  adTitle: string
  adType: AdType
  duration: Date | null
  adPosition: string
  imagePath: string
  externalLink: string
  published: boolean
}

/**
 * Model SuperSegment
 */

export type SuperSegment = {
  superSegId: number
  name: string
  country: string
  province: string
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model Segments
 */

export type Segments = {
  segId: number
  superSegId: number
  country: string
  province: string
  name: string
  superSegName: string | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model SubSegments
 */

export type SubSegments = {
  id: number
  segId: number
  name: string
  lat: Prisma.Decimal | null
  lon: Prisma.Decimal | null
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model segmentRequest
 */

export type segmentRequest = {
  id: number
  createAt: Date
  userId: string
  country: string
  province: string
  segmentName: string
  subSegmentName: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const UserType: {
  ADMIN: 'ADMIN',
  MOD: 'MOD',
  SEG_ADMIN: 'SEG_ADMIN',
  SEG_MOD: 'SEG_MOD',
  MUNICIPAL_SEG_ADMIN: 'MUNICIPAL_SEG_ADMIN',
  BUSINESS: 'BUSINESS',
  RESIDENTIAL: 'RESIDENTIAL',
  MUNICIPAL: 'MUNICIPAL',
  WORKER: 'WORKER',
  ASSOCIATE: 'ASSOCIATE',
  DEVELOPER: 'DEVELOPER'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const IdeaState: {
  IDEA: 'IDEA',
  PROPOSAL: 'PROPOSAL',
  PROJECT: 'PROJECT'
};

export type IdeaState = (typeof IdeaState)[keyof typeof IdeaState]


export const AdType: {
  BASIC: 'BASIC',
  EXTRA: 'EXTRA'
};

export type AdType = (typeof AdType)[keyof typeof AdType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Reports
 * const reports = await prisma.report.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Reports
   * const reports = await prisma.report.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<GlobalReject>;

  /**
   * `prisma.userGeo`: Exposes CRUD operations for the **UserGeo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGeos
    * const userGeos = await prisma.userGeo.findMany()
    * ```
    */
  get userGeo(): Prisma.UserGeoDelegate<GlobalReject>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.userSegments`: Exposes CRUD operations for the **UserSegments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSegments
    * const userSegments = await prisma.userSegments.findMany()
    * ```
    */
  get userSegments(): Prisma.UserSegmentsDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.geo`: Exposes CRUD operations for the **Geo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Geos
    * const geos = await prisma.geo.findMany()
    * ```
    */
  get geo(): Prisma.GeoDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.idea`: Exposes CRUD operations for the **Idea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ideas
    * const ideas = await prisma.idea.findMany()
    * ```
    */
  get idea(): Prisma.IdeaDelegate<GlobalReject>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<GlobalReject>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<GlobalReject>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.userCommentLikes`: Exposes CRUD operations for the **UserCommentLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCommentLikes
    * const userCommentLikes = await prisma.userCommentLikes.findMany()
    * ```
    */
  get userCommentLikes(): Prisma.UserCommentLikesDelegate<GlobalReject>;

  /**
   * `prisma.userCommentDislikes`: Exposes CRUD operations for the **UserCommentDislikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCommentDislikes
    * const userCommentDislikes = await prisma.userCommentDislikes.findMany()
    * ```
    */
  get userCommentDislikes(): Prisma.UserCommentDislikesDelegate<GlobalReject>;

  /**
   * `prisma.advertisements`: Exposes CRUD operations for the **Advertisements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisements.findMany()
    * ```
    */
  get advertisements(): Prisma.AdvertisementsDelegate<GlobalReject>;

  /**
   * `prisma.superSegment`: Exposes CRUD operations for the **SuperSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperSegments
    * const superSegments = await prisma.superSegment.findMany()
    * ```
    */
  get superSegment(): Prisma.SuperSegmentDelegate<GlobalReject>;

  /**
   * `prisma.segments`: Exposes CRUD operations for the **Segments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Segments
    * const segments = await prisma.segments.findMany()
    * ```
    */
  get segments(): Prisma.SegmentsDelegate<GlobalReject>;

  /**
   * `prisma.subSegments`: Exposes CRUD operations for the **SubSegments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubSegments
    * const subSegments = await prisma.subSegments.findMany()
    * ```
    */
  get subSegments(): Prisma.SubSegmentsDelegate<GlobalReject>;

  /**
   * `prisma.segmentRequest`: Exposes CRUD operations for the **segmentRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SegmentRequests
    * const segmentRequests = await prisma.segmentRequest.findMany()
    * ```
    */
  get segmentRequest(): Prisma.segmentRequestDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.21.2
   * Query Engine version: b8c35d44de987a9691890b3ddf3e2e7effb9bf20
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Report: 'Report',
    UserGeo: 'UserGeo',
    UserAddress: 'UserAddress',
    User: 'User',
    UserSegments: 'UserSegments',
    Category: 'Category',
    Geo: 'Geo',
    Address: 'Address',
    Idea: 'Idea',
    Proposal: 'Proposal',
    Project: 'Project',
    Rating: 'Rating',
    Comment: 'Comment',
    UserCommentLikes: 'UserCommentLikes',
    UserCommentDislikes: 'UserCommentDislikes',
    Advertisements: 'Advertisements',
    SuperSegment: 'SuperSegment',
    Segments: 'Segments',
    SubSegments: 'SubSegments',
    segmentRequest: 'segmentRequest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Report
   */


  export type AggregateReport = {
    count: ReportCountAggregateOutputType | null
    avg: ReportAvgAggregateOutputType | null
    sum: ReportSumAggregateOutputType | null
    min: ReportMinAggregateOutputType | null
    max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    email: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    email: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    email: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    email?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    email?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    email?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs = {
    /**
     * Filter which Report to aggregate.
    **/
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
    **/
    orderBy?: Enumerable<ReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
    [P in keyof T & keyof AggregateReport]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }


    
    
  export type ReportGroupByArgs = {
    where?: ReportWhereInput
    orderBy?: Enumerable<ReportOrderByInput>
    by: Array<ReportScalarFieldEnum>
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ReportCountAggregateInputType | true
    avg?: ReportAvgAggregateInputType
    sum?: ReportSumAggregateInputType
    min?: ReportMinAggregateInputType
    max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    id: number
    email: string
    description: string
    createdAt: Date
    updatedAt: Date
    count: ReportCountAggregateOutputType | null
    avg: ReportAvgAggregateOutputType | null
    sum: ReportSumAggregateOutputType | null
    min: ReportMinAggregateOutputType | null
    max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Promise<Array<
    PickArray<ReportGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ReportGroupByOutputType))]: GetScalarType<T[P], ReportGroupByOutputType[P]>
    }
  >>
    

  export type ReportSelect = {
    id?: boolean
    email?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportGetPayload<
    S extends boolean | null | undefined | ReportArgs,
    U = keyof S
      > = S extends true
        ? Report
    : S extends undefined
    ? never
    : S extends ReportArgs | ReportFindManyArgs
    ?'include' extends U
    ? Report 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Report ?Report [P]
  : 
     never
  } 
    : Report
  : Report


  type ReportCountArgs = Merge<
    Omit<ReportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }
  >

  export interface ReportDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Report'> extends True ? CheckSelect<T, Prisma__ReportClient<Report>, Prisma__ReportClient<ReportGetPayload<T>>> : CheckSelect<T, Prisma__ReportClient<Report | null >, Prisma__ReportClient<ReportGetPayload<T> | null >>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Report'> extends True ? CheckSelect<T, Prisma__ReportClient<Report>, Prisma__ReportClient<ReportGetPayload<T>>> : CheckSelect<T, Prisma__ReportClient<Report | null >, Prisma__ReportClient<ReportGetPayload<T> | null >>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs>(
      args?: SelectSubset<T, ReportFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Report>>, PrismaPromise<Array<ReportGetPayload<T>>>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs>(
      args: SelectSubset<T, ReportCreateArgs>
    ): CheckSelect<T, Prisma__ReportClient<Report>, Prisma__ReportClient<ReportGetPayload<T>>>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs>(
      args?: SelectSubset<T, ReportCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs>(
      args: SelectSubset<T, ReportDeleteArgs>
    ): CheckSelect<T, Prisma__ReportClient<Report>, Prisma__ReportClient<ReportGetPayload<T>>>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs>(
      args: SelectSubset<T, ReportUpdateArgs>
    ): CheckSelect<T, Prisma__ReportClient<Report>, Prisma__ReportClient<ReportGetPayload<T>>>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs>(
      args?: SelectSubset<T, ReportDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs>(
      args: SelectSubset<T, ReportUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs>(
      args: SelectSubset<T, ReportUpsertArgs>
    ): CheckSelect<T, Prisma__ReportClient<Report>, Prisma__ReportClient<ReportGetPayload<T>>>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * Throw an Error if a Report can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Report to fetch.
    **/
    where: ReportWhereUniqueInput
  }


  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * Throw an Error if a Report can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Report to fetch.
    **/
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
    **/
    orderBy?: Enumerable<ReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
    **/
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
    **/
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * Filter, which Reports to fetch.
    **/
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
    **/
    orderBy?: Enumerable<ReportOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
    **/
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
    **/
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report create
   */
  export type ReportCreateArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * The data needed to create a Report.
    **/
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs = {
    data: Enumerable<ReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * The data needed to update a Report.
    **/
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
    **/
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs = {
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * The filter to search for the Report to update in case it exists.
    **/
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
    **/
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
    /**
     * Filter which Report to delete.
    **/
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs = {
    where?: ReportWhereInput
  }


  /**
   * Report without action
   */
  export type ReportArgs = {
    /**
     * Select specific fields to fetch from the Report
    **/
    select?: ReportSelect | null
  }



  /**
   * Model UserGeo
   */


  export type AggregateUserGeo = {
    count: UserGeoCountAggregateOutputType | null
    avg: UserGeoAvgAggregateOutputType | null
    sum: UserGeoSumAggregateOutputType | null
    min: UserGeoMinAggregateOutputType | null
    max: UserGeoMaxAggregateOutputType | null
  }

  export type UserGeoAvgAggregateOutputType = {
    id: number | null
    lat: Decimal | null
    lon: Decimal | null
    work_lat: Decimal | null
    work_lon: Decimal | null
    school_lat: Decimal | null
    school_lon: Decimal | null
  }

  export type UserGeoSumAggregateOutputType = {
    id: number | null
    lat: Decimal | null
    lon: Decimal | null
    work_lat: Decimal | null
    work_lon: Decimal | null
    school_lat: Decimal | null
    school_lon: Decimal | null
  }

  export type UserGeoMinAggregateOutputType = {
    id: number | null
    userId: string | null
    lat: Decimal | null
    lon: Decimal | null
    work_lat: Decimal | null
    work_lon: Decimal | null
    school_lat: Decimal | null
    school_lon: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGeoMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    lat: Decimal | null
    lon: Decimal | null
    work_lat: Decimal | null
    work_lon: Decimal | null
    school_lat: Decimal | null
    school_lon: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserGeoCountAggregateOutputType = {
    id: number
    userId: number
    lat: number
    lon: number
    work_lat: number
    work_lon: number
    school_lat: number
    school_lon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserGeoAvgAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    work_lat?: true
    work_lon?: true
    school_lat?: true
    school_lon?: true
  }

  export type UserGeoSumAggregateInputType = {
    id?: true
    lat?: true
    lon?: true
    work_lat?: true
    work_lon?: true
    school_lat?: true
    school_lon?: true
  }

  export type UserGeoMinAggregateInputType = {
    id?: true
    userId?: true
    lat?: true
    lon?: true
    work_lat?: true
    work_lon?: true
    school_lat?: true
    school_lon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGeoMaxAggregateInputType = {
    id?: true
    userId?: true
    lat?: true
    lon?: true
    work_lat?: true
    work_lon?: true
    school_lat?: true
    school_lon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserGeoCountAggregateInputType = {
    id?: true
    userId?: true
    lat?: true
    lon?: true
    work_lat?: true
    work_lon?: true
    school_lat?: true
    school_lon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserGeoAggregateArgs = {
    /**
     * Filter which UserGeo to aggregate.
    **/
    where?: UserGeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGeos to fetch.
    **/
    orderBy?: Enumerable<UserGeoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserGeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGeos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGeos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGeos
    **/
    count?: true | UserGeoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserGeoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserGeoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserGeoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserGeoMaxAggregateInputType
  }

  export type GetUserGeoAggregateType<T extends UserGeoAggregateArgs> = {
    [P in keyof T & keyof AggregateUserGeo]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGeo[P]>
      : GetScalarType<T[P], AggregateUserGeo[P]>
  }


    
    
  export type UserGeoGroupByArgs = {
    where?: UserGeoWhereInput
    orderBy?: Enumerable<UserGeoOrderByInput>
    by: Array<UserGeoScalarFieldEnum>
    having?: UserGeoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserGeoCountAggregateInputType | true
    avg?: UserGeoAvgAggregateInputType
    sum?: UserGeoSumAggregateInputType
    min?: UserGeoMinAggregateInputType
    max?: UserGeoMaxAggregateInputType
  }


  export type UserGeoGroupByOutputType = {
    id: number
    userId: string
    lat: Decimal | null
    lon: Decimal | null
    work_lat: Decimal | null
    work_lon: Decimal | null
    school_lat: Decimal | null
    school_lon: Decimal | null
    createdAt: Date
    updatedAt: Date
    count: UserGeoCountAggregateOutputType | null
    avg: UserGeoAvgAggregateOutputType | null
    sum: UserGeoSumAggregateOutputType | null
    min: UserGeoMinAggregateOutputType | null
    max: UserGeoMaxAggregateOutputType | null
  }

  type GetUserGeoGroupByPayload<T extends UserGeoGroupByArgs> = Promise<Array<
    PickArray<UserGeoGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserGeoGroupByOutputType))]: GetScalarType<T[P], UserGeoGroupByOutputType[P]>
    }
  >>
    

  export type UserGeoSelect = {
    id?: boolean
    userId?: boolean
    lat?: boolean
    lon?: boolean
    work_lat?: boolean
    work_lon?: boolean
    school_lat?: boolean
    school_lon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }

  export type UserGeoInclude = {
    user?: boolean | UserArgs
  }

  export type UserGeoGetPayload<
    S extends boolean | null | undefined | UserGeoArgs,
    U = keyof S
      > = S extends true
        ? UserGeo
    : S extends undefined
    ? never
    : S extends UserGeoArgs | UserGeoFindManyArgs
    ?'include' extends U
    ? UserGeo  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserGeo ?UserGeo [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : UserGeo
  : UserGeo


  type UserGeoCountArgs = Merge<
    Omit<UserGeoFindManyArgs, 'select' | 'include'> & {
      select?: UserGeoCountAggregateInputType | true
    }
  >

  export interface UserGeoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserGeo that matches the filter.
     * @param {UserGeoFindUniqueArgs} args - Arguments to find a UserGeo
     * @example
     * // Get one UserGeo
     * const userGeo = await prisma.userGeo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserGeoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserGeoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserGeo'> extends True ? CheckSelect<T, Prisma__UserGeoClient<UserGeo>, Prisma__UserGeoClient<UserGeoGetPayload<T>>> : CheckSelect<T, Prisma__UserGeoClient<UserGeo | null >, Prisma__UserGeoClient<UserGeoGetPayload<T> | null >>

    /**
     * Find the first UserGeo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGeoFindFirstArgs} args - Arguments to find a UserGeo
     * @example
     * // Get one UserGeo
     * const userGeo = await prisma.userGeo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserGeoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserGeoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserGeo'> extends True ? CheckSelect<T, Prisma__UserGeoClient<UserGeo>, Prisma__UserGeoClient<UserGeoGetPayload<T>>> : CheckSelect<T, Prisma__UserGeoClient<UserGeo | null >, Prisma__UserGeoClient<UserGeoGetPayload<T> | null >>

    /**
     * Find zero or more UserGeos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGeoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGeos
     * const userGeos = await prisma.userGeo.findMany()
     * 
     * // Get first 10 UserGeos
     * const userGeos = await prisma.userGeo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userGeoWithIdOnly = await prisma.userGeo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserGeoFindManyArgs>(
      args?: SelectSubset<T, UserGeoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserGeo>>, PrismaPromise<Array<UserGeoGetPayload<T>>>>

    /**
     * Create a UserGeo.
     * @param {UserGeoCreateArgs} args - Arguments to create a UserGeo.
     * @example
     * // Create one UserGeo
     * const UserGeo = await prisma.userGeo.create({
     *   data: {
     *     // ... data to create a UserGeo
     *   }
     * })
     * 
    **/
    create<T extends UserGeoCreateArgs>(
      args: SelectSubset<T, UserGeoCreateArgs>
    ): CheckSelect<T, Prisma__UserGeoClient<UserGeo>, Prisma__UserGeoClient<UserGeoGetPayload<T>>>

    /**
     * Create many UserGeos.
     *     @param {UserGeoCreateManyArgs} args - Arguments to create many UserGeos.
     *     @example
     *     // Create many UserGeos
     *     const userGeo = await prisma.userGeo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserGeoCreateManyArgs>(
      args?: SelectSubset<T, UserGeoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserGeo.
     * @param {UserGeoDeleteArgs} args - Arguments to delete one UserGeo.
     * @example
     * // Delete one UserGeo
     * const UserGeo = await prisma.userGeo.delete({
     *   where: {
     *     // ... filter to delete one UserGeo
     *   }
     * })
     * 
    **/
    delete<T extends UserGeoDeleteArgs>(
      args: SelectSubset<T, UserGeoDeleteArgs>
    ): CheckSelect<T, Prisma__UserGeoClient<UserGeo>, Prisma__UserGeoClient<UserGeoGetPayload<T>>>

    /**
     * Update one UserGeo.
     * @param {UserGeoUpdateArgs} args - Arguments to update one UserGeo.
     * @example
     * // Update one UserGeo
     * const userGeo = await prisma.userGeo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserGeoUpdateArgs>(
      args: SelectSubset<T, UserGeoUpdateArgs>
    ): CheckSelect<T, Prisma__UserGeoClient<UserGeo>, Prisma__UserGeoClient<UserGeoGetPayload<T>>>

    /**
     * Delete zero or more UserGeos.
     * @param {UserGeoDeleteManyArgs} args - Arguments to filter UserGeos to delete.
     * @example
     * // Delete a few UserGeos
     * const { count } = await prisma.userGeo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserGeoDeleteManyArgs>(
      args?: SelectSubset<T, UserGeoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGeos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGeoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGeos
     * const userGeo = await prisma.userGeo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserGeoUpdateManyArgs>(
      args: SelectSubset<T, UserGeoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserGeo.
     * @param {UserGeoUpsertArgs} args - Arguments to update or create a UserGeo.
     * @example
     * // Update or create a UserGeo
     * const userGeo = await prisma.userGeo.upsert({
     *   create: {
     *     // ... data to create a UserGeo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGeo we want to update
     *   }
     * })
    **/
    upsert<T extends UserGeoUpsertArgs>(
      args: SelectSubset<T, UserGeoUpsertArgs>
    ): CheckSelect<T, Prisma__UserGeoClient<UserGeo>, Prisma__UserGeoClient<UserGeoGetPayload<T>>>

    /**
     * Count the number of UserGeos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGeoCountArgs} args - Arguments to filter UserGeos to count.
     * @example
     * // Count the number of UserGeos
     * const count = await prisma.userGeo.count({
     *   where: {
     *     // ... the filter for the UserGeos we want to count
     *   }
     * })
    **/
    count<T extends UserGeoCountArgs>(
      args?: Subset<T, UserGeoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGeoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGeo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGeoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGeoAggregateArgs>(args: Subset<T, UserGeoAggregateArgs>): PrismaPromise<GetUserGeoAggregateType<T>>

    /**
     * Group by UserGeo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGeoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGeoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGeoGroupByArgs['orderBy'] }
        : { orderBy?: UserGeoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGeoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGeoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGeo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserGeoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserGeo findUnique
   */
  export type UserGeoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * Throw an Error if a UserGeo can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGeo to fetch.
    **/
    where: UserGeoWhereUniqueInput
  }


  /**
   * UserGeo findFirst
   */
  export type UserGeoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * Throw an Error if a UserGeo can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserGeo to fetch.
    **/
    where?: UserGeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGeos to fetch.
    **/
    orderBy?: Enumerable<UserGeoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGeos.
    **/
    cursor?: UserGeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGeos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGeos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGeos.
    **/
    distinct?: Enumerable<UserGeoScalarFieldEnum>
  }


  /**
   * UserGeo findMany
   */
  export type UserGeoFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * Filter, which UserGeos to fetch.
    **/
    where?: UserGeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGeos to fetch.
    **/
    orderBy?: Enumerable<UserGeoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGeos.
    **/
    cursor?: UserGeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGeos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGeos.
    **/
    skip?: number
    distinct?: Enumerable<UserGeoScalarFieldEnum>
  }


  /**
   * UserGeo create
   */
  export type UserGeoCreateArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * The data needed to create a UserGeo.
    **/
    data: XOR<UserGeoCreateInput, UserGeoUncheckedCreateInput>
  }


  /**
   * UserGeo createMany
   */
  export type UserGeoCreateManyArgs = {
    data: Enumerable<UserGeoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserGeo update
   */
  export type UserGeoUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * The data needed to update a UserGeo.
    **/
    data: XOR<UserGeoUpdateInput, UserGeoUncheckedUpdateInput>
    /**
     * Choose, which UserGeo to update.
    **/
    where: UserGeoWhereUniqueInput
  }


  /**
   * UserGeo updateMany
   */
  export type UserGeoUpdateManyArgs = {
    data: XOR<UserGeoUpdateManyMutationInput, UserGeoUncheckedUpdateManyInput>
    where?: UserGeoWhereInput
  }


  /**
   * UserGeo upsert
   */
  export type UserGeoUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * The filter to search for the UserGeo to update in case it exists.
    **/
    where: UserGeoWhereUniqueInput
    /**
     * In case the UserGeo found by the `where` argument doesn't exist, create a new UserGeo with this data.
    **/
    create: XOR<UserGeoCreateInput, UserGeoUncheckedCreateInput>
    /**
     * In case the UserGeo was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserGeoUpdateInput, UserGeoUncheckedUpdateInput>
  }


  /**
   * UserGeo delete
   */
  export type UserGeoDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
    /**
     * Filter which UserGeo to delete.
    **/
    where: UserGeoWhereUniqueInput
  }


  /**
   * UserGeo deleteMany
   */
  export type UserGeoDeleteManyArgs = {
    where?: UserGeoWhereInput
  }


  /**
   * UserGeo without action
   */
  export type UserGeoArgs = {
    /**
     * Select specific fields to fetch from the UserGeo
    **/
    select?: UserGeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserGeoInclude | null
  }



  /**
   * Model UserAddress
   */


  export type AggregateUserAddress = {
    count: UserAddressCountAggregateOutputType | null
    avg: UserAddressAvgAggregateOutputType | null
    sum: UserAddressSumAggregateOutputType | null
    min: UserAddressMinAggregateOutputType | null
    max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressAvgAggregateOutputType = {
    id: number | null
  }

  export type UserAddressSumAggregateOutputType = {
    id: number | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: number | null
    userId: string | null
    streetAddress: string | null
    streetAddress2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    streetAddress: string | null
    streetAddress2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    userId: number
    streetAddress: number
    streetAddress2: number
    city: number
    country: number
    postalCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAddressAvgAggregateInputType = {
    id?: true
  }

  export type UserAddressSumAggregateInputType = {
    id?: true
  }

  export type UserAddressMinAggregateInputType = {
    id?: true
    userId?: true
    streetAddress?: true
    streetAddress2?: true
    city?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    userId?: true
    streetAddress?: true
    streetAddress2?: true
    city?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    userId?: true
    streetAddress?: true
    streetAddress2?: true
    city?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAddressAggregateArgs = {
    /**
     * Filter which UserAddress to aggregate.
    **/
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
    **/
    orderBy?: Enumerable<UserAddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
    [P in keyof T & keyof AggregateUserAddress]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }


    
    
  export type UserAddressGroupByArgs = {
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByInput>
    by: Array<UserAddressScalarFieldEnum>
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserAddressCountAggregateInputType | true
    avg?: UserAddressAvgAggregateInputType
    sum?: UserAddressSumAggregateInputType
    min?: UserAddressMinAggregateInputType
    max?: UserAddressMaxAggregateInputType
  }


  export type UserAddressGroupByOutputType = {
    id: number
    userId: string
    streetAddress: string | null
    streetAddress2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date
    updatedAt: Date
    count: UserAddressCountAggregateOutputType | null
    avg: UserAddressAvgAggregateOutputType | null
    sum: UserAddressSumAggregateOutputType | null
    min: UserAddressMinAggregateOutputType | null
    max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Promise<Array<
    PickArray<UserAddressGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: GetScalarType<T[P], UserAddressGroupByOutputType[P]>
    }
  >>
    

  export type UserAddressSelect = {
    id?: boolean
    userId?: boolean
    streetAddress?: boolean
    streetAddress2?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }

  export type UserAddressInclude = {
    user?: boolean | UserArgs
  }

  export type UserAddressGetPayload<
    S extends boolean | null | undefined | UserAddressArgs,
    U = keyof S
      > = S extends true
        ? UserAddress
    : S extends undefined
    ? never
    : S extends UserAddressArgs | UserAddressFindManyArgs
    ?'include' extends U
    ? UserAddress  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserAddress ?UserAddress [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : UserAddress
  : UserAddress


  type UserAddressCountArgs = Merge<
    Omit<UserAddressFindManyArgs, 'select' | 'include'> & {
      select?: UserAddressCountAggregateInputType | true
    }
  >

  export interface UserAddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserAddress'> extends True ? CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>> : CheckSelect<T, Prisma__UserAddressClient<UserAddress | null >, Prisma__UserAddressClient<UserAddressGetPayload<T> | null >>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserAddress'> extends True ? CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>> : CheckSelect<T, Prisma__UserAddressClient<UserAddress | null >, Prisma__UserAddressClient<UserAddressGetPayload<T> | null >>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAddressFindManyArgs>(
      args?: SelectSubset<T, UserAddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserAddress>>, PrismaPromise<Array<UserAddressGetPayload<T>>>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
    **/
    create<T extends UserAddressCreateArgs>(
      args: SelectSubset<T, UserAddressCreateArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Create many UserAddresses.
     *     @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     *     @example
     *     // Create many UserAddresses
     *     const userAddress = await prisma.userAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAddressCreateManyArgs>(
      args?: SelectSubset<T, UserAddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
    **/
    delete<T extends UserAddressDeleteArgs>(
      args: SelectSubset<T, UserAddressDeleteArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAddressUpdateArgs>(
      args: SelectSubset<T, UserAddressUpdateArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAddressDeleteManyArgs>(
      args?: SelectSubset<T, UserAddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAddressUpdateManyArgs>(
      args: SelectSubset<T, UserAddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
    **/
    upsert<T extends UserAddressUpsertArgs>(
      args: SelectSubset<T, UserAddressUpsertArgs>
    ): CheckSelect<T, Prisma__UserAddressClient<UserAddress>, Prisma__UserAddressClient<UserAddressGetPayload<T>>>

    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserAddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserAddress findUnique
   */
  export type UserAddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * Throw an Error if a UserAddress can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserAddress to fetch.
    **/
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress findFirst
   */
  export type UserAddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * Throw an Error if a UserAddress can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserAddress to fetch.
    **/
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
    **/
    orderBy?: Enumerable<UserAddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
    **/
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
    **/
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddresses to fetch.
    **/
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
    **/
    orderBy?: Enumerable<UserAddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
    **/
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
    **/
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * The data needed to create a UserAddress.
    **/
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }


  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs = {
    data: Enumerable<UserAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * The data needed to update a UserAddress.
    **/
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
    **/
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs = {
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
    **/
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
    **/
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }


  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
    /**
     * Filter which UserAddress to delete.
    **/
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs = {
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress without action
   */
  export type UserAddressArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
    **/
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserAddressInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    userType: UserType | null
    email: string | null
    password: string | null
    fname: string | null
    lname: string | null
    createdAt: Date | null
    updatedAt: Date | null
    imagePath: string | null
    passCode: string | null
    banned: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    userType: UserType | null
    email: string | null
    password: string | null
    fname: string | null
    lname: string | null
    createdAt: Date | null
    updatedAt: Date | null
    imagePath: string | null
    passCode: string | null
    banned: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    userType: number
    email: number
    password: number
    fname: number
    lname: number
    createdAt: number
    updatedAt: number
    imagePath: number
    passCode: number
    banned: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    userType?: true
    email?: true
    password?: true
    fname?: true
    lname?: true
    createdAt?: true
    updatedAt?: true
    imagePath?: true
    passCode?: true
    banned?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    userType?: true
    email?: true
    password?: true
    fname?: true
    lname?: true
    createdAt?: true
    updatedAt?: true
    imagePath?: true
    passCode?: true
    banned?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    userType?: true
    email?: true
    password?: true
    fname?: true
    lname?: true
    createdAt?: true
    updatedAt?: true
    imagePath?: true
    passCode?: true
    banned?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserCountAggregateInputType | true
    min?: UserMinAggregateInputType
    max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    userType: UserType
    email: string
    password: string
    fname: string | null
    lname: string | null
    createdAt: Date
    updatedAt: Date
    imagePath: string | null
    passCode: string | null
    banned: boolean
    count: UserCountAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<Array<
    PickArray<UserGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserGroupByOutputType))]: GetScalarType<T[P], UserGroupByOutputType[P]>
    }
  >>
    

  export type UserSelect = {
    id?: boolean
    userType?: boolean
    email?: boolean
    password?: boolean
    fname?: boolean
    lname?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    imagePath?: boolean
    passCode?: boolean
    banned?: boolean
    address?: boolean | UserAddressArgs
    geo?: boolean | UserGeoArgs
    ideas?: boolean | IdeaFindManyArgs
    proposals?: boolean | ProposalFindManyArgs
    championedProposals?: boolean | ProposalFindManyArgs
    championedIdeas?: boolean | IdeaFindManyArgs
    ideaRatings?: boolean | RatingFindManyArgs
    ideaComments?: boolean | CommentFindManyArgs
    ideaCommentLikes?: boolean | UserCommentLikesFindManyArgs
    ideaCommentDislikes?: boolean | UserCommentDislikesFindManyArgs
    Advertisements?: boolean | AdvertisementsFindManyArgs
    segmentRequest?: boolean | segmentRequestFindManyArgs
    userSegments?: boolean | UserSegmentsArgs
  }

  export type UserInclude = {
    address?: boolean | UserAddressArgs
    geo?: boolean | UserGeoArgs
    ideas?: boolean | IdeaFindManyArgs
    proposals?: boolean | ProposalFindManyArgs
    championedProposals?: boolean | ProposalFindManyArgs
    championedIdeas?: boolean | IdeaFindManyArgs
    ideaRatings?: boolean | RatingFindManyArgs
    ideaComments?: boolean | CommentFindManyArgs
    ideaCommentLikes?: boolean | UserCommentLikesFindManyArgs
    ideaCommentDislikes?: boolean | UserCommentDislikesFindManyArgs
    Advertisements?: boolean | AdvertisementsFindManyArgs
    segmentRequest?: boolean | segmentRequestFindManyArgs
    userSegments?: boolean | UserSegmentsArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'address'
        ? UserAddressGetPayload<S['include'][P]> | null :
        P extends 'geo'
        ? UserGeoGetPayload<S['include'][P]> | null :
        P extends 'ideas'
        ? Array < IdeaGetPayload<S['include'][P]>>  :
        P extends 'proposals'
        ? Array < ProposalGetPayload<S['include'][P]>>  :
        P extends 'championedProposals'
        ? Array < ProposalGetPayload<S['include'][P]>>  :
        P extends 'championedIdeas'
        ? Array < IdeaGetPayload<S['include'][P]>>  :
        P extends 'ideaRatings'
        ? Array < RatingGetPayload<S['include'][P]>>  :
        P extends 'ideaComments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'ideaCommentLikes'
        ? Array < UserCommentLikesGetPayload<S['include'][P]>>  :
        P extends 'ideaCommentDislikes'
        ? Array < UserCommentDislikesGetPayload<S['include'][P]>>  :
        P extends 'Advertisements'
        ? Array < AdvertisementsGetPayload<S['include'][P]>>  :
        P extends 'segmentRequest'
        ? Array < segmentRequestGetPayload<S['include'][P]>>  :
        P extends 'userSegments'
        ? UserSegmentsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'address'
        ? UserAddressGetPayload<S['select'][P]> | null :
        P extends 'geo'
        ? UserGeoGetPayload<S['select'][P]> | null :
        P extends 'ideas'
        ? Array < IdeaGetPayload<S['select'][P]>>  :
        P extends 'proposals'
        ? Array < ProposalGetPayload<S['select'][P]>>  :
        P extends 'championedProposals'
        ? Array < ProposalGetPayload<S['select'][P]>>  :
        P extends 'championedIdeas'
        ? Array < IdeaGetPayload<S['select'][P]>>  :
        P extends 'ideaRatings'
        ? Array < RatingGetPayload<S['select'][P]>>  :
        P extends 'ideaComments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'ideaCommentLikes'
        ? Array < UserCommentLikesGetPayload<S['select'][P]>>  :
        P extends 'ideaCommentDislikes'
        ? Array < UserCommentDislikesGetPayload<S['select'][P]>>  :
        P extends 'Advertisements'
        ? Array < AdvertisementsGetPayload<S['select'][P]>>  :
        P extends 'segmentRequest'
        ? Array < segmentRequestGetPayload<S['select'][P]>>  :
        P extends 'userSegments'
        ? UserSegmentsGetPayload<S['select'][P]> | null : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    address<T extends UserAddressArgs = {}>(args?: Subset<T, UserAddressArgs>): CheckSelect<T, Prisma__UserAddressClient<UserAddress | null >, Prisma__UserAddressClient<UserAddressGetPayload<T> | null >>;

    geo<T extends UserGeoArgs = {}>(args?: Subset<T, UserGeoArgs>): CheckSelect<T, Prisma__UserGeoClient<UserGeo | null >, Prisma__UserGeoClient<UserGeoGetPayload<T> | null >>;

    ideas<T extends IdeaFindManyArgs = {}>(args?: Subset<T, IdeaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>;

    proposals<T extends ProposalFindManyArgs = {}>(args?: Subset<T, ProposalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>;

    championedProposals<T extends ProposalFindManyArgs = {}>(args?: Subset<T, ProposalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>;

    championedIdeas<T extends IdeaFindManyArgs = {}>(args?: Subset<T, IdeaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>;

    ideaRatings<T extends RatingFindManyArgs = {}>(args?: Subset<T, RatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Rating>>, PrismaPromise<Array<RatingGetPayload<T>>>>;

    ideaComments<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    ideaCommentLikes<T extends UserCommentLikesFindManyArgs = {}>(args?: Subset<T, UserCommentLikesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCommentLikes>>, PrismaPromise<Array<UserCommentLikesGetPayload<T>>>>;

    ideaCommentDislikes<T extends UserCommentDislikesFindManyArgs = {}>(args?: Subset<T, UserCommentDislikesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCommentDislikes>>, PrismaPromise<Array<UserCommentDislikesGetPayload<T>>>>;

    Advertisements<T extends AdvertisementsFindManyArgs = {}>(args?: Subset<T, AdvertisementsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Advertisements>>, PrismaPromise<Array<AdvertisementsGetPayload<T>>>>;

    segmentRequest<T extends segmentRequestFindManyArgs = {}>(args?: Subset<T, segmentRequestFindManyArgs>): CheckSelect<T, PrismaPromise<Array<segmentRequest>>, PrismaPromise<Array<segmentRequestGetPayload<T>>>>;

    userSegments<T extends UserSegmentsArgs = {}>(args?: Subset<T, UserSegmentsArgs>): CheckSelect<T, Prisma__UserSegmentsClient<UserSegments | null >, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model UserSegments
   */


  export type AggregateUserSegments = {
    count: UserSegmentsCountAggregateOutputType | null
    avg: UserSegmentsAvgAggregateOutputType | null
    sum: UserSegmentsSumAggregateOutputType | null
    min: UserSegmentsMinAggregateOutputType | null
    max: UserSegmentsMaxAggregateOutputType | null
  }

  export type UserSegmentsAvgAggregateOutputType = {
    homeSuperSegId: number | null
    workSuperSegId: number | null
    schoolSuperSegId: number | null
    homeSegmentId: number | null
    workSegmentId: number | null
    schoolSegmentId: number | null
    homeSubSegmentId: number | null
    workSubSegmentId: number | null
    schoolSubSegmentId: number | null
  }

  export type UserSegmentsSumAggregateOutputType = {
    homeSuperSegId: number | null
    workSuperSegId: number | null
    schoolSuperSegId: number | null
    homeSegmentId: number | null
    workSegmentId: number | null
    schoolSegmentId: number | null
    homeSubSegmentId: number | null
    workSubSegmentId: number | null
    schoolSubSegmentId: number | null
  }

  export type UserSegmentsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    homeSuperSegId: number | null
    homeSuperSegName: string | null
    workSuperSegId: number | null
    workSuperSegName: string | null
    schoolSuperSegId: number | null
    schoolSuperSegName: string | null
    homeSegmentId: number | null
    homeSegmentName: string | null
    workSegmentId: number | null
    workSegmentName: string | null
    schoolSegmentId: number | null
    schoolSegmentName: string | null
    homeSubSegmentId: number | null
    homeSubSegmentName: string | null
    workSubSegmentId: number | null
    workSubSegmentName: string | null
    schoolSubSegmentId: number | null
    schoolSubSegmentName: string | null
  }

  export type UserSegmentsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    homeSuperSegId: number | null
    homeSuperSegName: string | null
    workSuperSegId: number | null
    workSuperSegName: string | null
    schoolSuperSegId: number | null
    schoolSuperSegName: string | null
    homeSegmentId: number | null
    homeSegmentName: string | null
    workSegmentId: number | null
    workSegmentName: string | null
    schoolSegmentId: number | null
    schoolSegmentName: string | null
    homeSubSegmentId: number | null
    homeSubSegmentName: string | null
    workSubSegmentId: number | null
    workSubSegmentName: string | null
    schoolSubSegmentId: number | null
    schoolSubSegmentName: string | null
  }

  export type UserSegmentsCountAggregateOutputType = {
    id: number
    userId: number
    homeSuperSegId: number
    homeSuperSegName: number
    workSuperSegId: number
    workSuperSegName: number
    schoolSuperSegId: number
    schoolSuperSegName: number
    homeSegmentId: number
    homeSegmentName: number
    workSegmentId: number
    workSegmentName: number
    schoolSegmentId: number
    schoolSegmentName: number
    homeSubSegmentId: number
    homeSubSegmentName: number
    workSubSegmentId: number
    workSubSegmentName: number
    schoolSubSegmentId: number
    schoolSubSegmentName: number
    _all: number
  }


  export type UserSegmentsAvgAggregateInputType = {
    homeSuperSegId?: true
    workSuperSegId?: true
    schoolSuperSegId?: true
    homeSegmentId?: true
    workSegmentId?: true
    schoolSegmentId?: true
    homeSubSegmentId?: true
    workSubSegmentId?: true
    schoolSubSegmentId?: true
  }

  export type UserSegmentsSumAggregateInputType = {
    homeSuperSegId?: true
    workSuperSegId?: true
    schoolSuperSegId?: true
    homeSegmentId?: true
    workSegmentId?: true
    schoolSegmentId?: true
    homeSubSegmentId?: true
    workSubSegmentId?: true
    schoolSubSegmentId?: true
  }

  export type UserSegmentsMinAggregateInputType = {
    id?: true
    userId?: true
    homeSuperSegId?: true
    homeSuperSegName?: true
    workSuperSegId?: true
    workSuperSegName?: true
    schoolSuperSegId?: true
    schoolSuperSegName?: true
    homeSegmentId?: true
    homeSegmentName?: true
    workSegmentId?: true
    workSegmentName?: true
    schoolSegmentId?: true
    schoolSegmentName?: true
    homeSubSegmentId?: true
    homeSubSegmentName?: true
    workSubSegmentId?: true
    workSubSegmentName?: true
    schoolSubSegmentId?: true
    schoolSubSegmentName?: true
  }

  export type UserSegmentsMaxAggregateInputType = {
    id?: true
    userId?: true
    homeSuperSegId?: true
    homeSuperSegName?: true
    workSuperSegId?: true
    workSuperSegName?: true
    schoolSuperSegId?: true
    schoolSuperSegName?: true
    homeSegmentId?: true
    homeSegmentName?: true
    workSegmentId?: true
    workSegmentName?: true
    schoolSegmentId?: true
    schoolSegmentName?: true
    homeSubSegmentId?: true
    homeSubSegmentName?: true
    workSubSegmentId?: true
    workSubSegmentName?: true
    schoolSubSegmentId?: true
    schoolSubSegmentName?: true
  }

  export type UserSegmentsCountAggregateInputType = {
    id?: true
    userId?: true
    homeSuperSegId?: true
    homeSuperSegName?: true
    workSuperSegId?: true
    workSuperSegName?: true
    schoolSuperSegId?: true
    schoolSuperSegName?: true
    homeSegmentId?: true
    homeSegmentName?: true
    workSegmentId?: true
    workSegmentName?: true
    schoolSegmentId?: true
    schoolSegmentName?: true
    homeSubSegmentId?: true
    homeSubSegmentName?: true
    workSubSegmentId?: true
    workSubSegmentName?: true
    schoolSubSegmentId?: true
    schoolSubSegmentName?: true
    _all?: true
  }

  export type UserSegmentsAggregateArgs = {
    /**
     * Filter which UserSegments to aggregate.
    **/
    where?: UserSegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSegments to fetch.
    **/
    orderBy?: Enumerable<UserSegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserSegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSegments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSegments
    **/
    count?: true | UserSegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserSegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserSegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserSegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserSegmentsMaxAggregateInputType
  }

  export type GetUserSegmentsAggregateType<T extends UserSegmentsAggregateArgs> = {
    [P in keyof T & keyof AggregateUserSegments]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSegments[P]>
      : GetScalarType<T[P], AggregateUserSegments[P]>
  }


    
    
  export type UserSegmentsGroupByArgs = {
    where?: UserSegmentsWhereInput
    orderBy?: Enumerable<UserSegmentsOrderByInput>
    by: Array<UserSegmentsScalarFieldEnum>
    having?: UserSegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserSegmentsCountAggregateInputType | true
    avg?: UserSegmentsAvgAggregateInputType
    sum?: UserSegmentsSumAggregateInputType
    min?: UserSegmentsMinAggregateInputType
    max?: UserSegmentsMaxAggregateInputType
  }


  export type UserSegmentsGroupByOutputType = {
    id: string
    userId: string
    homeSuperSegId: number | null
    homeSuperSegName: string | null
    workSuperSegId: number | null
    workSuperSegName: string | null
    schoolSuperSegId: number | null
    schoolSuperSegName: string | null
    homeSegmentId: number | null
    homeSegmentName: string | null
    workSegmentId: number | null
    workSegmentName: string | null
    schoolSegmentId: number | null
    schoolSegmentName: string | null
    homeSubSegmentId: number | null
    homeSubSegmentName: string | null
    workSubSegmentId: number | null
    workSubSegmentName: string | null
    schoolSubSegmentId: number | null
    schoolSubSegmentName: string | null
    count: UserSegmentsCountAggregateOutputType | null
    avg: UserSegmentsAvgAggregateOutputType | null
    sum: UserSegmentsSumAggregateOutputType | null
    min: UserSegmentsMinAggregateOutputType | null
    max: UserSegmentsMaxAggregateOutputType | null
  }

  type GetUserSegmentsGroupByPayload<T extends UserSegmentsGroupByArgs> = Promise<Array<
    PickArray<UserSegmentsGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserSegmentsGroupByOutputType))]: GetScalarType<T[P], UserSegmentsGroupByOutputType[P]>
    }
  >>
    

  export type UserSegmentsSelect = {
    id?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    homeSuperSegId?: boolean
    homeSuperSegName?: boolean
    workSuperSegId?: boolean
    workSuperSegName?: boolean
    schoolSuperSegId?: boolean
    schoolSuperSegName?: boolean
    homeSegmentId?: boolean
    homeSegmentName?: boolean
    workSegmentId?: boolean
    workSegmentName?: boolean
    schoolSegmentId?: boolean
    schoolSegmentName?: boolean
    homeSubSegmentId?: boolean
    homeSubSegmentName?: boolean
    workSubSegmentId?: boolean
    workSubSegmentName?: boolean
    schoolSubSegmentId?: boolean
    schoolSubSegmentName?: boolean
    homeSuperSeg?: boolean | SuperSegmentArgs
    workSuperSeg?: boolean | SuperSegmentArgs
    schoolSuperSeg?: boolean | SuperSegmentArgs
    homeSegment?: boolean | SegmentsArgs
    workSegment?: boolean | SegmentsArgs
    schoolSegment?: boolean | SegmentsArgs
    homeSubSegment?: boolean | SubSegmentsArgs
    workSubSegment?: boolean | SubSegmentsArgs
    schoolSubSegment?: boolean | SubSegmentsArgs
    IdeaComment?: boolean | CommentFindManyArgs
  }

  export type UserSegmentsInclude = {
    user?: boolean | UserArgs
    homeSuperSeg?: boolean | SuperSegmentArgs
    workSuperSeg?: boolean | SuperSegmentArgs
    schoolSuperSeg?: boolean | SuperSegmentArgs
    homeSegment?: boolean | SegmentsArgs
    workSegment?: boolean | SegmentsArgs
    schoolSegment?: boolean | SegmentsArgs
    homeSubSegment?: boolean | SubSegmentsArgs
    workSubSegment?: boolean | SubSegmentsArgs
    schoolSubSegment?: boolean | SubSegmentsArgs
    IdeaComment?: boolean | CommentFindManyArgs
  }

  export type UserSegmentsGetPayload<
    S extends boolean | null | undefined | UserSegmentsArgs,
    U = keyof S
      > = S extends true
        ? UserSegments
    : S extends undefined
    ? never
    : S extends UserSegmentsArgs | UserSegmentsFindManyArgs
    ?'include' extends U
    ? UserSegments  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'homeSuperSeg'
        ? SuperSegmentGetPayload<S['include'][P]> | null :
        P extends 'workSuperSeg'
        ? SuperSegmentGetPayload<S['include'][P]> | null :
        P extends 'schoolSuperSeg'
        ? SuperSegmentGetPayload<S['include'][P]> | null :
        P extends 'homeSegment'
        ? SegmentsGetPayload<S['include'][P]> | null :
        P extends 'workSegment'
        ? SegmentsGetPayload<S['include'][P]> | null :
        P extends 'schoolSegment'
        ? SegmentsGetPayload<S['include'][P]> | null :
        P extends 'homeSubSegment'
        ? SubSegmentsGetPayload<S['include'][P]> | null :
        P extends 'workSubSegment'
        ? SubSegmentsGetPayload<S['include'][P]> | null :
        P extends 'schoolSubSegment'
        ? SubSegmentsGetPayload<S['include'][P]> | null :
        P extends 'IdeaComment'
        ? Array < CommentGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserSegments ?UserSegments [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'homeSuperSeg'
        ? SuperSegmentGetPayload<S['select'][P]> | null :
        P extends 'workSuperSeg'
        ? SuperSegmentGetPayload<S['select'][P]> | null :
        P extends 'schoolSuperSeg'
        ? SuperSegmentGetPayload<S['select'][P]> | null :
        P extends 'homeSegment'
        ? SegmentsGetPayload<S['select'][P]> | null :
        P extends 'workSegment'
        ? SegmentsGetPayload<S['select'][P]> | null :
        P extends 'schoolSegment'
        ? SegmentsGetPayload<S['select'][P]> | null :
        P extends 'homeSubSegment'
        ? SubSegmentsGetPayload<S['select'][P]> | null :
        P extends 'workSubSegment'
        ? SubSegmentsGetPayload<S['select'][P]> | null :
        P extends 'schoolSubSegment'
        ? SubSegmentsGetPayload<S['select'][P]> | null :
        P extends 'IdeaComment'
        ? Array < CommentGetPayload<S['select'][P]>>  : never
  } 
    : UserSegments
  : UserSegments


  type UserSegmentsCountArgs = Merge<
    Omit<UserSegmentsFindManyArgs, 'select' | 'include'> & {
      select?: UserSegmentsCountAggregateInputType | true
    }
  >

  export interface UserSegmentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserSegments that matches the filter.
     * @param {UserSegmentsFindUniqueArgs} args - Arguments to find a UserSegments
     * @example
     * // Get one UserSegments
     * const userSegments = await prisma.userSegments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSegmentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserSegmentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserSegments'> extends True ? CheckSelect<T, Prisma__UserSegmentsClient<UserSegments>, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T>>> : CheckSelect<T, Prisma__UserSegmentsClient<UserSegments | null >, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T> | null >>

    /**
     * Find the first UserSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSegmentsFindFirstArgs} args - Arguments to find a UserSegments
     * @example
     * // Get one UserSegments
     * const userSegments = await prisma.userSegments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSegmentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserSegmentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserSegments'> extends True ? CheckSelect<T, Prisma__UserSegmentsClient<UserSegments>, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T>>> : CheckSelect<T, Prisma__UserSegmentsClient<UserSegments | null >, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T> | null >>

    /**
     * Find zero or more UserSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSegments
     * const userSegments = await prisma.userSegments.findMany()
     * 
     * // Get first 10 UserSegments
     * const userSegments = await prisma.userSegments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSegmentsWithIdOnly = await prisma.userSegments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserSegmentsFindManyArgs>(
      args?: SelectSubset<T, UserSegmentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>

    /**
     * Create a UserSegments.
     * @param {UserSegmentsCreateArgs} args - Arguments to create a UserSegments.
     * @example
     * // Create one UserSegments
     * const UserSegments = await prisma.userSegments.create({
     *   data: {
     *     // ... data to create a UserSegments
     *   }
     * })
     * 
    **/
    create<T extends UserSegmentsCreateArgs>(
      args: SelectSubset<T, UserSegmentsCreateArgs>
    ): CheckSelect<T, Prisma__UserSegmentsClient<UserSegments>, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T>>>

    /**
     * Create many UserSegments.
     *     @param {UserSegmentsCreateManyArgs} args - Arguments to create many UserSegments.
     *     @example
     *     // Create many UserSegments
     *     const userSegments = await prisma.userSegments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserSegmentsCreateManyArgs>(
      args?: SelectSubset<T, UserSegmentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserSegments.
     * @param {UserSegmentsDeleteArgs} args - Arguments to delete one UserSegments.
     * @example
     * // Delete one UserSegments
     * const UserSegments = await prisma.userSegments.delete({
     *   where: {
     *     // ... filter to delete one UserSegments
     *   }
     * })
     * 
    **/
    delete<T extends UserSegmentsDeleteArgs>(
      args: SelectSubset<T, UserSegmentsDeleteArgs>
    ): CheckSelect<T, Prisma__UserSegmentsClient<UserSegments>, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T>>>

    /**
     * Update one UserSegments.
     * @param {UserSegmentsUpdateArgs} args - Arguments to update one UserSegments.
     * @example
     * // Update one UserSegments
     * const userSegments = await prisma.userSegments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSegmentsUpdateArgs>(
      args: SelectSubset<T, UserSegmentsUpdateArgs>
    ): CheckSelect<T, Prisma__UserSegmentsClient<UserSegments>, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T>>>

    /**
     * Delete zero or more UserSegments.
     * @param {UserSegmentsDeleteManyArgs} args - Arguments to filter UserSegments to delete.
     * @example
     * // Delete a few UserSegments
     * const { count } = await prisma.userSegments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSegmentsDeleteManyArgs>(
      args?: SelectSubset<T, UserSegmentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSegments
     * const userSegments = await prisma.userSegments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSegmentsUpdateManyArgs>(
      args: SelectSubset<T, UserSegmentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSegments.
     * @param {UserSegmentsUpsertArgs} args - Arguments to update or create a UserSegments.
     * @example
     * // Update or create a UserSegments
     * const userSegments = await prisma.userSegments.upsert({
     *   create: {
     *     // ... data to create a UserSegments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSegments we want to update
     *   }
     * })
    **/
    upsert<T extends UserSegmentsUpsertArgs>(
      args: SelectSubset<T, UserSegmentsUpsertArgs>
    ): CheckSelect<T, Prisma__UserSegmentsClient<UserSegments>, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T>>>

    /**
     * Count the number of UserSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSegmentsCountArgs} args - Arguments to filter UserSegments to count.
     * @example
     * // Count the number of UserSegments
     * const count = await prisma.userSegments.count({
     *   where: {
     *     // ... the filter for the UserSegments we want to count
     *   }
     * })
    **/
    count<T extends UserSegmentsCountArgs>(
      args?: Subset<T, UserSegmentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSegmentsAggregateArgs>(args: Subset<T, UserSegmentsAggregateArgs>): PrismaPromise<GetUserSegmentsAggregateType<T>>

    /**
     * Group by UserSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSegmentsGroupByArgs['orderBy'] }
        : { orderBy?: UserSegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSegmentsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSegments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserSegmentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    homeSuperSeg<T extends SuperSegmentArgs = {}>(args?: Subset<T, SuperSegmentArgs>): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>;

    workSuperSeg<T extends SuperSegmentArgs = {}>(args?: Subset<T, SuperSegmentArgs>): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>;

    schoolSuperSeg<T extends SuperSegmentArgs = {}>(args?: Subset<T, SuperSegmentArgs>): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>;

    homeSegment<T extends SegmentsArgs = {}>(args?: Subset<T, SegmentsArgs>): CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>;

    workSegment<T extends SegmentsArgs = {}>(args?: Subset<T, SegmentsArgs>): CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>;

    schoolSegment<T extends SegmentsArgs = {}>(args?: Subset<T, SegmentsArgs>): CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>;

    homeSubSegment<T extends SubSegmentsArgs = {}>(args?: Subset<T, SubSegmentsArgs>): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>;

    workSubSegment<T extends SubSegmentsArgs = {}>(args?: Subset<T, SubSegmentsArgs>): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>;

    schoolSubSegment<T extends SubSegmentsArgs = {}>(args?: Subset<T, SubSegmentsArgs>): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>;

    IdeaComment<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserSegments findUnique
   */
  export type UserSegmentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * Throw an Error if a UserSegments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSegments to fetch.
    **/
    where: UserSegmentsWhereUniqueInput
  }


  /**
   * UserSegments findFirst
   */
  export type UserSegmentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * Throw an Error if a UserSegments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserSegments to fetch.
    **/
    where?: UserSegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSegments to fetch.
    **/
    orderBy?: Enumerable<UserSegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSegments.
    **/
    cursor?: UserSegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSegments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSegments.
    **/
    distinct?: Enumerable<UserSegmentsScalarFieldEnum>
  }


  /**
   * UserSegments findMany
   */
  export type UserSegmentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * Filter, which UserSegments to fetch.
    **/
    where?: UserSegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSegments to fetch.
    **/
    orderBy?: Enumerable<UserSegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSegments.
    **/
    cursor?: UserSegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSegments.
    **/
    skip?: number
    distinct?: Enumerable<UserSegmentsScalarFieldEnum>
  }


  /**
   * UserSegments create
   */
  export type UserSegmentsCreateArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * The data needed to create a UserSegments.
    **/
    data: XOR<UserSegmentsCreateInput, UserSegmentsUncheckedCreateInput>
  }


  /**
   * UserSegments createMany
   */
  export type UserSegmentsCreateManyArgs = {
    data: Enumerable<UserSegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserSegments update
   */
  export type UserSegmentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * The data needed to update a UserSegments.
    **/
    data: XOR<UserSegmentsUpdateInput, UserSegmentsUncheckedUpdateInput>
    /**
     * Choose, which UserSegments to update.
    **/
    where: UserSegmentsWhereUniqueInput
  }


  /**
   * UserSegments updateMany
   */
  export type UserSegmentsUpdateManyArgs = {
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyInput>
    where?: UserSegmentsWhereInput
  }


  /**
   * UserSegments upsert
   */
  export type UserSegmentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * The filter to search for the UserSegments to update in case it exists.
    **/
    where: UserSegmentsWhereUniqueInput
    /**
     * In case the UserSegments found by the `where` argument doesn't exist, create a new UserSegments with this data.
    **/
    create: XOR<UserSegmentsCreateInput, UserSegmentsUncheckedCreateInput>
    /**
     * In case the UserSegments was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserSegmentsUpdateInput, UserSegmentsUncheckedUpdateInput>
  }


  /**
   * UserSegments delete
   */
  export type UserSegmentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
    /**
     * Filter which UserSegments to delete.
    **/
    where: UserSegmentsWhereUniqueInput
  }


  /**
   * UserSegments deleteMany
   */
  export type UserSegmentsDeleteManyArgs = {
    where?: UserSegmentsWhereInput
  }


  /**
   * UserSegments without action
   */
  export type UserSegmentsArgs = {
    /**
     * Select specific fields to fetch from the UserSegments
    **/
    select?: UserSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserSegmentsInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    count: CategoryCountAggregateOutputType | null
    avg: CategoryAvgAggregateOutputType | null
    sum: CategorySumAggregateOutputType | null
    min: CategoryMinAggregateOutputType | null
    max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
    **/
    orderBy?: Enumerable<CategoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
    [P in keyof T & keyof AggregateCategory]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }


    
    
  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByInput>
    by: Array<CategoryScalarFieldEnum>
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CategoryCountAggregateInputType | true
    avg?: CategoryAvgAggregateInputType
    sum?: CategorySumAggregateInputType
    min?: CategoryMinAggregateInputType
    max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    count: CategoryCountAggregateOutputType | null
    avg: CategoryAvgAggregateOutputType | null
    sum: CategorySumAggregateOutputType | null
    min: CategoryMinAggregateOutputType | null
    max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Promise<Array<
    PickArray<CategoryGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: GetScalarType<T[P], CategoryGroupByOutputType[P]>
    }
  >>
    

  export type CategorySelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ideas?: boolean | IdeaFindManyArgs
    proposals?: boolean | ProposalFindManyArgs
  }

  export type CategoryInclude = {
    ideas?: boolean | IdeaFindManyArgs
    proposals?: boolean | ProposalFindManyArgs
  }

  export type CategoryGetPayload<
    S extends boolean | null | undefined | CategoryArgs,
    U = keyof S
      > = S extends true
        ? Category
    : S extends undefined
    ? never
    : S extends CategoryArgs | CategoryFindManyArgs
    ?'include' extends U
    ? Category  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ideas'
        ? Array < IdeaGetPayload<S['include'][P]>>  :
        P extends 'proposals'
        ? Array < ProposalGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Category ?Category [P]
  : 
          P extends 'ideas'
        ? Array < IdeaGetPayload<S['select'][P]>>  :
        P extends 'proposals'
        ? Array < ProposalGetPayload<S['select'][P]>>  : never
  } 
    : Category
  : Category


  type CategoryCountArgs = Merge<
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface CategoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>> : CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Category>>, PrismaPromise<Array<CategoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): CheckSelect<T, Prisma__CategoryClient<Category>, Prisma__CategoryClient<CategoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ideas<T extends IdeaFindManyArgs = {}>(args?: Subset<T, IdeaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>;

    proposals<T extends ProposalFindManyArgs = {}>(args?: Subset<T, ProposalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Throw an Error if a Category can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Category to fetch.
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
    **/
    orderBy?: Enumerable<CategoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
    **/
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
    **/
    orderBy?: Enumerable<CategoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
    **/
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
    **/
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    data: Enumerable<CategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
    **/
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
    **/
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
    **/
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
    **/
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    where?: CategoryWhereInput
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
    **/
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CategoryInclude | null
  }



  /**
   * Model Geo
   */


  export type AggregateGeo = {
    count: GeoCountAggregateOutputType | null
    avg: GeoAvgAggregateOutputType | null
    sum: GeoSumAggregateOutputType | null
    min: GeoMinAggregateOutputType | null
    max: GeoMaxAggregateOutputType | null
  }

  export type GeoAvgAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type GeoSumAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type GeoMinAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    lat: Decimal | null
    lon: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeoMaxAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    lat: Decimal | null
    lon: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeoCountAggregateOutputType = {
    id: number
    ideaId: number
    proposalId: number
    lat: number
    lon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GeoAvgAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    lat?: true
    lon?: true
  }

  export type GeoSumAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    lat?: true
    lon?: true
  }

  export type GeoMinAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    lat?: true
    lon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeoMaxAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    lat?: true
    lon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeoCountAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    lat?: true
    lon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GeoAggregateArgs = {
    /**
     * Filter which Geo to aggregate.
    **/
    where?: GeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geos to fetch.
    **/
    orderBy?: Enumerable<GeoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: GeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Geos
    **/
    count?: true | GeoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GeoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GeoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GeoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GeoMaxAggregateInputType
  }

  export type GetGeoAggregateType<T extends GeoAggregateArgs> = {
    [P in keyof T & keyof AggregateGeo]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeo[P]>
      : GetScalarType<T[P], AggregateGeo[P]>
  }


    
    
  export type GeoGroupByArgs = {
    where?: GeoWhereInput
    orderBy?: Enumerable<GeoOrderByInput>
    by: Array<GeoScalarFieldEnum>
    having?: GeoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: GeoCountAggregateInputType | true
    avg?: GeoAvgAggregateInputType
    sum?: GeoSumAggregateInputType
    min?: GeoMinAggregateInputType
    max?: GeoMaxAggregateInputType
  }


  export type GeoGroupByOutputType = {
    id: number
    ideaId: number | null
    proposalId: number | null
    lat: Decimal | null
    lon: Decimal | null
    createdAt: Date
    updatedAt: Date
    count: GeoCountAggregateOutputType | null
    avg: GeoAvgAggregateOutputType | null
    sum: GeoSumAggregateOutputType | null
    min: GeoMinAggregateOutputType | null
    max: GeoMaxAggregateOutputType | null
  }

  type GetGeoGroupByPayload<T extends GeoGroupByArgs> = Promise<Array<
    PickArray<GeoGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof GeoGroupByOutputType))]: GetScalarType<T[P], GeoGroupByOutputType[P]>
    }
  >>
    

  export type GeoSelect = {
    id?: boolean
    ideaId?: boolean
    proposalId?: boolean
    lat?: boolean
    lon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
  }

  export type GeoInclude = {
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
  }

  export type GeoGetPayload<
    S extends boolean | null | undefined | GeoArgs,
    U = keyof S
      > = S extends true
        ? Geo
    : S extends undefined
    ? never
    : S extends GeoArgs | GeoFindManyArgs
    ?'include' extends U
    ? Geo  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'idea'
        ? IdeaGetPayload<S['include'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Geo ?Geo [P]
  : 
          P extends 'idea'
        ? IdeaGetPayload<S['select'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['select'][P]> | null : never
  } 
    : Geo
  : Geo


  type GeoCountArgs = Merge<
    Omit<GeoFindManyArgs, 'select' | 'include'> & {
      select?: GeoCountAggregateInputType | true
    }
  >

  export interface GeoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Geo that matches the filter.
     * @param {GeoFindUniqueArgs} args - Arguments to find a Geo
     * @example
     * // Get one Geo
     * const geo = await prisma.geo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GeoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GeoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Geo'> extends True ? CheckSelect<T, Prisma__GeoClient<Geo>, Prisma__GeoClient<GeoGetPayload<T>>> : CheckSelect<T, Prisma__GeoClient<Geo | null >, Prisma__GeoClient<GeoGetPayload<T> | null >>

    /**
     * Find the first Geo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoFindFirstArgs} args - Arguments to find a Geo
     * @example
     * // Get one Geo
     * const geo = await prisma.geo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GeoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GeoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Geo'> extends True ? CheckSelect<T, Prisma__GeoClient<Geo>, Prisma__GeoClient<GeoGetPayload<T>>> : CheckSelect<T, Prisma__GeoClient<Geo | null >, Prisma__GeoClient<GeoGetPayload<T> | null >>

    /**
     * Find zero or more Geos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Geos
     * const geos = await prisma.geo.findMany()
     * 
     * // Get first 10 Geos
     * const geos = await prisma.geo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const geoWithIdOnly = await prisma.geo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GeoFindManyArgs>(
      args?: SelectSubset<T, GeoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Geo>>, PrismaPromise<Array<GeoGetPayload<T>>>>

    /**
     * Create a Geo.
     * @param {GeoCreateArgs} args - Arguments to create a Geo.
     * @example
     * // Create one Geo
     * const Geo = await prisma.geo.create({
     *   data: {
     *     // ... data to create a Geo
     *   }
     * })
     * 
    **/
    create<T extends GeoCreateArgs>(
      args: SelectSubset<T, GeoCreateArgs>
    ): CheckSelect<T, Prisma__GeoClient<Geo>, Prisma__GeoClient<GeoGetPayload<T>>>

    /**
     * Create many Geos.
     *     @param {GeoCreateManyArgs} args - Arguments to create many Geos.
     *     @example
     *     // Create many Geos
     *     const geo = await prisma.geo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GeoCreateManyArgs>(
      args?: SelectSubset<T, GeoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Geo.
     * @param {GeoDeleteArgs} args - Arguments to delete one Geo.
     * @example
     * // Delete one Geo
     * const Geo = await prisma.geo.delete({
     *   where: {
     *     // ... filter to delete one Geo
     *   }
     * })
     * 
    **/
    delete<T extends GeoDeleteArgs>(
      args: SelectSubset<T, GeoDeleteArgs>
    ): CheckSelect<T, Prisma__GeoClient<Geo>, Prisma__GeoClient<GeoGetPayload<T>>>

    /**
     * Update one Geo.
     * @param {GeoUpdateArgs} args - Arguments to update one Geo.
     * @example
     * // Update one Geo
     * const geo = await prisma.geo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GeoUpdateArgs>(
      args: SelectSubset<T, GeoUpdateArgs>
    ): CheckSelect<T, Prisma__GeoClient<Geo>, Prisma__GeoClient<GeoGetPayload<T>>>

    /**
     * Delete zero or more Geos.
     * @param {GeoDeleteManyArgs} args - Arguments to filter Geos to delete.
     * @example
     * // Delete a few Geos
     * const { count } = await prisma.geo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GeoDeleteManyArgs>(
      args?: SelectSubset<T, GeoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Geos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Geos
     * const geo = await prisma.geo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GeoUpdateManyArgs>(
      args: SelectSubset<T, GeoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Geo.
     * @param {GeoUpsertArgs} args - Arguments to update or create a Geo.
     * @example
     * // Update or create a Geo
     * const geo = await prisma.geo.upsert({
     *   create: {
     *     // ... data to create a Geo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Geo we want to update
     *   }
     * })
    **/
    upsert<T extends GeoUpsertArgs>(
      args: SelectSubset<T, GeoUpsertArgs>
    ): CheckSelect<T, Prisma__GeoClient<Geo>, Prisma__GeoClient<GeoGetPayload<T>>>

    /**
     * Count the number of Geos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoCountArgs} args - Arguments to filter Geos to count.
     * @example
     * // Count the number of Geos
     * const count = await prisma.geo.count({
     *   where: {
     *     // ... the filter for the Geos we want to count
     *   }
     * })
    **/
    count<T extends GeoCountArgs>(
      args?: Subset<T, GeoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Geo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeoAggregateArgs>(args: Subset<T, GeoAggregateArgs>): PrismaPromise<GetGeoAggregateType<T>>

    /**
     * Group by Geo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeoGroupByArgs['orderBy'] }
        : { orderBy?: GeoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeoGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Geo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GeoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    idea<T extends IdeaArgs = {}>(args?: Subset<T, IdeaArgs>): CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>;

    proposal<T extends ProposalArgs = {}>(args?: Subset<T, ProposalArgs>): CheckSelect<T, Prisma__ProposalClient<Proposal | null >, Prisma__ProposalClient<ProposalGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Geo findUnique
   */
  export type GeoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * Throw an Error if a Geo can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Geo to fetch.
    **/
    where: GeoWhereUniqueInput
  }


  /**
   * Geo findFirst
   */
  export type GeoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * Throw an Error if a Geo can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Geo to fetch.
    **/
    where?: GeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geos to fetch.
    **/
    orderBy?: Enumerable<GeoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Geos.
    **/
    cursor?: GeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Geos.
    **/
    distinct?: Enumerable<GeoScalarFieldEnum>
  }


  /**
   * Geo findMany
   */
  export type GeoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * Filter, which Geos to fetch.
    **/
    where?: GeoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Geos to fetch.
    **/
    orderBy?: Enumerable<GeoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Geos.
    **/
    cursor?: GeoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Geos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Geos.
    **/
    skip?: number
    distinct?: Enumerable<GeoScalarFieldEnum>
  }


  /**
   * Geo create
   */
  export type GeoCreateArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * The data needed to create a Geo.
    **/
    data: XOR<GeoCreateInput, GeoUncheckedCreateInput>
  }


  /**
   * Geo createMany
   */
  export type GeoCreateManyArgs = {
    data: Enumerable<GeoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Geo update
   */
  export type GeoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * The data needed to update a Geo.
    **/
    data: XOR<GeoUpdateInput, GeoUncheckedUpdateInput>
    /**
     * Choose, which Geo to update.
    **/
    where: GeoWhereUniqueInput
  }


  /**
   * Geo updateMany
   */
  export type GeoUpdateManyArgs = {
    data: XOR<GeoUpdateManyMutationInput, GeoUncheckedUpdateManyInput>
    where?: GeoWhereInput
  }


  /**
   * Geo upsert
   */
  export type GeoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * The filter to search for the Geo to update in case it exists.
    **/
    where: GeoWhereUniqueInput
    /**
     * In case the Geo found by the `where` argument doesn't exist, create a new Geo with this data.
    **/
    create: XOR<GeoCreateInput, GeoUncheckedCreateInput>
    /**
     * In case the Geo was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<GeoUpdateInput, GeoUncheckedUpdateInput>
  }


  /**
   * Geo delete
   */
  export type GeoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
    /**
     * Filter which Geo to delete.
    **/
    where: GeoWhereUniqueInput
  }


  /**
   * Geo deleteMany
   */
  export type GeoDeleteManyArgs = {
    where?: GeoWhereInput
  }


  /**
   * Geo without action
   */
  export type GeoArgs = {
    /**
     * Select specific fields to fetch from the Geo
    **/
    select?: GeoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GeoInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    count: AddressCountAggregateOutputType | null
    avg: AddressAvgAggregateOutputType | null
    sum: AddressSumAggregateOutputType | null
    min: AddressMinAggregateOutputType | null
    max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    streetAddress: string | null
    streetAddress2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    streetAddress: string | null
    streetAddress2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    ideaId: number
    proposalId: number
    streetAddress: number
    streetAddress2: number
    city: number
    country: number
    postalCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    streetAddress?: true
    streetAddress2?: true
    city?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    streetAddress?: true
    streetAddress2?: true
    city?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    streetAddress?: true
    streetAddress2?: true
    city?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }


    
    
  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByInput>
    by: Array<AddressScalarFieldEnum>
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AddressCountAggregateInputType | true
    avg?: AddressAvgAggregateInputType
    sum?: AddressSumAggregateInputType
    min?: AddressMinAggregateInputType
    max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: number
    ideaId: number | null
    proposalId: number | null
    streetAddress: string | null
    streetAddress2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date
    updatedAt: Date
    count: AddressCountAggregateOutputType | null
    avg: AddressAvgAggregateOutputType | null
    sum: AddressSumAggregateOutputType | null
    min: AddressMinAggregateOutputType | null
    max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Promise<Array<
    PickArray<AddressGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AddressGroupByOutputType))]: GetScalarType<T[P], AddressGroupByOutputType[P]>
    }
  >>
    

  export type AddressSelect = {
    id?: boolean
    ideaId?: boolean
    proposalId?: boolean
    streetAddress?: boolean
    streetAddress2?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
  }

  export type AddressInclude = {
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'idea'
        ? IdeaGetPayload<S['include'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Address ?Address [P]
  : 
          P extends 'idea'
        ? IdeaGetPayload<S['select'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['select'][P]> | null : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    idea<T extends IdeaArgs = {}>(args?: Subset<T, IdeaArgs>): CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>;

    proposal<T extends ProposalArgs = {}>(args?: Subset<T, ProposalArgs>): CheckSelect<T, Prisma__ProposalClient<Proposal | null >, Prisma__ProposalClient<ProposalGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
  }



  /**
   * Model Idea
   */


  export type AggregateIdea = {
    count: IdeaCountAggregateOutputType | null
    avg: IdeaAvgAggregateOutputType | null
    sum: IdeaSumAggregateOutputType | null
    min: IdeaMinAggregateOutputType | null
    max: IdeaMaxAggregateOutputType | null
  }

  export type IdeaAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
  }

  export type IdeaSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
  }

  export type IdeaMinAggregateOutputType = {
    id: number | null
    authorId: string | null
    championId: string | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    title: string | null
    description: string | null
    userType: string | null
    communityImpact: string | null
    natureImpact: string | null
    artsImpact: string | null
    energyImpact: string | null
    manufacturingImpact: string | null
    state: IdeaState | null
    active: boolean | null
    imagePath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeaMaxAggregateOutputType = {
    id: number | null
    authorId: string | null
    championId: string | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    title: string | null
    description: string | null
    userType: string | null
    communityImpact: string | null
    natureImpact: string | null
    artsImpact: string | null
    energyImpact: string | null
    manufacturingImpact: string | null
    state: IdeaState | null
    active: boolean | null
    imagePath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeaCountAggregateOutputType = {
    id: number
    authorId: number
    championId: number
    categoryId: number
    superSegmentId: number
    segmentId: number
    subSegmentId: number
    title: number
    description: number
    userType: number
    communityImpact: number
    natureImpact: number
    artsImpact: number
    energyImpact: number
    manufacturingImpact: number
    state: number
    active: number
    imagePath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdeaAvgAggregateInputType = {
    id?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
  }

  export type IdeaSumAggregateInputType = {
    id?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
  }

  export type IdeaMinAggregateInputType = {
    id?: true
    authorId?: true
    championId?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    title?: true
    description?: true
    userType?: true
    communityImpact?: true
    natureImpact?: true
    artsImpact?: true
    energyImpact?: true
    manufacturingImpact?: true
    state?: true
    active?: true
    imagePath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeaMaxAggregateInputType = {
    id?: true
    authorId?: true
    championId?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    title?: true
    description?: true
    userType?: true
    communityImpact?: true
    natureImpact?: true
    artsImpact?: true
    energyImpact?: true
    manufacturingImpact?: true
    state?: true
    active?: true
    imagePath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeaCountAggregateInputType = {
    id?: true
    authorId?: true
    championId?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    title?: true
    description?: true
    userType?: true
    communityImpact?: true
    natureImpact?: true
    artsImpact?: true
    energyImpact?: true
    manufacturingImpact?: true
    state?: true
    active?: true
    imagePath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdeaAggregateArgs = {
    /**
     * Filter which Idea to aggregate.
    **/
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
    **/
    orderBy?: Enumerable<IdeaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ideas
    **/
    count?: true | IdeaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: IdeaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: IdeaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: IdeaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: IdeaMaxAggregateInputType
  }

  export type GetIdeaAggregateType<T extends IdeaAggregateArgs> = {
    [P in keyof T & keyof AggregateIdea]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdea[P]>
      : GetScalarType<T[P], AggregateIdea[P]>
  }


    
    
  export type IdeaGroupByArgs = {
    where?: IdeaWhereInput
    orderBy?: Enumerable<IdeaOrderByInput>
    by: Array<IdeaScalarFieldEnum>
    having?: IdeaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: IdeaCountAggregateInputType | true
    avg?: IdeaAvgAggregateInputType
    sum?: IdeaSumAggregateInputType
    min?: IdeaMinAggregateInputType
    max?: IdeaMaxAggregateInputType
  }


  export type IdeaGroupByOutputType = {
    id: number
    authorId: string
    championId: string | null
    categoryId: number
    superSegmentId: number
    segmentId: number | null
    subSegmentId: number | null
    title: string
    description: string
    userType: string
    communityImpact: string | null
    natureImpact: string | null
    artsImpact: string | null
    energyImpact: string | null
    manufacturingImpact: string | null
    state: IdeaState
    active: boolean
    imagePath: string | null
    createdAt: Date
    updatedAt: Date
    count: IdeaCountAggregateOutputType | null
    avg: IdeaAvgAggregateOutputType | null
    sum: IdeaSumAggregateOutputType | null
    min: IdeaMinAggregateOutputType | null
    max: IdeaMaxAggregateOutputType | null
  }

  type GetIdeaGroupByPayload<T extends IdeaGroupByArgs> = Promise<Array<
    PickArray<IdeaGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof IdeaGroupByOutputType))]: GetScalarType<T[P], IdeaGroupByOutputType[P]>
    }
  >>
    

  export type IdeaSelect = {
    id?: boolean
    authorId?: boolean
    championId?: boolean
    categoryId?: boolean
    superSegmentId?: boolean
    segmentId?: boolean
    subSegmentId?: boolean
    title?: boolean
    description?: boolean
    userType?: boolean
    communityImpact?: boolean
    natureImpact?: boolean
    artsImpact?: boolean
    energyImpact?: boolean
    manufacturingImpact?: boolean
    state?: boolean
    active?: boolean
    imagePath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | CommentFindManyArgs
    ratings?: boolean | RatingFindManyArgs
    projectInfo?: boolean | ProjectArgs
    address?: boolean | AddressArgs
    geo?: boolean | GeoArgs
    author?: boolean | UserArgs
    champion?: boolean | UserArgs
    category?: boolean | CategoryArgs
    superSegment?: boolean | SuperSegmentArgs
    segment?: boolean | SegmentsArgs
    subSegment?: boolean | SubSegmentsArgs
  }

  export type IdeaInclude = {
    comments?: boolean | CommentFindManyArgs
    ratings?: boolean | RatingFindManyArgs
    projectInfo?: boolean | ProjectArgs
    address?: boolean | AddressArgs
    geo?: boolean | GeoArgs
    author?: boolean | UserArgs
    champion?: boolean | UserArgs
    category?: boolean | CategoryArgs
    superSegment?: boolean | SuperSegmentArgs
    segment?: boolean | SegmentsArgs
    subSegment?: boolean | SubSegmentsArgs
  }

  export type IdeaGetPayload<
    S extends boolean | null | undefined | IdeaArgs,
    U = keyof S
      > = S extends true
        ? Idea
    : S extends undefined
    ? never
    : S extends IdeaArgs | IdeaFindManyArgs
    ?'include' extends U
    ? Idea  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'comments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'ratings'
        ? Array < RatingGetPayload<S['include'][P]>>  :
        P extends 'projectInfo'
        ? ProjectGetPayload<S['include'][P]> | null :
        P extends 'address'
        ? AddressGetPayload<S['include'][P]> | null :
        P extends 'geo'
        ? GeoGetPayload<S['include'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['include'][P]> :
        P extends 'champion'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'category'
        ? CategoryGetPayload<S['include'][P]> :
        P extends 'superSegment'
        ? SuperSegmentGetPayload<S['include'][P]> :
        P extends 'segment'
        ? SegmentsGetPayload<S['include'][P]> | null :
        P extends 'subSegment'
        ? SubSegmentsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Idea ?Idea [P]
  : 
          P extends 'comments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'ratings'
        ? Array < RatingGetPayload<S['select'][P]>>  :
        P extends 'projectInfo'
        ? ProjectGetPayload<S['select'][P]> | null :
        P extends 'address'
        ? AddressGetPayload<S['select'][P]> | null :
        P extends 'geo'
        ? GeoGetPayload<S['select'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['select'][P]> :
        P extends 'champion'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'category'
        ? CategoryGetPayload<S['select'][P]> :
        P extends 'superSegment'
        ? SuperSegmentGetPayload<S['select'][P]> :
        P extends 'segment'
        ? SegmentsGetPayload<S['select'][P]> | null :
        P extends 'subSegment'
        ? SubSegmentsGetPayload<S['select'][P]> | null : never
  } 
    : Idea
  : Idea


  type IdeaCountArgs = Merge<
    Omit<IdeaFindManyArgs, 'select' | 'include'> & {
      select?: IdeaCountAggregateInputType | true
    }
  >

  export interface IdeaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Idea that matches the filter.
     * @param {IdeaFindUniqueArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IdeaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IdeaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Idea'> extends True ? CheckSelect<T, Prisma__IdeaClient<Idea>, Prisma__IdeaClient<IdeaGetPayload<T>>> : CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>

    /**
     * Find the first Idea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindFirstArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IdeaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IdeaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Idea'> extends True ? CheckSelect<T, Prisma__IdeaClient<Idea>, Prisma__IdeaClient<IdeaGetPayload<T>>> : CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>

    /**
     * Find zero or more Ideas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ideas
     * const ideas = await prisma.idea.findMany()
     * 
     * // Get first 10 Ideas
     * const ideas = await prisma.idea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ideaWithIdOnly = await prisma.idea.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IdeaFindManyArgs>(
      args?: SelectSubset<T, IdeaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>

    /**
     * Create a Idea.
     * @param {IdeaCreateArgs} args - Arguments to create a Idea.
     * @example
     * // Create one Idea
     * const Idea = await prisma.idea.create({
     *   data: {
     *     // ... data to create a Idea
     *   }
     * })
     * 
    **/
    create<T extends IdeaCreateArgs>(
      args: SelectSubset<T, IdeaCreateArgs>
    ): CheckSelect<T, Prisma__IdeaClient<Idea>, Prisma__IdeaClient<IdeaGetPayload<T>>>

    /**
     * Create many Ideas.
     *     @param {IdeaCreateManyArgs} args - Arguments to create many Ideas.
     *     @example
     *     // Create many Ideas
     *     const idea = await prisma.idea.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IdeaCreateManyArgs>(
      args?: SelectSubset<T, IdeaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Idea.
     * @param {IdeaDeleteArgs} args - Arguments to delete one Idea.
     * @example
     * // Delete one Idea
     * const Idea = await prisma.idea.delete({
     *   where: {
     *     // ... filter to delete one Idea
     *   }
     * })
     * 
    **/
    delete<T extends IdeaDeleteArgs>(
      args: SelectSubset<T, IdeaDeleteArgs>
    ): CheckSelect<T, Prisma__IdeaClient<Idea>, Prisma__IdeaClient<IdeaGetPayload<T>>>

    /**
     * Update one Idea.
     * @param {IdeaUpdateArgs} args - Arguments to update one Idea.
     * @example
     * // Update one Idea
     * const idea = await prisma.idea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IdeaUpdateArgs>(
      args: SelectSubset<T, IdeaUpdateArgs>
    ): CheckSelect<T, Prisma__IdeaClient<Idea>, Prisma__IdeaClient<IdeaGetPayload<T>>>

    /**
     * Delete zero or more Ideas.
     * @param {IdeaDeleteManyArgs} args - Arguments to filter Ideas to delete.
     * @example
     * // Delete a few Ideas
     * const { count } = await prisma.idea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IdeaDeleteManyArgs>(
      args?: SelectSubset<T, IdeaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ideas
     * const idea = await prisma.idea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IdeaUpdateManyArgs>(
      args: SelectSubset<T, IdeaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Idea.
     * @param {IdeaUpsertArgs} args - Arguments to update or create a Idea.
     * @example
     * // Update or create a Idea
     * const idea = await prisma.idea.upsert({
     *   create: {
     *     // ... data to create a Idea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Idea we want to update
     *   }
     * })
    **/
    upsert<T extends IdeaUpsertArgs>(
      args: SelectSubset<T, IdeaUpsertArgs>
    ): CheckSelect<T, Prisma__IdeaClient<Idea>, Prisma__IdeaClient<IdeaGetPayload<T>>>

    /**
     * Count the number of Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaCountArgs} args - Arguments to filter Ideas to count.
     * @example
     * // Count the number of Ideas
     * const count = await prisma.idea.count({
     *   where: {
     *     // ... the filter for the Ideas we want to count
     *   }
     * })
    **/
    count<T extends IdeaCountArgs>(
      args?: Subset<T, IdeaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdeaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Idea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdeaAggregateArgs>(args: Subset<T, IdeaAggregateArgs>): PrismaPromise<GetIdeaAggregateType<T>>

    /**
     * Group by Idea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdeaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdeaGroupByArgs['orderBy'] }
        : { orderBy?: IdeaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdeaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdeaGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Idea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IdeaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    comments<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    ratings<T extends RatingFindManyArgs = {}>(args?: Subset<T, RatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Rating>>, PrismaPromise<Array<RatingGetPayload<T>>>>;

    projectInfo<T extends ProjectArgs = {}>(args?: Subset<T, ProjectArgs>): CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>;

    address<T extends AddressArgs = {}>(args?: Subset<T, AddressArgs>): CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>;

    geo<T extends GeoArgs = {}>(args?: Subset<T, GeoArgs>): CheckSelect<T, Prisma__GeoClient<Geo | null >, Prisma__GeoClient<GeoGetPayload<T> | null >>;

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    champion<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    category<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    superSegment<T extends SuperSegmentArgs = {}>(args?: Subset<T, SuperSegmentArgs>): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>;

    segment<T extends SegmentsArgs = {}>(args?: Subset<T, SegmentsArgs>): CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>;

    subSegment<T extends SubSegmentsArgs = {}>(args?: Subset<T, SubSegmentsArgs>): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Idea findUnique
   */
  export type IdeaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * Throw an Error if a Idea can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Idea to fetch.
    **/
    where: IdeaWhereUniqueInput
  }


  /**
   * Idea findFirst
   */
  export type IdeaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * Throw an Error if a Idea can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Idea to fetch.
    **/
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
    **/
    orderBy?: Enumerable<IdeaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ideas.
    **/
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ideas.
    **/
    distinct?: Enumerable<IdeaScalarFieldEnum>
  }


  /**
   * Idea findMany
   */
  export type IdeaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * Filter, which Ideas to fetch.
    **/
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
    **/
    orderBy?: Enumerable<IdeaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ideas.
    **/
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
    **/
    skip?: number
    distinct?: Enumerable<IdeaScalarFieldEnum>
  }


  /**
   * Idea create
   */
  export type IdeaCreateArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * The data needed to create a Idea.
    **/
    data: XOR<IdeaCreateInput, IdeaUncheckedCreateInput>
  }


  /**
   * Idea createMany
   */
  export type IdeaCreateManyArgs = {
    data: Enumerable<IdeaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Idea update
   */
  export type IdeaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * The data needed to update a Idea.
    **/
    data: XOR<IdeaUpdateInput, IdeaUncheckedUpdateInput>
    /**
     * Choose, which Idea to update.
    **/
    where: IdeaWhereUniqueInput
  }


  /**
   * Idea updateMany
   */
  export type IdeaUpdateManyArgs = {
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyInput>
    where?: IdeaWhereInput
  }


  /**
   * Idea upsert
   */
  export type IdeaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * The filter to search for the Idea to update in case it exists.
    **/
    where: IdeaWhereUniqueInput
    /**
     * In case the Idea found by the `where` argument doesn't exist, create a new Idea with this data.
    **/
    create: XOR<IdeaCreateInput, IdeaUncheckedCreateInput>
    /**
     * In case the Idea was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<IdeaUpdateInput, IdeaUncheckedUpdateInput>
  }


  /**
   * Idea delete
   */
  export type IdeaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
    /**
     * Filter which Idea to delete.
    **/
    where: IdeaWhereUniqueInput
  }


  /**
   * Idea deleteMany
   */
  export type IdeaDeleteManyArgs = {
    where?: IdeaWhereInput
  }


  /**
   * Idea without action
   */
  export type IdeaArgs = {
    /**
     * Select specific fields to fetch from the Idea
    **/
    select?: IdeaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IdeaInclude | null
  }



  /**
   * Model Proposal
   */


  export type AggregateProposal = {
    count: ProposalCountAggregateOutputType | null
    avg: ProposalAvgAggregateOutputType | null
    sum: ProposalSumAggregateOutputType | null
    min: ProposalMinAggregateOutputType | null
    max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
  }

  export type ProposalSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
  }

  export type ProposalMinAggregateOutputType = {
    id: number | null
    authorId: string | null
    championId: string | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    title: string | null
    description: string | null
    userType: string | null
    communityImpact: string | null
    natureImpact: string | null
    artsImpact: string | null
    energyImpact: string | null
    manufacturingImpact: string | null
    state: IdeaState | null
    active: boolean | null
    imagePath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: number | null
    authorId: string | null
    championId: string | null
    categoryId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    title: string | null
    description: string | null
    userType: string | null
    communityImpact: string | null
    natureImpact: string | null
    artsImpact: string | null
    energyImpact: string | null
    manufacturingImpact: string | null
    state: IdeaState | null
    active: boolean | null
    imagePath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    authorId: number
    championId: number
    categoryId: number
    superSegmentId: number
    segmentId: number
    subSegmentId: number
    title: number
    description: number
    userType: number
    communityImpact: number
    natureImpact: number
    artsImpact: number
    energyImpact: number
    manufacturingImpact: number
    state: number
    active: number
    imagePath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    id?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
  }

  export type ProposalSumAggregateInputType = {
    id?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    authorId?: true
    championId?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    title?: true
    description?: true
    userType?: true
    communityImpact?: true
    natureImpact?: true
    artsImpact?: true
    energyImpact?: true
    manufacturingImpact?: true
    state?: true
    active?: true
    imagePath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    authorId?: true
    championId?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    title?: true
    description?: true
    userType?: true
    communityImpact?: true
    natureImpact?: true
    artsImpact?: true
    energyImpact?: true
    manufacturingImpact?: true
    state?: true
    active?: true
    imagePath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    authorId?: true
    championId?: true
    categoryId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    title?: true
    description?: true
    userType?: true
    communityImpact?: true
    natureImpact?: true
    artsImpact?: true
    energyImpact?: true
    manufacturingImpact?: true
    state?: true
    active?: true
    imagePath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalAggregateArgs = {
    /**
     * Filter which Proposal to aggregate.
    **/
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
    **/
    orderBy?: Enumerable<ProposalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
    [P in keyof T & keyof AggregateProposal]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }


    
    
  export type ProposalGroupByArgs = {
    where?: ProposalWhereInput
    orderBy?: Enumerable<ProposalOrderByInput>
    by: Array<ProposalScalarFieldEnum>
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ProposalCountAggregateInputType | true
    avg?: ProposalAvgAggregateInputType
    sum?: ProposalSumAggregateInputType
    min?: ProposalMinAggregateInputType
    max?: ProposalMaxAggregateInputType
  }


  export type ProposalGroupByOutputType = {
    id: number
    authorId: string
    championId: string | null
    categoryId: number
    superSegmentId: number
    segmentId: number | null
    subSegmentId: number | null
    title: string
    description: string
    userType: string
    communityImpact: string | null
    natureImpact: string | null
    artsImpact: string | null
    energyImpact: string | null
    manufacturingImpact: string | null
    state: IdeaState
    active: boolean
    imagePath: string | null
    createdAt: Date
    updatedAt: Date
    count: ProposalCountAggregateOutputType | null
    avg: ProposalAvgAggregateOutputType | null
    sum: ProposalSumAggregateOutputType | null
    min: ProposalMinAggregateOutputType | null
    max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Promise<Array<
    PickArray<ProposalGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: GetScalarType<T[P], ProposalGroupByOutputType[P]>
    }
  >>
    

  export type ProposalSelect = {
    id?: boolean
    authorId?: boolean
    championId?: boolean
    categoryId?: boolean
    superSegmentId?: boolean
    segmentId?: boolean
    subSegmentId?: boolean
    title?: boolean
    description?: boolean
    userType?: boolean
    communityImpact?: boolean
    natureImpact?: boolean
    artsImpact?: boolean
    energyImpact?: boolean
    manufacturingImpact?: boolean
    state?: boolean
    active?: boolean
    imagePath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | CommentFindManyArgs
    ratings?: boolean | RatingFindManyArgs
    address?: boolean | AddressArgs
    geo?: boolean | GeoArgs
    author?: boolean | UserArgs
    champion?: boolean | UserArgs
    category?: boolean | CategoryArgs
    superSegment?: boolean | SuperSegmentArgs
    segment?: boolean | SegmentsArgs
    subSegment?: boolean | SubSegmentsArgs
  }

  export type ProposalInclude = {
    comments?: boolean | CommentFindManyArgs
    ratings?: boolean | RatingFindManyArgs
    address?: boolean | AddressArgs
    geo?: boolean | GeoArgs
    author?: boolean | UserArgs
    champion?: boolean | UserArgs
    category?: boolean | CategoryArgs
    superSegment?: boolean | SuperSegmentArgs
    segment?: boolean | SegmentsArgs
    subSegment?: boolean | SubSegmentsArgs
  }

  export type ProposalGetPayload<
    S extends boolean | null | undefined | ProposalArgs,
    U = keyof S
      > = S extends true
        ? Proposal
    : S extends undefined
    ? never
    : S extends ProposalArgs | ProposalFindManyArgs
    ?'include' extends U
    ? Proposal  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'comments'
        ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'ratings'
        ? Array < RatingGetPayload<S['include'][P]>>  :
        P extends 'address'
        ? AddressGetPayload<S['include'][P]> | null :
        P extends 'geo'
        ? GeoGetPayload<S['include'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['include'][P]> :
        P extends 'champion'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'category'
        ? CategoryGetPayload<S['include'][P]> :
        P extends 'superSegment'
        ? SuperSegmentGetPayload<S['include'][P]> :
        P extends 'segment'
        ? SegmentsGetPayload<S['include'][P]> | null :
        P extends 'subSegment'
        ? SubSegmentsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Proposal ?Proposal [P]
  : 
          P extends 'comments'
        ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'ratings'
        ? Array < RatingGetPayload<S['select'][P]>>  :
        P extends 'address'
        ? AddressGetPayload<S['select'][P]> | null :
        P extends 'geo'
        ? GeoGetPayload<S['select'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['select'][P]> :
        P extends 'champion'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'category'
        ? CategoryGetPayload<S['select'][P]> :
        P extends 'superSegment'
        ? SuperSegmentGetPayload<S['select'][P]> :
        P extends 'segment'
        ? SegmentsGetPayload<S['select'][P]> | null :
        P extends 'subSegment'
        ? SubSegmentsGetPayload<S['select'][P]> | null : never
  } 
    : Proposal
  : Proposal


  type ProposalCountArgs = Merge<
    Omit<ProposalFindManyArgs, 'select' | 'include'> & {
      select?: ProposalCountAggregateInputType | true
    }
  >

  export interface ProposalDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProposalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProposalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Proposal'> extends True ? CheckSelect<T, Prisma__ProposalClient<Proposal>, Prisma__ProposalClient<ProposalGetPayload<T>>> : CheckSelect<T, Prisma__ProposalClient<Proposal | null >, Prisma__ProposalClient<ProposalGetPayload<T> | null >>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProposalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProposalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Proposal'> extends True ? CheckSelect<T, Prisma__ProposalClient<Proposal>, Prisma__ProposalClient<ProposalGetPayload<T>>> : CheckSelect<T, Prisma__ProposalClient<Proposal | null >, Prisma__ProposalClient<ProposalGetPayload<T> | null >>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProposalFindManyArgs>(
      args?: SelectSubset<T, ProposalFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
    **/
    create<T extends ProposalCreateArgs>(
      args: SelectSubset<T, ProposalCreateArgs>
    ): CheckSelect<T, Prisma__ProposalClient<Proposal>, Prisma__ProposalClient<ProposalGetPayload<T>>>

    /**
     * Create many Proposals.
     *     @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     *     @example
     *     // Create many Proposals
     *     const proposal = await prisma.proposal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProposalCreateManyArgs>(
      args?: SelectSubset<T, ProposalCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
    **/
    delete<T extends ProposalDeleteArgs>(
      args: SelectSubset<T, ProposalDeleteArgs>
    ): CheckSelect<T, Prisma__ProposalClient<Proposal>, Prisma__ProposalClient<ProposalGetPayload<T>>>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProposalUpdateArgs>(
      args: SelectSubset<T, ProposalUpdateArgs>
    ): CheckSelect<T, Prisma__ProposalClient<Proposal>, Prisma__ProposalClient<ProposalGetPayload<T>>>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProposalDeleteManyArgs>(
      args?: SelectSubset<T, ProposalDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProposalUpdateManyArgs>(
      args: SelectSubset<T, ProposalUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
    **/
    upsert<T extends ProposalUpsertArgs>(
      args: SelectSubset<T, ProposalUpsertArgs>
    ): CheckSelect<T, Prisma__ProposalClient<Proposal>, Prisma__ProposalClient<ProposalGetPayload<T>>>

    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProposalClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    comments<T extends CommentFindManyArgs = {}>(args?: Subset<T, CommentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>;

    ratings<T extends RatingFindManyArgs = {}>(args?: Subset<T, RatingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Rating>>, PrismaPromise<Array<RatingGetPayload<T>>>>;

    address<T extends AddressArgs = {}>(args?: Subset<T, AddressArgs>): CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>;

    geo<T extends GeoArgs = {}>(args?: Subset<T, GeoArgs>): CheckSelect<T, Prisma__GeoClient<Geo | null >, Prisma__GeoClient<GeoGetPayload<T> | null >>;

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    champion<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    category<T extends CategoryArgs = {}>(args?: Subset<T, CategoryArgs>): CheckSelect<T, Prisma__CategoryClient<Category | null >, Prisma__CategoryClient<CategoryGetPayload<T> | null >>;

    superSegment<T extends SuperSegmentArgs = {}>(args?: Subset<T, SuperSegmentArgs>): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>;

    segment<T extends SegmentsArgs = {}>(args?: Subset<T, SegmentsArgs>): CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>;

    subSegment<T extends SubSegmentsArgs = {}>(args?: Subset<T, SubSegmentsArgs>): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * Throw an Error if a Proposal can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Proposal to fetch.
    **/
    where: ProposalWhereUniqueInput
  }


  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * Throw an Error if a Proposal can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Proposal to fetch.
    **/
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
    **/
    orderBy?: Enumerable<ProposalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
    **/
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
    **/
    distinct?: Enumerable<ProposalScalarFieldEnum>
  }


  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * Filter, which Proposals to fetch.
    **/
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
    **/
    orderBy?: Enumerable<ProposalOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
    **/
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
    **/
    skip?: number
    distinct?: Enumerable<ProposalScalarFieldEnum>
  }


  /**
   * Proposal create
   */
  export type ProposalCreateArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * The data needed to create a Proposal.
    **/
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
  }


  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs = {
    data: Enumerable<ProposalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Proposal update
   */
  export type ProposalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * The data needed to update a Proposal.
    **/
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
    **/
    where: ProposalWhereUniqueInput
  }


  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs = {
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    where?: ProposalWhereInput
  }


  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * The filter to search for the Proposal to update in case it exists.
    **/
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
    **/
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
  }


  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
    /**
     * Filter which Proposal to delete.
    **/
    where: ProposalWhereUniqueInput
  }


  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs = {
    where?: ProposalWhereInput
  }


  /**
   * Proposal without action
   */
  export type ProposalArgs = {
    /**
     * Select specific fields to fetch from the Proposal
    **/
    select?: ProposalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProposalInclude | null
  }



  /**
   * Model Project
   */


  export type AggregateProject = {
    count: ProjectCountAggregateOutputType | null
    avg: ProjectAvgAggregateOutputType | null
    sum: ProjectSumAggregateOutputType | null
    min: ProjectMinAggregateOutputType | null
    max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    ideaId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    ideaId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    ideaId: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    ideaId: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    ideaId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    ideaId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    ideaId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    ideaId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    ideaId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    ideaId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs = {
    /**
     * Filter which Project to aggregate.
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
    **/
    orderBy?: Enumerable<ProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
    [P in keyof T & keyof AggregateProject]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }


    
    
  export type ProjectGroupByArgs = {
    where?: ProjectWhereInput
    orderBy?: Enumerable<ProjectOrderByInput>
    by: Array<ProjectScalarFieldEnum>
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ProjectCountAggregateInputType | true
    avg?: ProjectAvgAggregateInputType
    sum?: ProjectSumAggregateInputType
    min?: ProjectMinAggregateInputType
    max?: ProjectMaxAggregateInputType
  }


  export type ProjectGroupByOutputType = {
    id: number
    ideaId: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    count: ProjectCountAggregateOutputType | null
    avg: ProjectAvgAggregateOutputType | null
    sum: ProjectSumAggregateOutputType | null
    min: ProjectMinAggregateOutputType | null
    max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Promise<Array<
    PickArray<ProjectGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: GetScalarType<T[P], ProjectGroupByOutputType[P]>
    }
  >>
    

  export type ProjectSelect = {
    id?: boolean
    ideaId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idea?: boolean | IdeaArgs
  }

  export type ProjectInclude = {
    idea?: boolean | IdeaArgs
  }

  export type ProjectGetPayload<
    S extends boolean | null | undefined | ProjectArgs,
    U = keyof S
      > = S extends true
        ? Project
    : S extends undefined
    ? never
    : S extends ProjectArgs | ProjectFindManyArgs
    ?'include' extends U
    ? Project  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'idea'
        ? IdeaGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Project ?Project [P]
  : 
          P extends 'idea'
        ? IdeaGetPayload<S['select'][P]> : never
  } 
    : Project
  : Project


  type ProjectCountArgs = Merge<
    Omit<ProjectFindManyArgs, 'select' | 'include'> & {
      select?: ProjectCountAggregateInputType | true
    }
  >

  export interface ProjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Project'> extends True ? CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>> : CheckSelect<T, Prisma__ProjectClient<Project | null >, Prisma__ProjectClient<ProjectGetPayload<T> | null >>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProjectFindManyArgs>(
      args?: SelectSubset<T, ProjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Project>>, PrismaPromise<Array<ProjectGetPayload<T>>>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
    **/
    create<T extends ProjectCreateArgs>(
      args: SelectSubset<T, ProjectCreateArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Create many Projects.
     *     @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     *     @example
     *     // Create many Projects
     *     const project = await prisma.project.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProjectCreateManyArgs>(
      args?: SelectSubset<T, ProjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
    **/
    delete<T extends ProjectDeleteArgs>(
      args: SelectSubset<T, ProjectDeleteArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProjectUpdateArgs>(
      args: SelectSubset<T, ProjectUpdateArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProjectDeleteManyArgs>(
      args?: SelectSubset<T, ProjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProjectUpdateManyArgs>(
      args: SelectSubset<T, ProjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
    **/
    upsert<T extends ProjectUpsertArgs>(
      args: SelectSubset<T, ProjectUpsertArgs>
    ): CheckSelect<T, Prisma__ProjectClient<Project>, Prisma__ProjectClient<ProjectGetPayload<T>>>

    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    idea<T extends IdeaArgs = {}>(args?: Subset<T, IdeaArgs>): CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * Throw an Error if a Project can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Project to fetch.
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * Throw an Error if a Project can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Project to fetch.
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
    **/
    orderBy?: Enumerable<ProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
    **/
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project findMany
   */
  export type ProjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * Filter, which Projects to fetch.
    **/
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
    **/
    orderBy?: Enumerable<ProjectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
    **/
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
    **/
    skip?: number
    distinct?: Enumerable<ProjectScalarFieldEnum>
  }


  /**
   * Project create
   */
  export type ProjectCreateArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * The data needed to create a Project.
    **/
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }


  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs = {
    data: Enumerable<ProjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Project update
   */
  export type ProjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * The data needed to update a Project.
    **/
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs = {
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    where?: ProjectWhereInput
  }


  /**
   * Project upsert
   */
  export type ProjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * The filter to search for the Project to update in case it exists.
    **/
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
    **/
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }


  /**
   * Project delete
   */
  export type ProjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
    /**
     * Filter which Project to delete.
    **/
    where: ProjectWhereUniqueInput
  }


  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs = {
    where?: ProjectWhereInput
  }


  /**
   * Project without action
   */
  export type ProjectArgs = {
    /**
     * Select specific fields to fetch from the Project
    **/
    select?: ProjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ProjectInclude | null
  }



  /**
   * Model Rating
   */


  export type AggregateRating = {
    count: RatingCountAggregateOutputType | null
    avg: RatingAvgAggregateOutputType | null
    sum: RatingSumAggregateOutputType | null
    min: RatingMinAggregateOutputType | null
    max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    rating: number | null
  }

  export type RatingSumAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    rating: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    authorId: string | null
    rating: number | null
    ratingExplanation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingMaxAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    authorId: string | null
    rating: number | null
    ratingExplanation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    ideaId: number
    proposalId: number
    authorId: number
    rating: number
    ratingExplanation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    rating?: true
  }

  export type RatingSumAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    rating?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    authorId?: true
    rating?: true
    ratingExplanation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    authorId?: true
    rating?: true
    ratingExplanation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    authorId?: true
    rating?: true
    ratingExplanation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RatingAggregateArgs = {
    /**
     * Filter which Rating to aggregate.
    **/
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
    **/
    orderBy?: Enumerable<RatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
    [P in keyof T & keyof AggregateRating]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }


    
    
  export type RatingGroupByArgs = {
    where?: RatingWhereInput
    orderBy?: Enumerable<RatingOrderByInput>
    by: Array<RatingScalarFieldEnum>
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: RatingCountAggregateInputType | true
    avg?: RatingAvgAggregateInputType
    sum?: RatingSumAggregateInputType
    min?: RatingMinAggregateInputType
    max?: RatingMaxAggregateInputType
  }


  export type RatingGroupByOutputType = {
    id: number
    ideaId: number | null
    proposalId: number | null
    authorId: string
    rating: number
    ratingExplanation: string | null
    createdAt: Date
    updatedAt: Date
    count: RatingCountAggregateOutputType | null
    avg: RatingAvgAggregateOutputType | null
    sum: RatingSumAggregateOutputType | null
    min: RatingMinAggregateOutputType | null
    max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Promise<Array<
    PickArray<RatingGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof RatingGroupByOutputType))]: GetScalarType<T[P], RatingGroupByOutputType[P]>
    }
  >>
    

  export type RatingSelect = {
    id?: boolean
    ideaId?: boolean
    proposalId?: boolean
    authorId?: boolean
    rating?: boolean
    ratingExplanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserArgs
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
  }

  export type RatingInclude = {
    author?: boolean | UserArgs
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
  }

  export type RatingGetPayload<
    S extends boolean | null | undefined | RatingArgs,
    U = keyof S
      > = S extends true
        ? Rating
    : S extends undefined
    ? never
    : S extends RatingArgs | RatingFindManyArgs
    ?'include' extends U
    ? Rating  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'author'
        ? UserGetPayload<S['include'][P]> :
        P extends 'idea'
        ? IdeaGetPayload<S['include'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Rating ?Rating [P]
  : 
          P extends 'author'
        ? UserGetPayload<S['select'][P]> :
        P extends 'idea'
        ? IdeaGetPayload<S['select'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['select'][P]> | null : never
  } 
    : Rating
  : Rating


  type RatingCountArgs = Merge<
    Omit<RatingFindManyArgs, 'select' | 'include'> & {
      select?: RatingCountAggregateInputType | true
    }
  >

  export interface RatingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RatingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RatingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Rating'> extends True ? CheckSelect<T, Prisma__RatingClient<Rating>, Prisma__RatingClient<RatingGetPayload<T>>> : CheckSelect<T, Prisma__RatingClient<Rating | null >, Prisma__RatingClient<RatingGetPayload<T> | null >>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RatingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RatingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Rating'> extends True ? CheckSelect<T, Prisma__RatingClient<Rating>, Prisma__RatingClient<RatingGetPayload<T>>> : CheckSelect<T, Prisma__RatingClient<Rating | null >, Prisma__RatingClient<RatingGetPayload<T> | null >>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RatingFindManyArgs>(
      args?: SelectSubset<T, RatingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Rating>>, PrismaPromise<Array<RatingGetPayload<T>>>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
    **/
    create<T extends RatingCreateArgs>(
      args: SelectSubset<T, RatingCreateArgs>
    ): CheckSelect<T, Prisma__RatingClient<Rating>, Prisma__RatingClient<RatingGetPayload<T>>>

    /**
     * Create many Ratings.
     *     @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     *     @example
     *     // Create many Ratings
     *     const rating = await prisma.rating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RatingCreateManyArgs>(
      args?: SelectSubset<T, RatingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
    **/
    delete<T extends RatingDeleteArgs>(
      args: SelectSubset<T, RatingDeleteArgs>
    ): CheckSelect<T, Prisma__RatingClient<Rating>, Prisma__RatingClient<RatingGetPayload<T>>>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RatingUpdateArgs>(
      args: SelectSubset<T, RatingUpdateArgs>
    ): CheckSelect<T, Prisma__RatingClient<Rating>, Prisma__RatingClient<RatingGetPayload<T>>>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RatingDeleteManyArgs>(
      args?: SelectSubset<T, RatingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RatingUpdateManyArgs>(
      args: SelectSubset<T, RatingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
    **/
    upsert<T extends RatingUpsertArgs>(
      args: SelectSubset<T, RatingUpsertArgs>
    ): CheckSelect<T, Prisma__RatingClient<Rating>, Prisma__RatingClient<RatingGetPayload<T>>>

    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RatingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    idea<T extends IdeaArgs = {}>(args?: Subset<T, IdeaArgs>): CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>;

    proposal<T extends ProposalArgs = {}>(args?: Subset<T, ProposalArgs>): CheckSelect<T, Prisma__ProposalClient<Proposal | null >, Prisma__ProposalClient<ProposalGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * Throw an Error if a Rating can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Rating to fetch.
    **/
    where: RatingWhereUniqueInput
  }


  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * Throw an Error if a Rating can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Rating to fetch.
    **/
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
    **/
    orderBy?: Enumerable<RatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
    **/
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
    **/
    distinct?: Enumerable<RatingScalarFieldEnum>
  }


  /**
   * Rating findMany
   */
  export type RatingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * Filter, which Ratings to fetch.
    **/
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
    **/
    orderBy?: Enumerable<RatingOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
    **/
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
    **/
    skip?: number
    distinct?: Enumerable<RatingScalarFieldEnum>
  }


  /**
   * Rating create
   */
  export type RatingCreateArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * The data needed to create a Rating.
    **/
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }


  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs = {
    data: Enumerable<RatingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Rating update
   */
  export type RatingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * The data needed to update a Rating.
    **/
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
    **/
    where: RatingWhereUniqueInput
  }


  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs = {
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    where?: RatingWhereInput
  }


  /**
   * Rating upsert
   */
  export type RatingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * The filter to search for the Rating to update in case it exists.
    **/
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
    **/
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }


  /**
   * Rating delete
   */
  export type RatingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
    /**
     * Filter which Rating to delete.
    **/
    where: RatingWhereUniqueInput
  }


  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs = {
    where?: RatingWhereInput
  }


  /**
   * Rating without action
   */
  export type RatingArgs = {
    /**
     * Select specific fields to fetch from the Rating
    **/
    select?: RatingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RatingInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    count: CommentCountAggregateOutputType | null
    avg: CommentAvgAggregateOutputType | null
    sum: CommentSumAggregateOutputType | null
    min: CommentMinAggregateOutputType | null
    max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    authorId: string | null
    userSegId: string | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    content: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    ideaId: number | null
    proposalId: number | null
    authorId: string | null
    userSegId: string | null
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    content: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    ideaId: number
    proposalId: number
    authorId: number
    userSegId: number
    superSegmentId: number
    segmentId: number
    subSegmentId: number
    content: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    authorId?: true
    userSegId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    content?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    authorId?: true
    userSegId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    content?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    ideaId?: true
    proposalId?: true
    authorId?: true
    userSegId?: true
    superSegmentId?: true
    segmentId?: true
    subSegmentId?: true
    content?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
    [P in keyof T & keyof AggregateComment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }


    
    
  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByInput>
    by: Array<CommentScalarFieldEnum>
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CommentCountAggregateInputType | true
    avg?: CommentAvgAggregateInputType
    sum?: CommentSumAggregateInputType
    min?: CommentMinAggregateInputType
    max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: number
    ideaId: number | null
    proposalId: number | null
    authorId: string
    userSegId: string
    superSegmentId: number | null
    segmentId: number | null
    subSegmentId: number | null
    content: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    count: CommentCountAggregateOutputType | null
    avg: CommentAvgAggregateOutputType | null
    sum: CommentSumAggregateOutputType | null
    min: CommentMinAggregateOutputType | null
    max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Promise<Array<
    PickArray<CommentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CommentGroupByOutputType))]: GetScalarType<T[P], CommentGroupByOutputType[P]>
    }
  >>
    

  export type CommentSelect = {
    id?: boolean
    ideaId?: boolean
    proposalId?: boolean
    authorId?: boolean
    userSegId?: boolean
    superSegmentId?: boolean
    segmentId?: boolean
    subSegmentId?: boolean
    content?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserArgs
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
    userSeg?: boolean | UserSegmentsArgs
    likes?: boolean | UserCommentLikesFindManyArgs
    dislikes?: boolean | UserCommentDislikesFindManyArgs
  }

  export type CommentInclude = {
    author?: boolean | UserArgs
    idea?: boolean | IdeaArgs
    proposal?: boolean | ProposalArgs
    userSeg?: boolean | UserSegmentsArgs
    likes?: boolean | UserCommentLikesFindManyArgs
    dislikes?: boolean | UserCommentDislikesFindManyArgs
  }

  export type CommentGetPayload<
    S extends boolean | null | undefined | CommentArgs,
    U = keyof S
      > = S extends true
        ? Comment
    : S extends undefined
    ? never
    : S extends CommentArgs | CommentFindManyArgs
    ?'include' extends U
    ? Comment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'author'
        ? UserGetPayload<S['include'][P]> :
        P extends 'idea'
        ? IdeaGetPayload<S['include'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['include'][P]> | null :
        P extends 'userSeg'
        ? UserSegmentsGetPayload<S['include'][P]> :
        P extends 'likes'
        ? Array < UserCommentLikesGetPayload<S['include'][P]>>  :
        P extends 'dislikes'
        ? Array < UserCommentDislikesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Comment ?Comment [P]
  : 
          P extends 'author'
        ? UserGetPayload<S['select'][P]> :
        P extends 'idea'
        ? IdeaGetPayload<S['select'][P]> | null :
        P extends 'proposal'
        ? ProposalGetPayload<S['select'][P]> | null :
        P extends 'userSeg'
        ? UserSegmentsGetPayload<S['select'][P]> :
        P extends 'likes'
        ? Array < UserCommentLikesGetPayload<S['select'][P]>>  :
        P extends 'dislikes'
        ? Array < UserCommentDislikesGetPayload<S['select'][P]>>  : never
  } 
    : Comment
  : Comment


  type CommentCountArgs = Merge<
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }
  >

  export interface CommentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>> : CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>> : CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Comment>>, PrismaPromise<Array<CommentGetPayload<T>>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): CheckSelect<T, Prisma__CommentClient<Comment>, Prisma__CommentClient<CommentGetPayload<T>>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    idea<T extends IdeaArgs = {}>(args?: Subset<T, IdeaArgs>): CheckSelect<T, Prisma__IdeaClient<Idea | null >, Prisma__IdeaClient<IdeaGetPayload<T> | null >>;

    proposal<T extends ProposalArgs = {}>(args?: Subset<T, ProposalArgs>): CheckSelect<T, Prisma__ProposalClient<Proposal | null >, Prisma__ProposalClient<ProposalGetPayload<T> | null >>;

    userSeg<T extends UserSegmentsArgs = {}>(args?: Subset<T, UserSegmentsArgs>): CheckSelect<T, Prisma__UserSegmentsClient<UserSegments | null >, Prisma__UserSegmentsClient<UserSegmentsGetPayload<T> | null >>;

    likes<T extends UserCommentLikesFindManyArgs = {}>(args?: Subset<T, UserCommentLikesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCommentLikes>>, PrismaPromise<Array<UserCommentLikesGetPayload<T>>>>;

    dislikes<T extends UserCommentDislikesFindManyArgs = {}>(args?: Subset<T, UserCommentDislikesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserCommentDislikes>>, PrismaPromise<Array<UserCommentDislikesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Throw an Error if a Comment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comment to fetch.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Throw an Error if a Comment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Comment to fetch.
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
    **/
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
    **/
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
    **/
    orderBy?: Enumerable<CommentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
    **/
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
    **/
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
    **/
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
    **/
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
    **/
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
    **/
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
    **/
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
    **/
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CommentInclude | null
  }



  /**
   * Model UserCommentLikes
   */


  export type AggregateUserCommentLikes = {
    count: UserCommentLikesCountAggregateOutputType | null
    avg: UserCommentLikesAvgAggregateOutputType | null
    sum: UserCommentLikesSumAggregateOutputType | null
    min: UserCommentLikesMinAggregateOutputType | null
    max: UserCommentLikesMaxAggregateOutputType | null
  }

  export type UserCommentLikesAvgAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
  }

  export type UserCommentLikesSumAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
  }

  export type UserCommentLikesMinAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
    authorId: string | null
  }

  export type UserCommentLikesMaxAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
    authorId: string | null
  }

  export type UserCommentLikesCountAggregateOutputType = {
    id: number
    ideaCommentId: number
    authorId: number
    _all: number
  }


  export type UserCommentLikesAvgAggregateInputType = {
    id?: true
    ideaCommentId?: true
  }

  export type UserCommentLikesSumAggregateInputType = {
    id?: true
    ideaCommentId?: true
  }

  export type UserCommentLikesMinAggregateInputType = {
    id?: true
    ideaCommentId?: true
    authorId?: true
  }

  export type UserCommentLikesMaxAggregateInputType = {
    id?: true
    ideaCommentId?: true
    authorId?: true
  }

  export type UserCommentLikesCountAggregateInputType = {
    id?: true
    ideaCommentId?: true
    authorId?: true
    _all?: true
  }

  export type UserCommentLikesAggregateArgs = {
    /**
     * Filter which UserCommentLikes to aggregate.
    **/
    where?: UserCommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommentLikes to fetch.
    **/
    orderBy?: Enumerable<UserCommentLikesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserCommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommentLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommentLikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCommentLikes
    **/
    count?: true | UserCommentLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserCommentLikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserCommentLikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserCommentLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserCommentLikesMaxAggregateInputType
  }

  export type GetUserCommentLikesAggregateType<T extends UserCommentLikesAggregateArgs> = {
    [P in keyof T & keyof AggregateUserCommentLikes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCommentLikes[P]>
      : GetScalarType<T[P], AggregateUserCommentLikes[P]>
  }


    
    
  export type UserCommentLikesGroupByArgs = {
    where?: UserCommentLikesWhereInput
    orderBy?: Enumerable<UserCommentLikesOrderByInput>
    by: Array<UserCommentLikesScalarFieldEnum>
    having?: UserCommentLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserCommentLikesCountAggregateInputType | true
    avg?: UserCommentLikesAvgAggregateInputType
    sum?: UserCommentLikesSumAggregateInputType
    min?: UserCommentLikesMinAggregateInputType
    max?: UserCommentLikesMaxAggregateInputType
  }


  export type UserCommentLikesGroupByOutputType = {
    id: number
    ideaCommentId: number | null
    authorId: string | null
    count: UserCommentLikesCountAggregateOutputType | null
    avg: UserCommentLikesAvgAggregateOutputType | null
    sum: UserCommentLikesSumAggregateOutputType | null
    min: UserCommentLikesMinAggregateOutputType | null
    max: UserCommentLikesMaxAggregateOutputType | null
  }

  type GetUserCommentLikesGroupByPayload<T extends UserCommentLikesGroupByArgs> = Promise<Array<
    PickArray<UserCommentLikesGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserCommentLikesGroupByOutputType))]: GetScalarType<T[P], UserCommentLikesGroupByOutputType[P]>
    }
  >>
    

  export type UserCommentLikesSelect = {
    id?: boolean
    ideaCommentId?: boolean
    authorId?: boolean
    ideaComment?: boolean | CommentArgs
    author?: boolean | UserArgs
  }

  export type UserCommentLikesInclude = {
    ideaComment?: boolean | CommentArgs
    author?: boolean | UserArgs
  }

  export type UserCommentLikesGetPayload<
    S extends boolean | null | undefined | UserCommentLikesArgs,
    U = keyof S
      > = S extends true
        ? UserCommentLikes
    : S extends undefined
    ? never
    : S extends UserCommentLikesArgs | UserCommentLikesFindManyArgs
    ?'include' extends U
    ? UserCommentLikes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ideaComment'
        ? CommentGetPayload<S['include'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCommentLikes ?UserCommentLikes [P]
  : 
          P extends 'ideaComment'
        ? CommentGetPayload<S['select'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : UserCommentLikes
  : UserCommentLikes


  type UserCommentLikesCountArgs = Merge<
    Omit<UserCommentLikesFindManyArgs, 'select' | 'include'> & {
      select?: UserCommentLikesCountAggregateInputType | true
    }
  >

  export interface UserCommentLikesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserCommentLikes that matches the filter.
     * @param {UserCommentLikesFindUniqueArgs} args - Arguments to find a UserCommentLikes
     * @example
     * // Get one UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserCommentLikesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserCommentLikesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserCommentLikes'> extends True ? CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes>, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T>>> : CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes | null >, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T> | null >>

    /**
     * Find the first UserCommentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentLikesFindFirstArgs} args - Arguments to find a UserCommentLikes
     * @example
     * // Get one UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserCommentLikesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserCommentLikesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserCommentLikes'> extends True ? CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes>, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T>>> : CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes | null >, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T> | null >>

    /**
     * Find zero or more UserCommentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentLikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.findMany()
     * 
     * // Get first 10 UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCommentLikesWithIdOnly = await prisma.userCommentLikes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserCommentLikesFindManyArgs>(
      args?: SelectSubset<T, UserCommentLikesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserCommentLikes>>, PrismaPromise<Array<UserCommentLikesGetPayload<T>>>>

    /**
     * Create a UserCommentLikes.
     * @param {UserCommentLikesCreateArgs} args - Arguments to create a UserCommentLikes.
     * @example
     * // Create one UserCommentLikes
     * const UserCommentLikes = await prisma.userCommentLikes.create({
     *   data: {
     *     // ... data to create a UserCommentLikes
     *   }
     * })
     * 
    **/
    create<T extends UserCommentLikesCreateArgs>(
      args: SelectSubset<T, UserCommentLikesCreateArgs>
    ): CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes>, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T>>>

    /**
     * Create many UserCommentLikes.
     *     @param {UserCommentLikesCreateManyArgs} args - Arguments to create many UserCommentLikes.
     *     @example
     *     // Create many UserCommentLikes
     *     const userCommentLikes = await prisma.userCommentLikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCommentLikesCreateManyArgs>(
      args?: SelectSubset<T, UserCommentLikesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserCommentLikes.
     * @param {UserCommentLikesDeleteArgs} args - Arguments to delete one UserCommentLikes.
     * @example
     * // Delete one UserCommentLikes
     * const UserCommentLikes = await prisma.userCommentLikes.delete({
     *   where: {
     *     // ... filter to delete one UserCommentLikes
     *   }
     * })
     * 
    **/
    delete<T extends UserCommentLikesDeleteArgs>(
      args: SelectSubset<T, UserCommentLikesDeleteArgs>
    ): CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes>, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T>>>

    /**
     * Update one UserCommentLikes.
     * @param {UserCommentLikesUpdateArgs} args - Arguments to update one UserCommentLikes.
     * @example
     * // Update one UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserCommentLikesUpdateArgs>(
      args: SelectSubset<T, UserCommentLikesUpdateArgs>
    ): CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes>, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T>>>

    /**
     * Delete zero or more UserCommentLikes.
     * @param {UserCommentLikesDeleteManyArgs} args - Arguments to filter UserCommentLikes to delete.
     * @example
     * // Delete a few UserCommentLikes
     * const { count } = await prisma.userCommentLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserCommentLikesDeleteManyArgs>(
      args?: SelectSubset<T, UserCommentLikesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserCommentLikesUpdateManyArgs>(
      args: SelectSubset<T, UserCommentLikesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCommentLikes.
     * @param {UserCommentLikesUpsertArgs} args - Arguments to update or create a UserCommentLikes.
     * @example
     * // Update or create a UserCommentLikes
     * const userCommentLikes = await prisma.userCommentLikes.upsert({
     *   create: {
     *     // ... data to create a UserCommentLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCommentLikes we want to update
     *   }
     * })
    **/
    upsert<T extends UserCommentLikesUpsertArgs>(
      args: SelectSubset<T, UserCommentLikesUpsertArgs>
    ): CheckSelect<T, Prisma__UserCommentLikesClient<UserCommentLikes>, Prisma__UserCommentLikesClient<UserCommentLikesGetPayload<T>>>

    /**
     * Count the number of UserCommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentLikesCountArgs} args - Arguments to filter UserCommentLikes to count.
     * @example
     * // Count the number of UserCommentLikes
     * const count = await prisma.userCommentLikes.count({
     *   where: {
     *     // ... the filter for the UserCommentLikes we want to count
     *   }
     * })
    **/
    count<T extends UserCommentLikesCountArgs>(
      args?: Subset<T, UserCommentLikesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCommentLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCommentLikesAggregateArgs>(args: Subset<T, UserCommentLikesAggregateArgs>): PrismaPromise<GetUserCommentLikesAggregateType<T>>

    /**
     * Group by UserCommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCommentLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCommentLikesGroupByArgs['orderBy'] }
        : { orderBy?: UserCommentLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCommentLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCommentLikesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCommentLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserCommentLikesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ideaComment<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>;

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserCommentLikes findUnique
   */
  export type UserCommentLikesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * Throw an Error if a UserCommentLikes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserCommentLikes to fetch.
    **/
    where: UserCommentLikesWhereUniqueInput
  }


  /**
   * UserCommentLikes findFirst
   */
  export type UserCommentLikesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * Throw an Error if a UserCommentLikes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserCommentLikes to fetch.
    **/
    where?: UserCommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommentLikes to fetch.
    **/
    orderBy?: Enumerable<UserCommentLikesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCommentLikes.
    **/
    cursor?: UserCommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommentLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommentLikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCommentLikes.
    **/
    distinct?: Enumerable<UserCommentLikesScalarFieldEnum>
  }


  /**
   * UserCommentLikes findMany
   */
  export type UserCommentLikesFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * Filter, which UserCommentLikes to fetch.
    **/
    where?: UserCommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommentLikes to fetch.
    **/
    orderBy?: Enumerable<UserCommentLikesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCommentLikes.
    **/
    cursor?: UserCommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommentLikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommentLikes.
    **/
    skip?: number
    distinct?: Enumerable<UserCommentLikesScalarFieldEnum>
  }


  /**
   * UserCommentLikes create
   */
  export type UserCommentLikesCreateArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * The data needed to create a UserCommentLikes.
    **/
    data: XOR<UserCommentLikesCreateInput, UserCommentLikesUncheckedCreateInput>
  }


  /**
   * UserCommentLikes createMany
   */
  export type UserCommentLikesCreateManyArgs = {
    data: Enumerable<UserCommentLikesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserCommentLikes update
   */
  export type UserCommentLikesUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * The data needed to update a UserCommentLikes.
    **/
    data: XOR<UserCommentLikesUpdateInput, UserCommentLikesUncheckedUpdateInput>
    /**
     * Choose, which UserCommentLikes to update.
    **/
    where: UserCommentLikesWhereUniqueInput
  }


  /**
   * UserCommentLikes updateMany
   */
  export type UserCommentLikesUpdateManyArgs = {
    data: XOR<UserCommentLikesUpdateManyMutationInput, UserCommentLikesUncheckedUpdateManyInput>
    where?: UserCommentLikesWhereInput
  }


  /**
   * UserCommentLikes upsert
   */
  export type UserCommentLikesUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * The filter to search for the UserCommentLikes to update in case it exists.
    **/
    where: UserCommentLikesWhereUniqueInput
    /**
     * In case the UserCommentLikes found by the `where` argument doesn't exist, create a new UserCommentLikes with this data.
    **/
    create: XOR<UserCommentLikesCreateInput, UserCommentLikesUncheckedCreateInput>
    /**
     * In case the UserCommentLikes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserCommentLikesUpdateInput, UserCommentLikesUncheckedUpdateInput>
  }


  /**
   * UserCommentLikes delete
   */
  export type UserCommentLikesDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
    /**
     * Filter which UserCommentLikes to delete.
    **/
    where: UserCommentLikesWhereUniqueInput
  }


  /**
   * UserCommentLikes deleteMany
   */
  export type UserCommentLikesDeleteManyArgs = {
    where?: UserCommentLikesWhereInput
  }


  /**
   * UserCommentLikes without action
   */
  export type UserCommentLikesArgs = {
    /**
     * Select specific fields to fetch from the UserCommentLikes
    **/
    select?: UserCommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentLikesInclude | null
  }



  /**
   * Model UserCommentDislikes
   */


  export type AggregateUserCommentDislikes = {
    count: UserCommentDislikesCountAggregateOutputType | null
    avg: UserCommentDislikesAvgAggregateOutputType | null
    sum: UserCommentDislikesSumAggregateOutputType | null
    min: UserCommentDislikesMinAggregateOutputType | null
    max: UserCommentDislikesMaxAggregateOutputType | null
  }

  export type UserCommentDislikesAvgAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
  }

  export type UserCommentDislikesSumAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
  }

  export type UserCommentDislikesMinAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
    authorId: string | null
  }

  export type UserCommentDislikesMaxAggregateOutputType = {
    id: number | null
    ideaCommentId: number | null
    authorId: string | null
  }

  export type UserCommentDislikesCountAggregateOutputType = {
    id: number
    ideaCommentId: number
    authorId: number
    _all: number
  }


  export type UserCommentDislikesAvgAggregateInputType = {
    id?: true
    ideaCommentId?: true
  }

  export type UserCommentDislikesSumAggregateInputType = {
    id?: true
    ideaCommentId?: true
  }

  export type UserCommentDislikesMinAggregateInputType = {
    id?: true
    ideaCommentId?: true
    authorId?: true
  }

  export type UserCommentDislikesMaxAggregateInputType = {
    id?: true
    ideaCommentId?: true
    authorId?: true
  }

  export type UserCommentDislikesCountAggregateInputType = {
    id?: true
    ideaCommentId?: true
    authorId?: true
    _all?: true
  }

  export type UserCommentDislikesAggregateArgs = {
    /**
     * Filter which UserCommentDislikes to aggregate.
    **/
    where?: UserCommentDislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommentDislikes to fetch.
    **/
    orderBy?: Enumerable<UserCommentDislikesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserCommentDislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommentDislikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommentDislikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCommentDislikes
    **/
    count?: true | UserCommentDislikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UserCommentDislikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UserCommentDislikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserCommentDislikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserCommentDislikesMaxAggregateInputType
  }

  export type GetUserCommentDislikesAggregateType<T extends UserCommentDislikesAggregateArgs> = {
    [P in keyof T & keyof AggregateUserCommentDislikes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCommentDislikes[P]>
      : GetScalarType<T[P], AggregateUserCommentDislikes[P]>
  }


    
    
  export type UserCommentDislikesGroupByArgs = {
    where?: UserCommentDislikesWhereInput
    orderBy?: Enumerable<UserCommentDislikesOrderByInput>
    by: Array<UserCommentDislikesScalarFieldEnum>
    having?: UserCommentDislikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: UserCommentDislikesCountAggregateInputType | true
    avg?: UserCommentDislikesAvgAggregateInputType
    sum?: UserCommentDislikesSumAggregateInputType
    min?: UserCommentDislikesMinAggregateInputType
    max?: UserCommentDislikesMaxAggregateInputType
  }


  export type UserCommentDislikesGroupByOutputType = {
    id: number
    ideaCommentId: number | null
    authorId: string | null
    count: UserCommentDislikesCountAggregateOutputType | null
    avg: UserCommentDislikesAvgAggregateOutputType | null
    sum: UserCommentDislikesSumAggregateOutputType | null
    min: UserCommentDislikesMinAggregateOutputType | null
    max: UserCommentDislikesMaxAggregateOutputType | null
  }

  type GetUserCommentDislikesGroupByPayload<T extends UserCommentDislikesGroupByArgs> = Promise<Array<
    PickArray<UserCommentDislikesGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof UserCommentDislikesGroupByOutputType))]: GetScalarType<T[P], UserCommentDislikesGroupByOutputType[P]>
    }
  >>
    

  export type UserCommentDislikesSelect = {
    id?: boolean
    ideaCommentId?: boolean
    authorId?: boolean
    ideaComment?: boolean | CommentArgs
    author?: boolean | UserArgs
  }

  export type UserCommentDislikesInclude = {
    ideaComment?: boolean | CommentArgs
    author?: boolean | UserArgs
  }

  export type UserCommentDislikesGetPayload<
    S extends boolean | null | undefined | UserCommentDislikesArgs,
    U = keyof S
      > = S extends true
        ? UserCommentDislikes
    : S extends undefined
    ? never
    : S extends UserCommentDislikesArgs | UserCommentDislikesFindManyArgs
    ?'include' extends U
    ? UserCommentDislikes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ideaComment'
        ? CommentGetPayload<S['include'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCommentDislikes ?UserCommentDislikes [P]
  : 
          P extends 'ideaComment'
        ? CommentGetPayload<S['select'][P]> | null :
        P extends 'author'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : UserCommentDislikes
  : UserCommentDislikes


  type UserCommentDislikesCountArgs = Merge<
    Omit<UserCommentDislikesFindManyArgs, 'select' | 'include'> & {
      select?: UserCommentDislikesCountAggregateInputType | true
    }
  >

  export interface UserCommentDislikesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UserCommentDislikes that matches the filter.
     * @param {UserCommentDislikesFindUniqueArgs} args - Arguments to find a UserCommentDislikes
     * @example
     * // Get one UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserCommentDislikesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserCommentDislikesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserCommentDislikes'> extends True ? CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes>, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T>>> : CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes | null >, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T> | null >>

    /**
     * Find the first UserCommentDislikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentDislikesFindFirstArgs} args - Arguments to find a UserCommentDislikes
     * @example
     * // Get one UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserCommentDislikesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserCommentDislikesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserCommentDislikes'> extends True ? CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes>, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T>>> : CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes | null >, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T> | null >>

    /**
     * Find zero or more UserCommentDislikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentDislikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.findMany()
     * 
     * // Get first 10 UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCommentDislikesWithIdOnly = await prisma.userCommentDislikes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserCommentDislikesFindManyArgs>(
      args?: SelectSubset<T, UserCommentDislikesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UserCommentDislikes>>, PrismaPromise<Array<UserCommentDislikesGetPayload<T>>>>

    /**
     * Create a UserCommentDislikes.
     * @param {UserCommentDislikesCreateArgs} args - Arguments to create a UserCommentDislikes.
     * @example
     * // Create one UserCommentDislikes
     * const UserCommentDislikes = await prisma.userCommentDislikes.create({
     *   data: {
     *     // ... data to create a UserCommentDislikes
     *   }
     * })
     * 
    **/
    create<T extends UserCommentDislikesCreateArgs>(
      args: SelectSubset<T, UserCommentDislikesCreateArgs>
    ): CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes>, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T>>>

    /**
     * Create many UserCommentDislikes.
     *     @param {UserCommentDislikesCreateManyArgs} args - Arguments to create many UserCommentDislikes.
     *     @example
     *     // Create many UserCommentDislikes
     *     const userCommentDislikes = await prisma.userCommentDislikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCommentDislikesCreateManyArgs>(
      args?: SelectSubset<T, UserCommentDislikesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserCommentDislikes.
     * @param {UserCommentDislikesDeleteArgs} args - Arguments to delete one UserCommentDislikes.
     * @example
     * // Delete one UserCommentDislikes
     * const UserCommentDislikes = await prisma.userCommentDislikes.delete({
     *   where: {
     *     // ... filter to delete one UserCommentDislikes
     *   }
     * })
     * 
    **/
    delete<T extends UserCommentDislikesDeleteArgs>(
      args: SelectSubset<T, UserCommentDislikesDeleteArgs>
    ): CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes>, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T>>>

    /**
     * Update one UserCommentDislikes.
     * @param {UserCommentDislikesUpdateArgs} args - Arguments to update one UserCommentDislikes.
     * @example
     * // Update one UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserCommentDislikesUpdateArgs>(
      args: SelectSubset<T, UserCommentDislikesUpdateArgs>
    ): CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes>, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T>>>

    /**
     * Delete zero or more UserCommentDislikes.
     * @param {UserCommentDislikesDeleteManyArgs} args - Arguments to filter UserCommentDislikes to delete.
     * @example
     * // Delete a few UserCommentDislikes
     * const { count } = await prisma.userCommentDislikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserCommentDislikesDeleteManyArgs>(
      args?: SelectSubset<T, UserCommentDislikesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCommentDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentDislikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserCommentDislikesUpdateManyArgs>(
      args: SelectSubset<T, UserCommentDislikesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCommentDislikes.
     * @param {UserCommentDislikesUpsertArgs} args - Arguments to update or create a UserCommentDislikes.
     * @example
     * // Update or create a UserCommentDislikes
     * const userCommentDislikes = await prisma.userCommentDislikes.upsert({
     *   create: {
     *     // ... data to create a UserCommentDislikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCommentDislikes we want to update
     *   }
     * })
    **/
    upsert<T extends UserCommentDislikesUpsertArgs>(
      args: SelectSubset<T, UserCommentDislikesUpsertArgs>
    ): CheckSelect<T, Prisma__UserCommentDislikesClient<UserCommentDislikes>, Prisma__UserCommentDislikesClient<UserCommentDislikesGetPayload<T>>>

    /**
     * Count the number of UserCommentDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentDislikesCountArgs} args - Arguments to filter UserCommentDislikes to count.
     * @example
     * // Count the number of UserCommentDislikes
     * const count = await prisma.userCommentDislikes.count({
     *   where: {
     *     // ... the filter for the UserCommentDislikes we want to count
     *   }
     * })
    **/
    count<T extends UserCommentDislikesCountArgs>(
      args?: Subset<T, UserCommentDislikesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCommentDislikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCommentDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentDislikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCommentDislikesAggregateArgs>(args: Subset<T, UserCommentDislikesAggregateArgs>): PrismaPromise<GetUserCommentDislikesAggregateType<T>>

    /**
     * Group by UserCommentDislikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCommentDislikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCommentDislikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCommentDislikesGroupByArgs['orderBy'] }
        : { orderBy?: UserCommentDislikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCommentDislikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCommentDislikesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCommentDislikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserCommentDislikesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ideaComment<T extends CommentArgs = {}>(args?: Subset<T, CommentArgs>): CheckSelect<T, Prisma__CommentClient<Comment | null >, Prisma__CommentClient<CommentGetPayload<T> | null >>;

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UserCommentDislikes findUnique
   */
  export type UserCommentDislikesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * Throw an Error if a UserCommentDislikes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserCommentDislikes to fetch.
    **/
    where: UserCommentDislikesWhereUniqueInput
  }


  /**
   * UserCommentDislikes findFirst
   */
  export type UserCommentDislikesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * Throw an Error if a UserCommentDislikes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UserCommentDislikes to fetch.
    **/
    where?: UserCommentDislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommentDislikes to fetch.
    **/
    orderBy?: Enumerable<UserCommentDislikesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCommentDislikes.
    **/
    cursor?: UserCommentDislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommentDislikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommentDislikes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCommentDislikes.
    **/
    distinct?: Enumerable<UserCommentDislikesScalarFieldEnum>
  }


  /**
   * UserCommentDislikes findMany
   */
  export type UserCommentDislikesFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * Filter, which UserCommentDislikes to fetch.
    **/
    where?: UserCommentDislikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCommentDislikes to fetch.
    **/
    orderBy?: Enumerable<UserCommentDislikesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCommentDislikes.
    **/
    cursor?: UserCommentDislikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCommentDislikes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCommentDislikes.
    **/
    skip?: number
    distinct?: Enumerable<UserCommentDislikesScalarFieldEnum>
  }


  /**
   * UserCommentDislikes create
   */
  export type UserCommentDislikesCreateArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * The data needed to create a UserCommentDislikes.
    **/
    data: XOR<UserCommentDislikesCreateInput, UserCommentDislikesUncheckedCreateInput>
  }


  /**
   * UserCommentDislikes createMany
   */
  export type UserCommentDislikesCreateManyArgs = {
    data: Enumerable<UserCommentDislikesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserCommentDislikes update
   */
  export type UserCommentDislikesUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * The data needed to update a UserCommentDislikes.
    **/
    data: XOR<UserCommentDislikesUpdateInput, UserCommentDislikesUncheckedUpdateInput>
    /**
     * Choose, which UserCommentDislikes to update.
    **/
    where: UserCommentDislikesWhereUniqueInput
  }


  /**
   * UserCommentDislikes updateMany
   */
  export type UserCommentDislikesUpdateManyArgs = {
    data: XOR<UserCommentDislikesUpdateManyMutationInput, UserCommentDislikesUncheckedUpdateManyInput>
    where?: UserCommentDislikesWhereInput
  }


  /**
   * UserCommentDislikes upsert
   */
  export type UserCommentDislikesUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * The filter to search for the UserCommentDislikes to update in case it exists.
    **/
    where: UserCommentDislikesWhereUniqueInput
    /**
     * In case the UserCommentDislikes found by the `where` argument doesn't exist, create a new UserCommentDislikes with this data.
    **/
    create: XOR<UserCommentDislikesCreateInput, UserCommentDislikesUncheckedCreateInput>
    /**
     * In case the UserCommentDislikes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserCommentDislikesUpdateInput, UserCommentDislikesUncheckedUpdateInput>
  }


  /**
   * UserCommentDislikes delete
   */
  export type UserCommentDislikesDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
    /**
     * Filter which UserCommentDislikes to delete.
    **/
    where: UserCommentDislikesWhereUniqueInput
  }


  /**
   * UserCommentDislikes deleteMany
   */
  export type UserCommentDislikesDeleteManyArgs = {
    where?: UserCommentDislikesWhereInput
  }


  /**
   * UserCommentDislikes without action
   */
  export type UserCommentDislikesArgs = {
    /**
     * Select specific fields to fetch from the UserCommentDislikes
    **/
    select?: UserCommentDislikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserCommentDislikesInclude | null
  }



  /**
   * Model Advertisements
   */


  export type AggregateAdvertisements = {
    count: AdvertisementsCountAggregateOutputType | null
    avg: AdvertisementsAvgAggregateOutputType | null
    sum: AdvertisementsSumAggregateOutputType | null
    min: AdvertisementsMinAggregateOutputType | null
    max: AdvertisementsMaxAggregateOutputType | null
  }

  export type AdvertisementsAvgAggregateOutputType = {
    id: number | null
  }

  export type AdvertisementsSumAggregateOutputType = {
    id: number | null
  }

  export type AdvertisementsMinAggregateOutputType = {
    id: number | null
    ownerId: string | null
    createAt: Date | null
    updateAt: Date | null
    adTitle: string | null
    adType: AdType | null
    duration: Date | null
    adPosition: string | null
    imagePath: string | null
    externalLink: string | null
    published: boolean | null
  }

  export type AdvertisementsMaxAggregateOutputType = {
    id: number | null
    ownerId: string | null
    createAt: Date | null
    updateAt: Date | null
    adTitle: string | null
    adType: AdType | null
    duration: Date | null
    adPosition: string | null
    imagePath: string | null
    externalLink: string | null
    published: boolean | null
  }

  export type AdvertisementsCountAggregateOutputType = {
    id: number
    ownerId: number
    createAt: number
    updateAt: number
    adTitle: number
    adType: number
    duration: number
    adPosition: number
    imagePath: number
    externalLink: number
    published: number
    _all: number
  }


  export type AdvertisementsAvgAggregateInputType = {
    id?: true
  }

  export type AdvertisementsSumAggregateInputType = {
    id?: true
  }

  export type AdvertisementsMinAggregateInputType = {
    id?: true
    ownerId?: true
    createAt?: true
    updateAt?: true
    adTitle?: true
    adType?: true
    duration?: true
    adPosition?: true
    imagePath?: true
    externalLink?: true
    published?: true
  }

  export type AdvertisementsMaxAggregateInputType = {
    id?: true
    ownerId?: true
    createAt?: true
    updateAt?: true
    adTitle?: true
    adType?: true
    duration?: true
    adPosition?: true
    imagePath?: true
    externalLink?: true
    published?: true
  }

  export type AdvertisementsCountAggregateInputType = {
    id?: true
    ownerId?: true
    createAt?: true
    updateAt?: true
    adTitle?: true
    adType?: true
    duration?: true
    adPosition?: true
    imagePath?: true
    externalLink?: true
    published?: true
    _all?: true
  }

  export type AdvertisementsAggregateArgs = {
    /**
     * Filter which Advertisements to aggregate.
    **/
    where?: AdvertisementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
    **/
    orderBy?: Enumerable<AdvertisementsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AdvertisementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advertisements
    **/
    count?: true | AdvertisementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AdvertisementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AdvertisementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AdvertisementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AdvertisementsMaxAggregateInputType
  }

  export type GetAdvertisementsAggregateType<T extends AdvertisementsAggregateArgs> = {
    [P in keyof T & keyof AggregateAdvertisements]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisements[P]>
      : GetScalarType<T[P], AggregateAdvertisements[P]>
  }


    
    
  export type AdvertisementsGroupByArgs = {
    where?: AdvertisementsWhereInput
    orderBy?: Enumerable<AdvertisementsOrderByInput>
    by: Array<AdvertisementsScalarFieldEnum>
    having?: AdvertisementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: AdvertisementsCountAggregateInputType | true
    avg?: AdvertisementsAvgAggregateInputType
    sum?: AdvertisementsSumAggregateInputType
    min?: AdvertisementsMinAggregateInputType
    max?: AdvertisementsMaxAggregateInputType
  }


  export type AdvertisementsGroupByOutputType = {
    id: number
    ownerId: string
    createAt: Date
    updateAt: Date | null
    adTitle: string
    adType: AdType
    duration: Date | null
    adPosition: string
    imagePath: string
    externalLink: string
    published: boolean
    count: AdvertisementsCountAggregateOutputType | null
    avg: AdvertisementsAvgAggregateOutputType | null
    sum: AdvertisementsSumAggregateOutputType | null
    min: AdvertisementsMinAggregateOutputType | null
    max: AdvertisementsMaxAggregateOutputType | null
  }

  type GetAdvertisementsGroupByPayload<T extends AdvertisementsGroupByArgs> = Promise<Array<
    PickArray<AdvertisementsGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof AdvertisementsGroupByOutputType))]: GetScalarType<T[P], AdvertisementsGroupByOutputType[P]>
    }
  >>
    

  export type AdvertisementsSelect = {
    id?: boolean
    ownerId?: boolean
    createAt?: boolean
    updateAt?: boolean
    adTitle?: boolean
    adType?: boolean
    duration?: boolean
    adPosition?: boolean
    imagePath?: boolean
    externalLink?: boolean
    published?: boolean
    author?: boolean | UserArgs
  }

  export type AdvertisementsInclude = {
    author?: boolean | UserArgs
  }

  export type AdvertisementsGetPayload<
    S extends boolean | null | undefined | AdvertisementsArgs,
    U = keyof S
      > = S extends true
        ? Advertisements
    : S extends undefined
    ? never
    : S extends AdvertisementsArgs | AdvertisementsFindManyArgs
    ?'include' extends U
    ? Advertisements  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'author'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Advertisements ?Advertisements [P]
  : 
          P extends 'author'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : Advertisements
  : Advertisements


  type AdvertisementsCountArgs = Merge<
    Omit<AdvertisementsFindManyArgs, 'select' | 'include'> & {
      select?: AdvertisementsCountAggregateInputType | true
    }
  >

  export interface AdvertisementsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Advertisements that matches the filter.
     * @param {AdvertisementsFindUniqueArgs} args - Arguments to find a Advertisements
     * @example
     * // Get one Advertisements
     * const advertisements = await prisma.advertisements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvertisementsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdvertisementsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Advertisements'> extends True ? CheckSelect<T, Prisma__AdvertisementsClient<Advertisements>, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T>>> : CheckSelect<T, Prisma__AdvertisementsClient<Advertisements | null >, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T> | null >>

    /**
     * Find the first Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementsFindFirstArgs} args - Arguments to find a Advertisements
     * @example
     * // Get one Advertisements
     * const advertisements = await prisma.advertisements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvertisementsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdvertisementsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Advertisements'> extends True ? CheckSelect<T, Prisma__AdvertisementsClient<Advertisements>, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T>>> : CheckSelect<T, Prisma__AdvertisementsClient<Advertisements | null >, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T> | null >>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisements.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisementsWithIdOnly = await prisma.advertisements.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdvertisementsFindManyArgs>(
      args?: SelectSubset<T, AdvertisementsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Advertisements>>, PrismaPromise<Array<AdvertisementsGetPayload<T>>>>

    /**
     * Create a Advertisements.
     * @param {AdvertisementsCreateArgs} args - Arguments to create a Advertisements.
     * @example
     * // Create one Advertisements
     * const Advertisements = await prisma.advertisements.create({
     *   data: {
     *     // ... data to create a Advertisements
     *   }
     * })
     * 
    **/
    create<T extends AdvertisementsCreateArgs>(
      args: SelectSubset<T, AdvertisementsCreateArgs>
    ): CheckSelect<T, Prisma__AdvertisementsClient<Advertisements>, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T>>>

    /**
     * Create many Advertisements.
     *     @param {AdvertisementsCreateManyArgs} args - Arguments to create many Advertisements.
     *     @example
     *     // Create many Advertisements
     *     const advertisements = await prisma.advertisements.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvertisementsCreateManyArgs>(
      args?: SelectSubset<T, AdvertisementsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Advertisements.
     * @param {AdvertisementsDeleteArgs} args - Arguments to delete one Advertisements.
     * @example
     * // Delete one Advertisements
     * const Advertisements = await prisma.advertisements.delete({
     *   where: {
     *     // ... filter to delete one Advertisements
     *   }
     * })
     * 
    **/
    delete<T extends AdvertisementsDeleteArgs>(
      args: SelectSubset<T, AdvertisementsDeleteArgs>
    ): CheckSelect<T, Prisma__AdvertisementsClient<Advertisements>, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T>>>

    /**
     * Update one Advertisements.
     * @param {AdvertisementsUpdateArgs} args - Arguments to update one Advertisements.
     * @example
     * // Update one Advertisements
     * const advertisements = await prisma.advertisements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvertisementsUpdateArgs>(
      args: SelectSubset<T, AdvertisementsUpdateArgs>
    ): CheckSelect<T, Prisma__AdvertisementsClient<Advertisements>, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T>>>

    /**
     * Delete zero or more Advertisements.
     * @param {AdvertisementsDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvertisementsDeleteManyArgs>(
      args?: SelectSubset<T, AdvertisementsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisements = await prisma.advertisements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvertisementsUpdateManyArgs>(
      args: SelectSubset<T, AdvertisementsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Advertisements.
     * @param {AdvertisementsUpsertArgs} args - Arguments to update or create a Advertisements.
     * @example
     * // Update or create a Advertisements
     * const advertisements = await prisma.advertisements.upsert({
     *   create: {
     *     // ... data to create a Advertisements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisements we want to update
     *   }
     * })
    **/
    upsert<T extends AdvertisementsUpsertArgs>(
      args: SelectSubset<T, AdvertisementsUpsertArgs>
    ): CheckSelect<T, Prisma__AdvertisementsClient<Advertisements>, Prisma__AdvertisementsClient<AdvertisementsGetPayload<T>>>

    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementsCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisements.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisementsCountArgs>(
      args?: Subset<T, AdvertisementsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementsAggregateArgs>(args: Subset<T, AdvertisementsAggregateArgs>): PrismaPromise<GetAdvertisementsAggregateType<T>>

    /**
     * Group by Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisementsGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advertisements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdvertisementsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Advertisements findUnique
   */
  export type AdvertisementsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * Throw an Error if a Advertisements can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Advertisements to fetch.
    **/
    where: AdvertisementsWhereUniqueInput
  }


  /**
   * Advertisements findFirst
   */
  export type AdvertisementsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * Throw an Error if a Advertisements can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Advertisements to fetch.
    **/
    where?: AdvertisementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
    **/
    orderBy?: Enumerable<AdvertisementsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
    **/
    cursor?: AdvertisementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
    **/
    distinct?: Enumerable<AdvertisementsScalarFieldEnum>
  }


  /**
   * Advertisements findMany
   */
  export type AdvertisementsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * Filter, which Advertisements to fetch.
    **/
    where?: AdvertisementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
    **/
    orderBy?: Enumerable<AdvertisementsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advertisements.
    **/
    cursor?: AdvertisementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
    **/
    skip?: number
    distinct?: Enumerable<AdvertisementsScalarFieldEnum>
  }


  /**
   * Advertisements create
   */
  export type AdvertisementsCreateArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * The data needed to create a Advertisements.
    **/
    data: XOR<AdvertisementsCreateInput, AdvertisementsUncheckedCreateInput>
  }


  /**
   * Advertisements createMany
   */
  export type AdvertisementsCreateManyArgs = {
    data: Enumerable<AdvertisementsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Advertisements update
   */
  export type AdvertisementsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * The data needed to update a Advertisements.
    **/
    data: XOR<AdvertisementsUpdateInput, AdvertisementsUncheckedUpdateInput>
    /**
     * Choose, which Advertisements to update.
    **/
    where: AdvertisementsWhereUniqueInput
  }


  /**
   * Advertisements updateMany
   */
  export type AdvertisementsUpdateManyArgs = {
    data: XOR<AdvertisementsUpdateManyMutationInput, AdvertisementsUncheckedUpdateManyInput>
    where?: AdvertisementsWhereInput
  }


  /**
   * Advertisements upsert
   */
  export type AdvertisementsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * The filter to search for the Advertisements to update in case it exists.
    **/
    where: AdvertisementsWhereUniqueInput
    /**
     * In case the Advertisements found by the `where` argument doesn't exist, create a new Advertisements with this data.
    **/
    create: XOR<AdvertisementsCreateInput, AdvertisementsUncheckedCreateInput>
    /**
     * In case the Advertisements was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AdvertisementsUpdateInput, AdvertisementsUncheckedUpdateInput>
  }


  /**
   * Advertisements delete
   */
  export type AdvertisementsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
    /**
     * Filter which Advertisements to delete.
    **/
    where: AdvertisementsWhereUniqueInput
  }


  /**
   * Advertisements deleteMany
   */
  export type AdvertisementsDeleteManyArgs = {
    where?: AdvertisementsWhereInput
  }


  /**
   * Advertisements without action
   */
  export type AdvertisementsArgs = {
    /**
     * Select specific fields to fetch from the Advertisements
    **/
    select?: AdvertisementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AdvertisementsInclude | null
  }



  /**
   * Model SuperSegment
   */


  export type AggregateSuperSegment = {
    count: SuperSegmentCountAggregateOutputType | null
    avg: SuperSegmentAvgAggregateOutputType | null
    sum: SuperSegmentSumAggregateOutputType | null
    min: SuperSegmentMinAggregateOutputType | null
    max: SuperSegmentMaxAggregateOutputType | null
  }

  export type SuperSegmentAvgAggregateOutputType = {
    superSegId: number | null
  }

  export type SuperSegmentSumAggregateOutputType = {
    superSegId: number | null
  }

  export type SuperSegmentMinAggregateOutputType = {
    superSegId: number | null
    name: string | null
    country: string | null
    province: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperSegmentMaxAggregateOutputType = {
    superSegId: number | null
    name: string | null
    country: string | null
    province: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperSegmentCountAggregateOutputType = {
    superSegId: number
    name: number
    country: number
    province: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperSegmentAvgAggregateInputType = {
    superSegId?: true
  }

  export type SuperSegmentSumAggregateInputType = {
    superSegId?: true
  }

  export type SuperSegmentMinAggregateInputType = {
    superSegId?: true
    name?: true
    country?: true
    province?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperSegmentMaxAggregateInputType = {
    superSegId?: true
    name?: true
    country?: true
    province?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperSegmentCountAggregateInputType = {
    superSegId?: true
    name?: true
    country?: true
    province?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperSegmentAggregateArgs = {
    /**
     * Filter which SuperSegment to aggregate.
    **/
    where?: SuperSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperSegments to fetch.
    **/
    orderBy?: Enumerable<SuperSegmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SuperSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperSegments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperSegments
    **/
    count?: true | SuperSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SuperSegmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SuperSegmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SuperSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SuperSegmentMaxAggregateInputType
  }

  export type GetSuperSegmentAggregateType<T extends SuperSegmentAggregateArgs> = {
    [P in keyof T & keyof AggregateSuperSegment]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperSegment[P]>
      : GetScalarType<T[P], AggregateSuperSegment[P]>
  }


    
    
  export type SuperSegmentGroupByArgs = {
    where?: SuperSegmentWhereInput
    orderBy?: Enumerable<SuperSegmentOrderByInput>
    by: Array<SuperSegmentScalarFieldEnum>
    having?: SuperSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SuperSegmentCountAggregateInputType | true
    avg?: SuperSegmentAvgAggregateInputType
    sum?: SuperSegmentSumAggregateInputType
    min?: SuperSegmentMinAggregateInputType
    max?: SuperSegmentMaxAggregateInputType
  }


  export type SuperSegmentGroupByOutputType = {
    superSegId: number
    name: string
    country: string
    province: string
    createdAt: Date
    updatedAt: Date | null
    count: SuperSegmentCountAggregateOutputType | null
    avg: SuperSegmentAvgAggregateOutputType | null
    sum: SuperSegmentSumAggregateOutputType | null
    min: SuperSegmentMinAggregateOutputType | null
    max: SuperSegmentMaxAggregateOutputType | null
  }

  type GetSuperSegmentGroupByPayload<T extends SuperSegmentGroupByArgs> = Promise<Array<
    PickArray<SuperSegmentGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SuperSegmentGroupByOutputType))]: GetScalarType<T[P], SuperSegmentGroupByOutputType[P]>
    }
  >>
    

  export type SuperSegmentSelect = {
    superSegId?: boolean
    name?: boolean
    country?: boolean
    province?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Segments?: boolean | SegmentsFindManyArgs
    Idea?: boolean | IdeaFindManyArgs
    Proposal?: boolean | ProposalFindManyArgs
    homeUserSegments?: boolean | UserSegmentsFindManyArgs
    workUserSegments?: boolean | UserSegmentsFindManyArgs
    schoolUserSegments?: boolean | UserSegmentsFindManyArgs
  }

  export type SuperSegmentInclude = {
    Segments?: boolean | SegmentsFindManyArgs
    Idea?: boolean | IdeaFindManyArgs
    Proposal?: boolean | ProposalFindManyArgs
    homeUserSegments?: boolean | UserSegmentsFindManyArgs
    workUserSegments?: boolean | UserSegmentsFindManyArgs
    schoolUserSegments?: boolean | UserSegmentsFindManyArgs
  }

  export type SuperSegmentGetPayload<
    S extends boolean | null | undefined | SuperSegmentArgs,
    U = keyof S
      > = S extends true
        ? SuperSegment
    : S extends undefined
    ? never
    : S extends SuperSegmentArgs | SuperSegmentFindManyArgs
    ?'include' extends U
    ? SuperSegment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Segments'
        ? Array < SegmentsGetPayload<S['include'][P]>>  :
        P extends 'Idea'
        ? Array < IdeaGetPayload<S['include'][P]>>  :
        P extends 'Proposal'
        ? Array < ProposalGetPayload<S['include'][P]>>  :
        P extends 'homeUserSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'workUserSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'schoolUserSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SuperSegment ?SuperSegment [P]
  : 
          P extends 'Segments'
        ? Array < SegmentsGetPayload<S['select'][P]>>  :
        P extends 'Idea'
        ? Array < IdeaGetPayload<S['select'][P]>>  :
        P extends 'Proposal'
        ? Array < ProposalGetPayload<S['select'][P]>>  :
        P extends 'homeUserSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'workUserSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'schoolUserSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  : never
  } 
    : SuperSegment
  : SuperSegment


  type SuperSegmentCountArgs = Merge<
    Omit<SuperSegmentFindManyArgs, 'select' | 'include'> & {
      select?: SuperSegmentCountAggregateInputType | true
    }
  >

  export interface SuperSegmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SuperSegment that matches the filter.
     * @param {SuperSegmentFindUniqueArgs} args - Arguments to find a SuperSegment
     * @example
     * // Get one SuperSegment
     * const superSegment = await prisma.superSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SuperSegmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SuperSegmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SuperSegment'> extends True ? CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment>, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T>>> : CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>

    /**
     * Find the first SuperSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperSegmentFindFirstArgs} args - Arguments to find a SuperSegment
     * @example
     * // Get one SuperSegment
     * const superSegment = await prisma.superSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SuperSegmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SuperSegmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SuperSegment'> extends True ? CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment>, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T>>> : CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>

    /**
     * Find zero or more SuperSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperSegmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperSegments
     * const superSegments = await prisma.superSegment.findMany()
     * 
     * // Get first 10 SuperSegments
     * const superSegments = await prisma.superSegment.findMany({ take: 10 })
     * 
     * // Only select the `superSegId`
     * const superSegmentWithSuperSegIdOnly = await prisma.superSegment.findMany({ select: { superSegId: true } })
     * 
    **/
    findMany<T extends SuperSegmentFindManyArgs>(
      args?: SelectSubset<T, SuperSegmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SuperSegment>>, PrismaPromise<Array<SuperSegmentGetPayload<T>>>>

    /**
     * Create a SuperSegment.
     * @param {SuperSegmentCreateArgs} args - Arguments to create a SuperSegment.
     * @example
     * // Create one SuperSegment
     * const SuperSegment = await prisma.superSegment.create({
     *   data: {
     *     // ... data to create a SuperSegment
     *   }
     * })
     * 
    **/
    create<T extends SuperSegmentCreateArgs>(
      args: SelectSubset<T, SuperSegmentCreateArgs>
    ): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment>, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T>>>

    /**
     * Create many SuperSegments.
     *     @param {SuperSegmentCreateManyArgs} args - Arguments to create many SuperSegments.
     *     @example
     *     // Create many SuperSegments
     *     const superSegment = await prisma.superSegment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SuperSegmentCreateManyArgs>(
      args?: SelectSubset<T, SuperSegmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SuperSegment.
     * @param {SuperSegmentDeleteArgs} args - Arguments to delete one SuperSegment.
     * @example
     * // Delete one SuperSegment
     * const SuperSegment = await prisma.superSegment.delete({
     *   where: {
     *     // ... filter to delete one SuperSegment
     *   }
     * })
     * 
    **/
    delete<T extends SuperSegmentDeleteArgs>(
      args: SelectSubset<T, SuperSegmentDeleteArgs>
    ): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment>, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T>>>

    /**
     * Update one SuperSegment.
     * @param {SuperSegmentUpdateArgs} args - Arguments to update one SuperSegment.
     * @example
     * // Update one SuperSegment
     * const superSegment = await prisma.superSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SuperSegmentUpdateArgs>(
      args: SelectSubset<T, SuperSegmentUpdateArgs>
    ): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment>, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T>>>

    /**
     * Delete zero or more SuperSegments.
     * @param {SuperSegmentDeleteManyArgs} args - Arguments to filter SuperSegments to delete.
     * @example
     * // Delete a few SuperSegments
     * const { count } = await prisma.superSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SuperSegmentDeleteManyArgs>(
      args?: SelectSubset<T, SuperSegmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperSegments
     * const superSegment = await prisma.superSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SuperSegmentUpdateManyArgs>(
      args: SelectSubset<T, SuperSegmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SuperSegment.
     * @param {SuperSegmentUpsertArgs} args - Arguments to update or create a SuperSegment.
     * @example
     * // Update or create a SuperSegment
     * const superSegment = await prisma.superSegment.upsert({
     *   create: {
     *     // ... data to create a SuperSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperSegment we want to update
     *   }
     * })
    **/
    upsert<T extends SuperSegmentUpsertArgs>(
      args: SelectSubset<T, SuperSegmentUpsertArgs>
    ): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment>, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T>>>

    /**
     * Count the number of SuperSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperSegmentCountArgs} args - Arguments to filter SuperSegments to count.
     * @example
     * // Count the number of SuperSegments
     * const count = await prisma.superSegment.count({
     *   where: {
     *     // ... the filter for the SuperSegments we want to count
     *   }
     * })
    **/
    count<T extends SuperSegmentCountArgs>(
      args?: Subset<T, SuperSegmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperSegmentAggregateArgs>(args: Subset<T, SuperSegmentAggregateArgs>): PrismaPromise<GetSuperSegmentAggregateType<T>>

    /**
     * Group by SuperSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperSegmentGroupByArgs['orderBy'] }
        : { orderBy?: SuperSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperSegmentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SuperSegmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Segments<T extends SegmentsFindManyArgs = {}>(args?: Subset<T, SegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Segments>>, PrismaPromise<Array<SegmentsGetPayload<T>>>>;

    Idea<T extends IdeaFindManyArgs = {}>(args?: Subset<T, IdeaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>;

    Proposal<T extends ProposalFindManyArgs = {}>(args?: Subset<T, ProposalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>;

    homeUserSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    workUserSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    schoolUserSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SuperSegment findUnique
   */
  export type SuperSegmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * Throw an Error if a SuperSegment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SuperSegment to fetch.
    **/
    where: SuperSegmentWhereUniqueInput
  }


  /**
   * SuperSegment findFirst
   */
  export type SuperSegmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * Throw an Error if a SuperSegment can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SuperSegment to fetch.
    **/
    where?: SuperSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperSegments to fetch.
    **/
    orderBy?: Enumerable<SuperSegmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperSegments.
    **/
    cursor?: SuperSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperSegments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperSegments.
    **/
    distinct?: Enumerable<SuperSegmentScalarFieldEnum>
  }


  /**
   * SuperSegment findMany
   */
  export type SuperSegmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * Filter, which SuperSegments to fetch.
    **/
    where?: SuperSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperSegments to fetch.
    **/
    orderBy?: Enumerable<SuperSegmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperSegments.
    **/
    cursor?: SuperSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperSegments.
    **/
    skip?: number
    distinct?: Enumerable<SuperSegmentScalarFieldEnum>
  }


  /**
   * SuperSegment create
   */
  export type SuperSegmentCreateArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * The data needed to create a SuperSegment.
    **/
    data: XOR<SuperSegmentCreateInput, SuperSegmentUncheckedCreateInput>
  }


  /**
   * SuperSegment createMany
   */
  export type SuperSegmentCreateManyArgs = {
    data: Enumerable<SuperSegmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SuperSegment update
   */
  export type SuperSegmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * The data needed to update a SuperSegment.
    **/
    data: XOR<SuperSegmentUpdateInput, SuperSegmentUncheckedUpdateInput>
    /**
     * Choose, which SuperSegment to update.
    **/
    where: SuperSegmentWhereUniqueInput
  }


  /**
   * SuperSegment updateMany
   */
  export type SuperSegmentUpdateManyArgs = {
    data: XOR<SuperSegmentUpdateManyMutationInput, SuperSegmentUncheckedUpdateManyInput>
    where?: SuperSegmentWhereInput
  }


  /**
   * SuperSegment upsert
   */
  export type SuperSegmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * The filter to search for the SuperSegment to update in case it exists.
    **/
    where: SuperSegmentWhereUniqueInput
    /**
     * In case the SuperSegment found by the `where` argument doesn't exist, create a new SuperSegment with this data.
    **/
    create: XOR<SuperSegmentCreateInput, SuperSegmentUncheckedCreateInput>
    /**
     * In case the SuperSegment was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SuperSegmentUpdateInput, SuperSegmentUncheckedUpdateInput>
  }


  /**
   * SuperSegment delete
   */
  export type SuperSegmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
    /**
     * Filter which SuperSegment to delete.
    **/
    where: SuperSegmentWhereUniqueInput
  }


  /**
   * SuperSegment deleteMany
   */
  export type SuperSegmentDeleteManyArgs = {
    where?: SuperSegmentWhereInput
  }


  /**
   * SuperSegment without action
   */
  export type SuperSegmentArgs = {
    /**
     * Select specific fields to fetch from the SuperSegment
    **/
    select?: SuperSegmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SuperSegmentInclude | null
  }



  /**
   * Model Segments
   */


  export type AggregateSegments = {
    count: SegmentsCountAggregateOutputType | null
    avg: SegmentsAvgAggregateOutputType | null
    sum: SegmentsSumAggregateOutputType | null
    min: SegmentsMinAggregateOutputType | null
    max: SegmentsMaxAggregateOutputType | null
  }

  export type SegmentsAvgAggregateOutputType = {
    segId: number | null
    superSegId: number | null
  }

  export type SegmentsSumAggregateOutputType = {
    segId: number | null
    superSegId: number | null
  }

  export type SegmentsMinAggregateOutputType = {
    segId: number | null
    superSegId: number | null
    country: string | null
    province: string | null
    name: string | null
    superSegName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentsMaxAggregateOutputType = {
    segId: number | null
    superSegId: number | null
    country: string | null
    province: string | null
    name: string | null
    superSegName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentsCountAggregateOutputType = {
    segId: number
    superSegId: number
    country: number
    province: number
    name: number
    superSegName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SegmentsAvgAggregateInputType = {
    segId?: true
    superSegId?: true
  }

  export type SegmentsSumAggregateInputType = {
    segId?: true
    superSegId?: true
  }

  export type SegmentsMinAggregateInputType = {
    segId?: true
    superSegId?: true
    country?: true
    province?: true
    name?: true
    superSegName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentsMaxAggregateInputType = {
    segId?: true
    superSegId?: true
    country?: true
    province?: true
    name?: true
    superSegName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentsCountAggregateInputType = {
    segId?: true
    superSegId?: true
    country?: true
    province?: true
    name?: true
    superSegName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SegmentsAggregateArgs = {
    /**
     * Filter which Segments to aggregate.
    **/
    where?: SegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
    **/
    orderBy?: Enumerable<SegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Segments
    **/
    count?: true | SegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SegmentsMaxAggregateInputType
  }

  export type GetSegmentsAggregateType<T extends SegmentsAggregateArgs> = {
    [P in keyof T & keyof AggregateSegments]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegments[P]>
      : GetScalarType<T[P], AggregateSegments[P]>
  }


    
    
  export type SegmentsGroupByArgs = {
    where?: SegmentsWhereInput
    orderBy?: Enumerable<SegmentsOrderByInput>
    by: Array<SegmentsScalarFieldEnum>
    having?: SegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SegmentsCountAggregateInputType | true
    avg?: SegmentsAvgAggregateInputType
    sum?: SegmentsSumAggregateInputType
    min?: SegmentsMinAggregateInputType
    max?: SegmentsMaxAggregateInputType
  }


  export type SegmentsGroupByOutputType = {
    segId: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName: string | null
    createdAt: Date
    updatedAt: Date | null
    count: SegmentsCountAggregateOutputType | null
    avg: SegmentsAvgAggregateOutputType | null
    sum: SegmentsSumAggregateOutputType | null
    min: SegmentsMinAggregateOutputType | null
    max: SegmentsMaxAggregateOutputType | null
  }

  type GetSegmentsGroupByPayload<T extends SegmentsGroupByArgs> = Promise<Array<
    PickArray<SegmentsGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SegmentsGroupByOutputType))]: GetScalarType<T[P], SegmentsGroupByOutputType[P]>
    }
  >>
    

  export type SegmentsSelect = {
    segId?: boolean
    superSegId?: boolean
    country?: boolean
    province?: boolean
    name?: boolean
    superSegName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superSegment?: boolean | SuperSegmentArgs
    SubSegments?: boolean | SubSegmentsFindManyArgs
    homeSegments?: boolean | UserSegmentsFindManyArgs
    workSegments?: boolean | UserSegmentsFindManyArgs
    schoolSegments?: boolean | UserSegmentsFindManyArgs
    Idea?: boolean | IdeaFindManyArgs
    Proposal?: boolean | ProposalFindManyArgs
  }

  export type SegmentsInclude = {
    superSegment?: boolean | SuperSegmentArgs
    SubSegments?: boolean | SubSegmentsFindManyArgs
    homeSegments?: boolean | UserSegmentsFindManyArgs
    workSegments?: boolean | UserSegmentsFindManyArgs
    schoolSegments?: boolean | UserSegmentsFindManyArgs
    Idea?: boolean | IdeaFindManyArgs
    Proposal?: boolean | ProposalFindManyArgs
  }

  export type SegmentsGetPayload<
    S extends boolean | null | undefined | SegmentsArgs,
    U = keyof S
      > = S extends true
        ? Segments
    : S extends undefined
    ? never
    : S extends SegmentsArgs | SegmentsFindManyArgs
    ?'include' extends U
    ? Segments  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'superSegment'
        ? SuperSegmentGetPayload<S['include'][P]> :
        P extends 'SubSegments'
        ? Array < SubSegmentsGetPayload<S['include'][P]>>  :
        P extends 'homeSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'workSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'schoolSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'Idea'
        ? Array < IdeaGetPayload<S['include'][P]>>  :
        P extends 'Proposal'
        ? Array < ProposalGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Segments ?Segments [P]
  : 
          P extends 'superSegment'
        ? SuperSegmentGetPayload<S['select'][P]> :
        P extends 'SubSegments'
        ? Array < SubSegmentsGetPayload<S['select'][P]>>  :
        P extends 'homeSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'workSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'schoolSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'Idea'
        ? Array < IdeaGetPayload<S['select'][P]>>  :
        P extends 'Proposal'
        ? Array < ProposalGetPayload<S['select'][P]>>  : never
  } 
    : Segments
  : Segments


  type SegmentsCountArgs = Merge<
    Omit<SegmentsFindManyArgs, 'select' | 'include'> & {
      select?: SegmentsCountAggregateInputType | true
    }
  >

  export interface SegmentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Segments that matches the filter.
     * @param {SegmentsFindUniqueArgs} args - Arguments to find a Segments
     * @example
     * // Get one Segments
     * const segments = await prisma.segments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SegmentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SegmentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Segments'> extends True ? CheckSelect<T, Prisma__SegmentsClient<Segments>, Prisma__SegmentsClient<SegmentsGetPayload<T>>> : CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>

    /**
     * Find the first Segments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentsFindFirstArgs} args - Arguments to find a Segments
     * @example
     * // Get one Segments
     * const segments = await prisma.segments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SegmentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SegmentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Segments'> extends True ? CheckSelect<T, Prisma__SegmentsClient<Segments>, Prisma__SegmentsClient<SegmentsGetPayload<T>>> : CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>

    /**
     * Find zero or more Segments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Segments
     * const segments = await prisma.segments.findMany()
     * 
     * // Get first 10 Segments
     * const segments = await prisma.segments.findMany({ take: 10 })
     * 
     * // Only select the `segId`
     * const segmentsWithSegIdOnly = await prisma.segments.findMany({ select: { segId: true } })
     * 
    **/
    findMany<T extends SegmentsFindManyArgs>(
      args?: SelectSubset<T, SegmentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Segments>>, PrismaPromise<Array<SegmentsGetPayload<T>>>>

    /**
     * Create a Segments.
     * @param {SegmentsCreateArgs} args - Arguments to create a Segments.
     * @example
     * // Create one Segments
     * const Segments = await prisma.segments.create({
     *   data: {
     *     // ... data to create a Segments
     *   }
     * })
     * 
    **/
    create<T extends SegmentsCreateArgs>(
      args: SelectSubset<T, SegmentsCreateArgs>
    ): CheckSelect<T, Prisma__SegmentsClient<Segments>, Prisma__SegmentsClient<SegmentsGetPayload<T>>>

    /**
     * Create many Segments.
     *     @param {SegmentsCreateManyArgs} args - Arguments to create many Segments.
     *     @example
     *     // Create many Segments
     *     const segments = await prisma.segments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SegmentsCreateManyArgs>(
      args?: SelectSubset<T, SegmentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Segments.
     * @param {SegmentsDeleteArgs} args - Arguments to delete one Segments.
     * @example
     * // Delete one Segments
     * const Segments = await prisma.segments.delete({
     *   where: {
     *     // ... filter to delete one Segments
     *   }
     * })
     * 
    **/
    delete<T extends SegmentsDeleteArgs>(
      args: SelectSubset<T, SegmentsDeleteArgs>
    ): CheckSelect<T, Prisma__SegmentsClient<Segments>, Prisma__SegmentsClient<SegmentsGetPayload<T>>>

    /**
     * Update one Segments.
     * @param {SegmentsUpdateArgs} args - Arguments to update one Segments.
     * @example
     * // Update one Segments
     * const segments = await prisma.segments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SegmentsUpdateArgs>(
      args: SelectSubset<T, SegmentsUpdateArgs>
    ): CheckSelect<T, Prisma__SegmentsClient<Segments>, Prisma__SegmentsClient<SegmentsGetPayload<T>>>

    /**
     * Delete zero or more Segments.
     * @param {SegmentsDeleteManyArgs} args - Arguments to filter Segments to delete.
     * @example
     * // Delete a few Segments
     * const { count } = await prisma.segments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SegmentsDeleteManyArgs>(
      args?: SelectSubset<T, SegmentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Segments
     * const segments = await prisma.segments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SegmentsUpdateManyArgs>(
      args: SelectSubset<T, SegmentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Segments.
     * @param {SegmentsUpsertArgs} args - Arguments to update or create a Segments.
     * @example
     * // Update or create a Segments
     * const segments = await prisma.segments.upsert({
     *   create: {
     *     // ... data to create a Segments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Segments we want to update
     *   }
     * })
    **/
    upsert<T extends SegmentsUpsertArgs>(
      args: SelectSubset<T, SegmentsUpsertArgs>
    ): CheckSelect<T, Prisma__SegmentsClient<Segments>, Prisma__SegmentsClient<SegmentsGetPayload<T>>>

    /**
     * Count the number of Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentsCountArgs} args - Arguments to filter Segments to count.
     * @example
     * // Count the number of Segments
     * const count = await prisma.segments.count({
     *   where: {
     *     // ... the filter for the Segments we want to count
     *   }
     * })
    **/
    count<T extends SegmentsCountArgs>(
      args?: Subset<T, SegmentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentsAggregateArgs>(args: Subset<T, SegmentsAggregateArgs>): PrismaPromise<GetSegmentsAggregateType<T>>

    /**
     * Group by Segments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentsGroupByArgs['orderBy'] }
        : { orderBy?: SegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Segments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SegmentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    superSegment<T extends SuperSegmentArgs = {}>(args?: Subset<T, SuperSegmentArgs>): CheckSelect<T, Prisma__SuperSegmentClient<SuperSegment | null >, Prisma__SuperSegmentClient<SuperSegmentGetPayload<T> | null >>;

    SubSegments<T extends SubSegmentsFindManyArgs = {}>(args?: Subset<T, SubSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SubSegments>>, PrismaPromise<Array<SubSegmentsGetPayload<T>>>>;

    homeSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    workSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    schoolSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    Idea<T extends IdeaFindManyArgs = {}>(args?: Subset<T, IdeaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>;

    Proposal<T extends ProposalFindManyArgs = {}>(args?: Subset<T, ProposalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Segments findUnique
   */
  export type SegmentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * Throw an Error if a Segments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Segments to fetch.
    **/
    where: SegmentsWhereUniqueInput
  }


  /**
   * Segments findFirst
   */
  export type SegmentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * Throw an Error if a Segments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Segments to fetch.
    **/
    where?: SegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
    **/
    orderBy?: Enumerable<SegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Segments.
    **/
    cursor?: SegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Segments.
    **/
    distinct?: Enumerable<SegmentsScalarFieldEnum>
  }


  /**
   * Segments findMany
   */
  export type SegmentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * Filter, which Segments to fetch.
    **/
    where?: SegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Segments to fetch.
    **/
    orderBy?: Enumerable<SegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Segments.
    **/
    cursor?: SegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Segments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Segments.
    **/
    skip?: number
    distinct?: Enumerable<SegmentsScalarFieldEnum>
  }


  /**
   * Segments create
   */
  export type SegmentsCreateArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * The data needed to create a Segments.
    **/
    data: XOR<SegmentsCreateInput, SegmentsUncheckedCreateInput>
  }


  /**
   * Segments createMany
   */
  export type SegmentsCreateManyArgs = {
    data: Enumerable<SegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Segments update
   */
  export type SegmentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * The data needed to update a Segments.
    **/
    data: XOR<SegmentsUpdateInput, SegmentsUncheckedUpdateInput>
    /**
     * Choose, which Segments to update.
    **/
    where: SegmentsWhereUniqueInput
  }


  /**
   * Segments updateMany
   */
  export type SegmentsUpdateManyArgs = {
    data: XOR<SegmentsUpdateManyMutationInput, SegmentsUncheckedUpdateManyInput>
    where?: SegmentsWhereInput
  }


  /**
   * Segments upsert
   */
  export type SegmentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * The filter to search for the Segments to update in case it exists.
    **/
    where: SegmentsWhereUniqueInput
    /**
     * In case the Segments found by the `where` argument doesn't exist, create a new Segments with this data.
    **/
    create: XOR<SegmentsCreateInput, SegmentsUncheckedCreateInput>
    /**
     * In case the Segments was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SegmentsUpdateInput, SegmentsUncheckedUpdateInput>
  }


  /**
   * Segments delete
   */
  export type SegmentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
    /**
     * Filter which Segments to delete.
    **/
    where: SegmentsWhereUniqueInput
  }


  /**
   * Segments deleteMany
   */
  export type SegmentsDeleteManyArgs = {
    where?: SegmentsWhereInput
  }


  /**
   * Segments without action
   */
  export type SegmentsArgs = {
    /**
     * Select specific fields to fetch from the Segments
    **/
    select?: SegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SegmentsInclude | null
  }



  /**
   * Model SubSegments
   */


  export type AggregateSubSegments = {
    count: SubSegmentsCountAggregateOutputType | null
    avg: SubSegmentsAvgAggregateOutputType | null
    sum: SubSegmentsSumAggregateOutputType | null
    min: SubSegmentsMinAggregateOutputType | null
    max: SubSegmentsMaxAggregateOutputType | null
  }

  export type SubSegmentsAvgAggregateOutputType = {
    id: number | null
    segId: number | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type SubSegmentsSumAggregateOutputType = {
    id: number | null
    segId: number | null
    lat: Decimal | null
    lon: Decimal | null
  }

  export type SubSegmentsMinAggregateOutputType = {
    id: number | null
    segId: number | null
    name: string | null
    lat: Decimal | null
    lon: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubSegmentsMaxAggregateOutputType = {
    id: number | null
    segId: number | null
    name: string | null
    lat: Decimal | null
    lon: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubSegmentsCountAggregateOutputType = {
    id: number
    segId: number
    name: number
    lat: number
    lon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubSegmentsAvgAggregateInputType = {
    id?: true
    segId?: true
    lat?: true
    lon?: true
  }

  export type SubSegmentsSumAggregateInputType = {
    id?: true
    segId?: true
    lat?: true
    lon?: true
  }

  export type SubSegmentsMinAggregateInputType = {
    id?: true
    segId?: true
    name?: true
    lat?: true
    lon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubSegmentsMaxAggregateInputType = {
    id?: true
    segId?: true
    name?: true
    lat?: true
    lon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubSegmentsCountAggregateInputType = {
    id?: true
    segId?: true
    name?: true
    lat?: true
    lon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubSegmentsAggregateArgs = {
    /**
     * Filter which SubSegments to aggregate.
    **/
    where?: SubSegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSegments to fetch.
    **/
    orderBy?: Enumerable<SubSegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SubSegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSegments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubSegments
    **/
    count?: true | SubSegmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SubSegmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SubSegmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SubSegmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SubSegmentsMaxAggregateInputType
  }

  export type GetSubSegmentsAggregateType<T extends SubSegmentsAggregateArgs> = {
    [P in keyof T & keyof AggregateSubSegments]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubSegments[P]>
      : GetScalarType<T[P], AggregateSubSegments[P]>
  }


    
    
  export type SubSegmentsGroupByArgs = {
    where?: SubSegmentsWhereInput
    orderBy?: Enumerable<SubSegmentsOrderByInput>
    by: Array<SubSegmentsScalarFieldEnum>
    having?: SubSegmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SubSegmentsCountAggregateInputType | true
    avg?: SubSegmentsAvgAggregateInputType
    sum?: SubSegmentsSumAggregateInputType
    min?: SubSegmentsMinAggregateInputType
    max?: SubSegmentsMaxAggregateInputType
  }


  export type SubSegmentsGroupByOutputType = {
    id: number
    segId: number
    name: string
    lat: Decimal | null
    lon: Decimal | null
    createdAt: Date
    updatedAt: Date | null
    count: SubSegmentsCountAggregateOutputType | null
    avg: SubSegmentsAvgAggregateOutputType | null
    sum: SubSegmentsSumAggregateOutputType | null
    min: SubSegmentsMinAggregateOutputType | null
    max: SubSegmentsMaxAggregateOutputType | null
  }

  type GetSubSegmentsGroupByPayload<T extends SubSegmentsGroupByArgs> = Promise<Array<
    PickArray<SubSegmentsGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SubSegmentsGroupByOutputType))]: GetScalarType<T[P], SubSegmentsGroupByOutputType[P]>
    }
  >>
    

  export type SubSegmentsSelect = {
    id?: boolean
    segId?: boolean
    name?: boolean
    lat?: boolean
    lon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    segRef?: boolean | SegmentsArgs
    homeSubSegments?: boolean | UserSegmentsFindManyArgs
    workSubSegments?: boolean | UserSegmentsFindManyArgs
    schoolSubSegments?: boolean | UserSegmentsFindManyArgs
    Idea?: boolean | IdeaFindManyArgs
    Proposal?: boolean | ProposalFindManyArgs
  }

  export type SubSegmentsInclude = {
    segRef?: boolean | SegmentsArgs
    homeSubSegments?: boolean | UserSegmentsFindManyArgs
    workSubSegments?: boolean | UserSegmentsFindManyArgs
    schoolSubSegments?: boolean | UserSegmentsFindManyArgs
    Idea?: boolean | IdeaFindManyArgs
    Proposal?: boolean | ProposalFindManyArgs
  }

  export type SubSegmentsGetPayload<
    S extends boolean | null | undefined | SubSegmentsArgs,
    U = keyof S
      > = S extends true
        ? SubSegments
    : S extends undefined
    ? never
    : S extends SubSegmentsArgs | SubSegmentsFindManyArgs
    ?'include' extends U
    ? SubSegments  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'segRef'
        ? SegmentsGetPayload<S['include'][P]> :
        P extends 'homeSubSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'workSubSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'schoolSubSegments'
        ? Array < UserSegmentsGetPayload<S['include'][P]>>  :
        P extends 'Idea'
        ? Array < IdeaGetPayload<S['include'][P]>>  :
        P extends 'Proposal'
        ? Array < ProposalGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SubSegments ?SubSegments [P]
  : 
          P extends 'segRef'
        ? SegmentsGetPayload<S['select'][P]> :
        P extends 'homeSubSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'workSubSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'schoolSubSegments'
        ? Array < UserSegmentsGetPayload<S['select'][P]>>  :
        P extends 'Idea'
        ? Array < IdeaGetPayload<S['select'][P]>>  :
        P extends 'Proposal'
        ? Array < ProposalGetPayload<S['select'][P]>>  : never
  } 
    : SubSegments
  : SubSegments


  type SubSegmentsCountArgs = Merge<
    Omit<SubSegmentsFindManyArgs, 'select' | 'include'> & {
      select?: SubSegmentsCountAggregateInputType | true
    }
  >

  export interface SubSegmentsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubSegments that matches the filter.
     * @param {SubSegmentsFindUniqueArgs} args - Arguments to find a SubSegments
     * @example
     * // Get one SubSegments
     * const subSegments = await prisma.subSegments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubSegmentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubSegmentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubSegments'> extends True ? CheckSelect<T, Prisma__SubSegmentsClient<SubSegments>, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T>>> : CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>

    /**
     * Find the first SubSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSegmentsFindFirstArgs} args - Arguments to find a SubSegments
     * @example
     * // Get one SubSegments
     * const subSegments = await prisma.subSegments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubSegmentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubSegmentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubSegments'> extends True ? CheckSelect<T, Prisma__SubSegmentsClient<SubSegments>, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T>>> : CheckSelect<T, Prisma__SubSegmentsClient<SubSegments | null >, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T> | null >>

    /**
     * Find zero or more SubSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSegmentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubSegments
     * const subSegments = await prisma.subSegments.findMany()
     * 
     * // Get first 10 SubSegments
     * const subSegments = await prisma.subSegments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subSegmentsWithIdOnly = await prisma.subSegments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubSegmentsFindManyArgs>(
      args?: SelectSubset<T, SubSegmentsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SubSegments>>, PrismaPromise<Array<SubSegmentsGetPayload<T>>>>

    /**
     * Create a SubSegments.
     * @param {SubSegmentsCreateArgs} args - Arguments to create a SubSegments.
     * @example
     * // Create one SubSegments
     * const SubSegments = await prisma.subSegments.create({
     *   data: {
     *     // ... data to create a SubSegments
     *   }
     * })
     * 
    **/
    create<T extends SubSegmentsCreateArgs>(
      args: SelectSubset<T, SubSegmentsCreateArgs>
    ): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments>, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T>>>

    /**
     * Create many SubSegments.
     *     @param {SubSegmentsCreateManyArgs} args - Arguments to create many SubSegments.
     *     @example
     *     // Create many SubSegments
     *     const subSegments = await prisma.subSegments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubSegmentsCreateManyArgs>(
      args?: SelectSubset<T, SubSegmentsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubSegments.
     * @param {SubSegmentsDeleteArgs} args - Arguments to delete one SubSegments.
     * @example
     * // Delete one SubSegments
     * const SubSegments = await prisma.subSegments.delete({
     *   where: {
     *     // ... filter to delete one SubSegments
     *   }
     * })
     * 
    **/
    delete<T extends SubSegmentsDeleteArgs>(
      args: SelectSubset<T, SubSegmentsDeleteArgs>
    ): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments>, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T>>>

    /**
     * Update one SubSegments.
     * @param {SubSegmentsUpdateArgs} args - Arguments to update one SubSegments.
     * @example
     * // Update one SubSegments
     * const subSegments = await prisma.subSegments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubSegmentsUpdateArgs>(
      args: SelectSubset<T, SubSegmentsUpdateArgs>
    ): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments>, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T>>>

    /**
     * Delete zero or more SubSegments.
     * @param {SubSegmentsDeleteManyArgs} args - Arguments to filter SubSegments to delete.
     * @example
     * // Delete a few SubSegments
     * const { count } = await prisma.subSegments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubSegmentsDeleteManyArgs>(
      args?: SelectSubset<T, SubSegmentsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSegmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubSegments
     * const subSegments = await prisma.subSegments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubSegmentsUpdateManyArgs>(
      args: SelectSubset<T, SubSegmentsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubSegments.
     * @param {SubSegmentsUpsertArgs} args - Arguments to update or create a SubSegments.
     * @example
     * // Update or create a SubSegments
     * const subSegments = await prisma.subSegments.upsert({
     *   create: {
     *     // ... data to create a SubSegments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubSegments we want to update
     *   }
     * })
    **/
    upsert<T extends SubSegmentsUpsertArgs>(
      args: SelectSubset<T, SubSegmentsUpsertArgs>
    ): CheckSelect<T, Prisma__SubSegmentsClient<SubSegments>, Prisma__SubSegmentsClient<SubSegmentsGetPayload<T>>>

    /**
     * Count the number of SubSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSegmentsCountArgs} args - Arguments to filter SubSegments to count.
     * @example
     * // Count the number of SubSegments
     * const count = await prisma.subSegments.count({
     *   where: {
     *     // ... the filter for the SubSegments we want to count
     *   }
     * })
    **/
    count<T extends SubSegmentsCountArgs>(
      args?: Subset<T, SubSegmentsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubSegmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSegmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubSegmentsAggregateArgs>(args: Subset<T, SubSegmentsAggregateArgs>): PrismaPromise<GetSubSegmentsAggregateType<T>>

    /**
     * Group by SubSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubSegmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubSegmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubSegmentsGroupByArgs['orderBy'] }
        : { orderBy?: SubSegmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubSegmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubSegmentsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubSegments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubSegmentsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    segRef<T extends SegmentsArgs = {}>(args?: Subset<T, SegmentsArgs>): CheckSelect<T, Prisma__SegmentsClient<Segments | null >, Prisma__SegmentsClient<SegmentsGetPayload<T> | null >>;

    homeSubSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    workSubSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    schoolSubSegments<T extends UserSegmentsFindManyArgs = {}>(args?: Subset<T, UserSegmentsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UserSegments>>, PrismaPromise<Array<UserSegmentsGetPayload<T>>>>;

    Idea<T extends IdeaFindManyArgs = {}>(args?: Subset<T, IdeaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Idea>>, PrismaPromise<Array<IdeaGetPayload<T>>>>;

    Proposal<T extends ProposalFindManyArgs = {}>(args?: Subset<T, ProposalFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Proposal>>, PrismaPromise<Array<ProposalGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SubSegments findUnique
   */
  export type SubSegmentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * Throw an Error if a SubSegments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubSegments to fetch.
    **/
    where: SubSegmentsWhereUniqueInput
  }


  /**
   * SubSegments findFirst
   */
  export type SubSegmentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * Throw an Error if a SubSegments can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SubSegments to fetch.
    **/
    where?: SubSegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSegments to fetch.
    **/
    orderBy?: Enumerable<SubSegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubSegments.
    **/
    cursor?: SubSegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSegments.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubSegments.
    **/
    distinct?: Enumerable<SubSegmentsScalarFieldEnum>
  }


  /**
   * SubSegments findMany
   */
  export type SubSegmentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * Filter, which SubSegments to fetch.
    **/
    where?: SubSegmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubSegments to fetch.
    **/
    orderBy?: Enumerable<SubSegmentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubSegments.
    **/
    cursor?: SubSegmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubSegments from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubSegments.
    **/
    skip?: number
    distinct?: Enumerable<SubSegmentsScalarFieldEnum>
  }


  /**
   * SubSegments create
   */
  export type SubSegmentsCreateArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * The data needed to create a SubSegments.
    **/
    data: XOR<SubSegmentsCreateInput, SubSegmentsUncheckedCreateInput>
  }


  /**
   * SubSegments createMany
   */
  export type SubSegmentsCreateManyArgs = {
    data: Enumerable<SubSegmentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubSegments update
   */
  export type SubSegmentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * The data needed to update a SubSegments.
    **/
    data: XOR<SubSegmentsUpdateInput, SubSegmentsUncheckedUpdateInput>
    /**
     * Choose, which SubSegments to update.
    **/
    where: SubSegmentsWhereUniqueInput
  }


  /**
   * SubSegments updateMany
   */
  export type SubSegmentsUpdateManyArgs = {
    data: XOR<SubSegmentsUpdateManyMutationInput, SubSegmentsUncheckedUpdateManyInput>
    where?: SubSegmentsWhereInput
  }


  /**
   * SubSegments upsert
   */
  export type SubSegmentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * The filter to search for the SubSegments to update in case it exists.
    **/
    where: SubSegmentsWhereUniqueInput
    /**
     * In case the SubSegments found by the `where` argument doesn't exist, create a new SubSegments with this data.
    **/
    create: XOR<SubSegmentsCreateInput, SubSegmentsUncheckedCreateInput>
    /**
     * In case the SubSegments was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SubSegmentsUpdateInput, SubSegmentsUncheckedUpdateInput>
  }


  /**
   * SubSegments delete
   */
  export type SubSegmentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
    /**
     * Filter which SubSegments to delete.
    **/
    where: SubSegmentsWhereUniqueInput
  }


  /**
   * SubSegments deleteMany
   */
  export type SubSegmentsDeleteManyArgs = {
    where?: SubSegmentsWhereInput
  }


  /**
   * SubSegments without action
   */
  export type SubSegmentsArgs = {
    /**
     * Select specific fields to fetch from the SubSegments
    **/
    select?: SubSegmentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SubSegmentsInclude | null
  }



  /**
   * Model segmentRequest
   */


  export type AggregateSegmentRequest = {
    count: SegmentRequestCountAggregateOutputType | null
    avg: SegmentRequestAvgAggregateOutputType | null
    sum: SegmentRequestSumAggregateOutputType | null
    min: SegmentRequestMinAggregateOutputType | null
    max: SegmentRequestMaxAggregateOutputType | null
  }

  export type SegmentRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type SegmentRequestSumAggregateOutputType = {
    id: number | null
  }

  export type SegmentRequestMinAggregateOutputType = {
    id: number | null
    createAt: Date | null
    userId: string | null
    country: string | null
    province: string | null
    segmentName: string | null
    subSegmentName: string | null
  }

  export type SegmentRequestMaxAggregateOutputType = {
    id: number | null
    createAt: Date | null
    userId: string | null
    country: string | null
    province: string | null
    segmentName: string | null
    subSegmentName: string | null
  }

  export type SegmentRequestCountAggregateOutputType = {
    id: number
    createAt: number
    userId: number
    country: number
    province: number
    segmentName: number
    subSegmentName: number
    _all: number
  }


  export type SegmentRequestAvgAggregateInputType = {
    id?: true
  }

  export type SegmentRequestSumAggregateInputType = {
    id?: true
  }

  export type SegmentRequestMinAggregateInputType = {
    id?: true
    createAt?: true
    userId?: true
    country?: true
    province?: true
    segmentName?: true
    subSegmentName?: true
  }

  export type SegmentRequestMaxAggregateInputType = {
    id?: true
    createAt?: true
    userId?: true
    country?: true
    province?: true
    segmentName?: true
    subSegmentName?: true
  }

  export type SegmentRequestCountAggregateInputType = {
    id?: true
    createAt?: true
    userId?: true
    country?: true
    province?: true
    segmentName?: true
    subSegmentName?: true
    _all?: true
  }

  export type SegmentRequestAggregateArgs = {
    /**
     * Filter which segmentRequest to aggregate.
    **/
    where?: segmentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of segmentRequests to fetch.
    **/
    orderBy?: Enumerable<segmentRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: segmentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` segmentRequests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` segmentRequests.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned segmentRequests
    **/
    count?: true | SegmentRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SegmentRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SegmentRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SegmentRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SegmentRequestMaxAggregateInputType
  }

  export type GetSegmentRequestAggregateType<T extends SegmentRequestAggregateArgs> = {
    [P in keyof T & keyof AggregateSegmentRequest]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegmentRequest[P]>
      : GetScalarType<T[P], AggregateSegmentRequest[P]>
  }


    
    
  export type SegmentRequestGroupByArgs = {
    where?: segmentRequestWhereInput
    orderBy?: Enumerable<segmentRequestOrderByInput>
    by: Array<SegmentRequestScalarFieldEnum>
    having?: segmentRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SegmentRequestCountAggregateInputType | true
    avg?: SegmentRequestAvgAggregateInputType
    sum?: SegmentRequestSumAggregateInputType
    min?: SegmentRequestMinAggregateInputType
    max?: SegmentRequestMaxAggregateInputType
  }


  export type SegmentRequestGroupByOutputType = {
    id: number
    createAt: Date
    userId: string
    country: string
    province: string
    segmentName: string
    subSegmentName: string | null
    count: SegmentRequestCountAggregateOutputType | null
    avg: SegmentRequestAvgAggregateOutputType | null
    sum: SegmentRequestSumAggregateOutputType | null
    min: SegmentRequestMinAggregateOutputType | null
    max: SegmentRequestMaxAggregateOutputType | null
  }

  type GetSegmentRequestGroupByPayload<T extends SegmentRequestGroupByArgs> = Promise<Array<
    PickArray<SegmentRequestGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SegmentRequestGroupByOutputType))]: GetScalarType<T[P], SegmentRequestGroupByOutputType[P]>
    }
  >>
    

  export type segmentRequestSelect = {
    id?: boolean
    createAt?: boolean
    userId?: boolean
    country?: boolean
    province?: boolean
    segmentName?: boolean
    subSegmentName?: boolean
    requester?: boolean | UserArgs
  }

  export type segmentRequestInclude = {
    requester?: boolean | UserArgs
  }

  export type segmentRequestGetPayload<
    S extends boolean | null | undefined | segmentRequestArgs,
    U = keyof S
      > = S extends true
        ? segmentRequest
    : S extends undefined
    ? never
    : S extends segmentRequestArgs | segmentRequestFindManyArgs
    ?'include' extends U
    ? segmentRequest  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'requester'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof segmentRequest ?segmentRequest [P]
  : 
          P extends 'requester'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : segmentRequest
  : segmentRequest


  type segmentRequestCountArgs = Merge<
    Omit<segmentRequestFindManyArgs, 'select' | 'include'> & {
      select?: SegmentRequestCountAggregateInputType | true
    }
  >

  export interface segmentRequestDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SegmentRequest that matches the filter.
     * @param {segmentRequestFindUniqueArgs} args - Arguments to find a SegmentRequest
     * @example
     * // Get one SegmentRequest
     * const segmentRequest = await prisma.segmentRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends segmentRequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, segmentRequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'segmentRequest'> extends True ? CheckSelect<T, Prisma__segmentRequestClient<segmentRequest>, Prisma__segmentRequestClient<segmentRequestGetPayload<T>>> : CheckSelect<T, Prisma__segmentRequestClient<segmentRequest | null >, Prisma__segmentRequestClient<segmentRequestGetPayload<T> | null >>

    /**
     * Find the first SegmentRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {segmentRequestFindFirstArgs} args - Arguments to find a SegmentRequest
     * @example
     * // Get one SegmentRequest
     * const segmentRequest = await prisma.segmentRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends segmentRequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, segmentRequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'segmentRequest'> extends True ? CheckSelect<T, Prisma__segmentRequestClient<segmentRequest>, Prisma__segmentRequestClient<segmentRequestGetPayload<T>>> : CheckSelect<T, Prisma__segmentRequestClient<segmentRequest | null >, Prisma__segmentRequestClient<segmentRequestGetPayload<T> | null >>

    /**
     * Find zero or more SegmentRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {segmentRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SegmentRequests
     * const segmentRequests = await prisma.segmentRequest.findMany()
     * 
     * // Get first 10 SegmentRequests
     * const segmentRequests = await prisma.segmentRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentRequestWithIdOnly = await prisma.segmentRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends segmentRequestFindManyArgs>(
      args?: SelectSubset<T, segmentRequestFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<segmentRequest>>, PrismaPromise<Array<segmentRequestGetPayload<T>>>>

    /**
     * Create a SegmentRequest.
     * @param {segmentRequestCreateArgs} args - Arguments to create a SegmentRequest.
     * @example
     * // Create one SegmentRequest
     * const SegmentRequest = await prisma.segmentRequest.create({
     *   data: {
     *     // ... data to create a SegmentRequest
     *   }
     * })
     * 
    **/
    create<T extends segmentRequestCreateArgs>(
      args: SelectSubset<T, segmentRequestCreateArgs>
    ): CheckSelect<T, Prisma__segmentRequestClient<segmentRequest>, Prisma__segmentRequestClient<segmentRequestGetPayload<T>>>

    /**
     * Create many SegmentRequests.
     *     @param {segmentRequestCreateManyArgs} args - Arguments to create many SegmentRequests.
     *     @example
     *     // Create many SegmentRequests
     *     const segmentRequest = await prisma.segmentRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends segmentRequestCreateManyArgs>(
      args?: SelectSubset<T, segmentRequestCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SegmentRequest.
     * @param {segmentRequestDeleteArgs} args - Arguments to delete one SegmentRequest.
     * @example
     * // Delete one SegmentRequest
     * const SegmentRequest = await prisma.segmentRequest.delete({
     *   where: {
     *     // ... filter to delete one SegmentRequest
     *   }
     * })
     * 
    **/
    delete<T extends segmentRequestDeleteArgs>(
      args: SelectSubset<T, segmentRequestDeleteArgs>
    ): CheckSelect<T, Prisma__segmentRequestClient<segmentRequest>, Prisma__segmentRequestClient<segmentRequestGetPayload<T>>>

    /**
     * Update one SegmentRequest.
     * @param {segmentRequestUpdateArgs} args - Arguments to update one SegmentRequest.
     * @example
     * // Update one SegmentRequest
     * const segmentRequest = await prisma.segmentRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends segmentRequestUpdateArgs>(
      args: SelectSubset<T, segmentRequestUpdateArgs>
    ): CheckSelect<T, Prisma__segmentRequestClient<segmentRequest>, Prisma__segmentRequestClient<segmentRequestGetPayload<T>>>

    /**
     * Delete zero or more SegmentRequests.
     * @param {segmentRequestDeleteManyArgs} args - Arguments to filter SegmentRequests to delete.
     * @example
     * // Delete a few SegmentRequests
     * const { count } = await prisma.segmentRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends segmentRequestDeleteManyArgs>(
      args?: SelectSubset<T, segmentRequestDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SegmentRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {segmentRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SegmentRequests
     * const segmentRequest = await prisma.segmentRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends segmentRequestUpdateManyArgs>(
      args: SelectSubset<T, segmentRequestUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SegmentRequest.
     * @param {segmentRequestUpsertArgs} args - Arguments to update or create a SegmentRequest.
     * @example
     * // Update or create a SegmentRequest
     * const segmentRequest = await prisma.segmentRequest.upsert({
     *   create: {
     *     // ... data to create a SegmentRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SegmentRequest we want to update
     *   }
     * })
    **/
    upsert<T extends segmentRequestUpsertArgs>(
      args: SelectSubset<T, segmentRequestUpsertArgs>
    ): CheckSelect<T, Prisma__segmentRequestClient<segmentRequest>, Prisma__segmentRequestClient<segmentRequestGetPayload<T>>>

    /**
     * Count the number of SegmentRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {segmentRequestCountArgs} args - Arguments to filter SegmentRequests to count.
     * @example
     * // Count the number of SegmentRequests
     * const count = await prisma.segmentRequest.count({
     *   where: {
     *     // ... the filter for the SegmentRequests we want to count
     *   }
     * })
    **/
    count<T extends segmentRequestCountArgs>(
      args?: Subset<T, segmentRequestCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SegmentRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentRequestAggregateArgs>(args: Subset<T, SegmentRequestAggregateArgs>): PrismaPromise<GetSegmentRequestAggregateType<T>>

    /**
     * Group by SegmentRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentRequestGroupByArgs['orderBy'] }
        : { orderBy?: SegmentRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentRequestGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for segmentRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__segmentRequestClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    requester<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * segmentRequest findUnique
   */
  export type segmentRequestFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * Throw an Error if a segmentRequest can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which segmentRequest to fetch.
    **/
    where: segmentRequestWhereUniqueInput
  }


  /**
   * segmentRequest findFirst
   */
  export type segmentRequestFindFirstArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * Throw an Error if a segmentRequest can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which segmentRequest to fetch.
    **/
    where?: segmentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of segmentRequests to fetch.
    **/
    orderBy?: Enumerable<segmentRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for segmentRequests.
    **/
    cursor?: segmentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` segmentRequests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` segmentRequests.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of segmentRequests.
    **/
    distinct?: Enumerable<SegmentRequestScalarFieldEnum>
  }


  /**
   * segmentRequest findMany
   */
  export type segmentRequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * Filter, which segmentRequests to fetch.
    **/
    where?: segmentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of segmentRequests to fetch.
    **/
    orderBy?: Enumerable<segmentRequestOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing segmentRequests.
    **/
    cursor?: segmentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` segmentRequests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` segmentRequests.
    **/
    skip?: number
    distinct?: Enumerable<SegmentRequestScalarFieldEnum>
  }


  /**
   * segmentRequest create
   */
  export type segmentRequestCreateArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * The data needed to create a segmentRequest.
    **/
    data: XOR<segmentRequestCreateInput, segmentRequestUncheckedCreateInput>
  }


  /**
   * segmentRequest createMany
   */
  export type segmentRequestCreateManyArgs = {
    data: Enumerable<segmentRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * segmentRequest update
   */
  export type segmentRequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * The data needed to update a segmentRequest.
    **/
    data: XOR<segmentRequestUpdateInput, segmentRequestUncheckedUpdateInput>
    /**
     * Choose, which segmentRequest to update.
    **/
    where: segmentRequestWhereUniqueInput
  }


  /**
   * segmentRequest updateMany
   */
  export type segmentRequestUpdateManyArgs = {
    data: XOR<segmentRequestUpdateManyMutationInput, segmentRequestUncheckedUpdateManyInput>
    where?: segmentRequestWhereInput
  }


  /**
   * segmentRequest upsert
   */
  export type segmentRequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * The filter to search for the segmentRequest to update in case it exists.
    **/
    where: segmentRequestWhereUniqueInput
    /**
     * In case the segmentRequest found by the `where` argument doesn't exist, create a new segmentRequest with this data.
    **/
    create: XOR<segmentRequestCreateInput, segmentRequestUncheckedCreateInput>
    /**
     * In case the segmentRequest was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<segmentRequestUpdateInput, segmentRequestUncheckedUpdateInput>
  }


  /**
   * segmentRequest delete
   */
  export type segmentRequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
    /**
     * Filter which segmentRequest to delete.
    **/
    where: segmentRequestWhereUniqueInput
  }


  /**
   * segmentRequest deleteMany
   */
  export type segmentRequestDeleteManyArgs = {
    where?: segmentRequestWhereInput
  }


  /**
   * segmentRequest without action
   */
  export type segmentRequestArgs = {
    /**
     * Select specific fields to fetch from the segmentRequest
    **/
    select?: segmentRequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: segmentRequestInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ReportScalarFieldEnum: {
    id: 'id',
    email: 'email',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const UserGeoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lat: 'lat',
    lon: 'lon',
    work_lat: 'work_lat',
    work_lon: 'work_lon',
    school_lat: 'school_lat',
    school_lon: 'school_lon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserGeoScalarFieldEnum = (typeof UserGeoScalarFieldEnum)[keyof typeof UserGeoScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    streetAddress: 'streetAddress',
    streetAddress2: 'streetAddress2',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    userType: 'userType',
    email: 'email',
    password: 'password',
    fname: 'fname',
    lname: 'lname',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    imagePath: 'imagePath',
    passCode: 'passCode',
    banned: 'banned'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSegmentsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    homeSuperSegId: 'homeSuperSegId',
    homeSuperSegName: 'homeSuperSegName',
    workSuperSegId: 'workSuperSegId',
    workSuperSegName: 'workSuperSegName',
    schoolSuperSegId: 'schoolSuperSegId',
    schoolSuperSegName: 'schoolSuperSegName',
    homeSegmentId: 'homeSegmentId',
    homeSegmentName: 'homeSegmentName',
    workSegmentId: 'workSegmentId',
    workSegmentName: 'workSegmentName',
    schoolSegmentId: 'schoolSegmentId',
    schoolSegmentName: 'schoolSegmentName',
    homeSubSegmentId: 'homeSubSegmentId',
    homeSubSegmentName: 'homeSubSegmentName',
    workSubSegmentId: 'workSubSegmentId',
    workSubSegmentName: 'workSubSegmentName',
    schoolSubSegmentId: 'schoolSubSegmentId',
    schoolSubSegmentName: 'schoolSubSegmentName'
  };

  export type UserSegmentsScalarFieldEnum = (typeof UserSegmentsScalarFieldEnum)[keyof typeof UserSegmentsScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const GeoScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    proposalId: 'proposalId',
    lat: 'lat',
    lon: 'lon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GeoScalarFieldEnum = (typeof GeoScalarFieldEnum)[keyof typeof GeoScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    proposalId: 'proposalId',
    streetAddress: 'streetAddress',
    streetAddress2: 'streetAddress2',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const IdeaScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    championId: 'championId',
    categoryId: 'categoryId',
    superSegmentId: 'superSegmentId',
    segmentId: 'segmentId',
    subSegmentId: 'subSegmentId',
    title: 'title',
    description: 'description',
    userType: 'userType',
    communityImpact: 'communityImpact',
    natureImpact: 'natureImpact',
    artsImpact: 'artsImpact',
    energyImpact: 'energyImpact',
    manufacturingImpact: 'manufacturingImpact',
    state: 'state',
    active: 'active',
    imagePath: 'imagePath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdeaScalarFieldEnum = (typeof IdeaScalarFieldEnum)[keyof typeof IdeaScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    championId: 'championId',
    categoryId: 'categoryId',
    superSegmentId: 'superSegmentId',
    segmentId: 'segmentId',
    subSegmentId: 'subSegmentId',
    title: 'title',
    description: 'description',
    userType: 'userType',
    communityImpact: 'communityImpact',
    natureImpact: 'natureImpact',
    artsImpact: 'artsImpact',
    energyImpact: 'energyImpact',
    manufacturingImpact: 'manufacturingImpact',
    state: 'state',
    active: 'active',
    imagePath: 'imagePath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    proposalId: 'proposalId',
    authorId: 'authorId',
    rating: 'rating',
    ratingExplanation: 'ratingExplanation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    proposalId: 'proposalId',
    authorId: 'authorId',
    userSegId: 'userSegId',
    superSegmentId: 'superSegmentId',
    segmentId: 'segmentId',
    subSegmentId: 'subSegmentId',
    content: 'content',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const UserCommentLikesScalarFieldEnum: {
    id: 'id',
    ideaCommentId: 'ideaCommentId',
    authorId: 'authorId'
  };

  export type UserCommentLikesScalarFieldEnum = (typeof UserCommentLikesScalarFieldEnum)[keyof typeof UserCommentLikesScalarFieldEnum]


  export const UserCommentDislikesScalarFieldEnum: {
    id: 'id',
    ideaCommentId: 'ideaCommentId',
    authorId: 'authorId'
  };

  export type UserCommentDislikesScalarFieldEnum = (typeof UserCommentDislikesScalarFieldEnum)[keyof typeof UserCommentDislikesScalarFieldEnum]


  export const AdvertisementsScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    createAt: 'createAt',
    updateAt: 'updateAt',
    adTitle: 'adTitle',
    adType: 'adType',
    duration: 'duration',
    adPosition: 'adPosition',
    imagePath: 'imagePath',
    externalLink: 'externalLink',
    published: 'published'
  };

  export type AdvertisementsScalarFieldEnum = (typeof AdvertisementsScalarFieldEnum)[keyof typeof AdvertisementsScalarFieldEnum]


  export const SuperSegmentScalarFieldEnum: {
    superSegId: 'superSegId',
    name: 'name',
    country: 'country',
    province: 'province',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperSegmentScalarFieldEnum = (typeof SuperSegmentScalarFieldEnum)[keyof typeof SuperSegmentScalarFieldEnum]


  export const SegmentsScalarFieldEnum: {
    segId: 'segId',
    superSegId: 'superSegId',
    country: 'country',
    province: 'province',
    name: 'name',
    superSegName: 'superSegName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SegmentsScalarFieldEnum = (typeof SegmentsScalarFieldEnum)[keyof typeof SegmentsScalarFieldEnum]


  export const SubSegmentsScalarFieldEnum: {
    id: 'id',
    segId: 'segId',
    name: 'name',
    lat: 'lat',
    lon: 'lon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubSegmentsScalarFieldEnum = (typeof SubSegmentsScalarFieldEnum)[keyof typeof SubSegmentsScalarFieldEnum]


  export const SegmentRequestScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    userId: 'userId',
    country: 'country',
    province: 'province',
    segmentName: 'segmentName',
    subSegmentName: 'subSegmentName'
  };

  export type SegmentRequestScalarFieldEnum = (typeof SegmentRequestScalarFieldEnum)[keyof typeof SegmentRequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type ReportWhereInput = {
    AND?: Enumerable<ReportWhereInput>
    OR?: Enumerable<ReportWhereInput>
    NOT?: Enumerable<ReportWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ReportOrderByInput = {
    id?: SortOrder
    email?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportWhereUniqueInput = {
    id?: number
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserGeoWhereInput = {
    AND?: Enumerable<UserGeoWhereInput>
    OR?: Enumerable<UserGeoWhereInput>
    NOT?: Enumerable<UserGeoWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    lat?: DecimalNullableFilter | Decimal | number | string | null
    lon?: DecimalNullableFilter | Decimal | number | string | null
    work_lat?: DecimalNullableFilter | Decimal | number | string | null
    work_lon?: DecimalNullableFilter | Decimal | number | string | null
    school_lat?: DecimalNullableFilter | Decimal | number | string | null
    school_lon?: DecimalNullableFilter | Decimal | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserGeoOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    work_lat?: SortOrder
    work_lon?: SortOrder
    school_lat?: SortOrder
    school_lon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserGeoWhereUniqueInput = {
    id?: number
  }

  export type UserGeoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserGeoScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserGeoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserGeoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    lat?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    lon?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    work_lat?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    work_lon?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    school_lat?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    school_lon?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserAddressWhereInput = {
    AND?: Enumerable<UserAddressWhereInput>
    OR?: Enumerable<UserAddressWhereInput>
    NOT?: Enumerable<UserAddressWhereInput>
    id?: IntFilter | number
    userId?: StringFilter | string
    streetAddress?: StringNullableFilter | string | null
    streetAddress2?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    postalCode?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    streetAddress?: SortOrder
    streetAddress2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAddressWhereUniqueInput = {
    id?: number
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    streetAddress?: StringNullableWithAggregatesFilter | string | null
    streetAddress2?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    postalCode?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    userType?: EnumUserTypeFilter | UserType
    email?: StringFilter | string
    password?: StringFilter | string
    fname?: StringNullableFilter | string | null
    lname?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    imagePath?: StringNullableFilter | string | null
    passCode?: StringNullableFilter | string | null
    banned?: BoolFilter | boolean
    address?: XOR<UserAddressRelationFilter, UserAddressWhereInput> | null
    geo?: XOR<UserGeoRelationFilter, UserGeoWhereInput> | null
    ideas?: IdeaListRelationFilter
    proposals?: ProposalListRelationFilter
    championedProposals?: ProposalListRelationFilter
    championedIdeas?: IdeaListRelationFilter
    ideaRatings?: RatingListRelationFilter
    ideaComments?: CommentListRelationFilter
    ideaCommentLikes?: UserCommentLikesListRelationFilter
    ideaCommentDislikes?: UserCommentDislikesListRelationFilter
    Advertisements?: AdvertisementsListRelationFilter
    segmentRequest?: SegmentRequestListRelationFilter
    userSegments?: XOR<UserSegmentsRelationFilter, UserSegmentsWhereInput> | null
  }

  export type UserOrderByInput = {
    id?: SortOrder
    userType?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fname?: SortOrder
    lname?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    imagePath?: SortOrder
    passCode?: SortOrder
    banned?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userType?: EnumUserTypeWithAggregatesFilter | UserType
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    fname?: StringNullableWithAggregatesFilter | string | null
    lname?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    imagePath?: StringNullableWithAggregatesFilter | string | null
    passCode?: StringNullableWithAggregatesFilter | string | null
    banned?: BoolWithAggregatesFilter | boolean
  }

  export type UserSegmentsWhereInput = {
    AND?: Enumerable<UserSegmentsWhereInput>
    OR?: Enumerable<UserSegmentsWhereInput>
    NOT?: Enumerable<UserSegmentsWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    homeSuperSegId?: IntNullableFilter | number | null
    homeSuperSegName?: StringNullableFilter | string | null
    workSuperSegId?: IntNullableFilter | number | null
    workSuperSegName?: StringNullableFilter | string | null
    schoolSuperSegId?: IntNullableFilter | number | null
    schoolSuperSegName?: StringNullableFilter | string | null
    homeSegmentId?: IntNullableFilter | number | null
    homeSegmentName?: StringNullableFilter | string | null
    workSegmentId?: IntNullableFilter | number | null
    workSegmentName?: StringNullableFilter | string | null
    schoolSegmentId?: IntNullableFilter | number | null
    schoolSegmentName?: StringNullableFilter | string | null
    homeSubSegmentId?: IntNullableFilter | number | null
    homeSubSegmentName?: StringNullableFilter | string | null
    workSubSegmentId?: IntNullableFilter | number | null
    workSubSegmentName?: StringNullableFilter | string | null
    schoolSubSegmentId?: IntNullableFilter | number | null
    schoolSubSegmentName?: StringNullableFilter | string | null
    homeSuperSeg?: XOR<SuperSegmentRelationFilter, SuperSegmentWhereInput> | null
    workSuperSeg?: XOR<SuperSegmentRelationFilter, SuperSegmentWhereInput> | null
    schoolSuperSeg?: XOR<SuperSegmentRelationFilter, SuperSegmentWhereInput> | null
    homeSegment?: XOR<SegmentsRelationFilter, SegmentsWhereInput> | null
    workSegment?: XOR<SegmentsRelationFilter, SegmentsWhereInput> | null
    schoolSegment?: XOR<SegmentsRelationFilter, SegmentsWhereInput> | null
    homeSubSegment?: XOR<SubSegmentsRelationFilter, SubSegmentsWhereInput> | null
    workSubSegment?: XOR<SubSegmentsRelationFilter, SubSegmentsWhereInput> | null
    schoolSubSegment?: XOR<SubSegmentsRelationFilter, SubSegmentsWhereInput> | null
    IdeaComment?: CommentListRelationFilter
  }

  export type UserSegmentsOrderByInput = {
    id?: SortOrder
    userId?: SortOrder
    homeSuperSegId?: SortOrder
    homeSuperSegName?: SortOrder
    workSuperSegId?: SortOrder
    workSuperSegName?: SortOrder
    schoolSuperSegId?: SortOrder
    schoolSuperSegName?: SortOrder
    homeSegmentId?: SortOrder
    homeSegmentName?: SortOrder
    workSegmentId?: SortOrder
    workSegmentName?: SortOrder
    schoolSegmentId?: SortOrder
    schoolSegmentName?: SortOrder
    homeSubSegmentId?: SortOrder
    homeSubSegmentName?: SortOrder
    workSubSegmentId?: SortOrder
    workSubSegmentName?: SortOrder
    schoolSubSegmentId?: SortOrder
    schoolSubSegmentName?: SortOrder
  }

  export type UserSegmentsWhereUniqueInput = {
    id?: string
  }

  export type UserSegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserSegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserSegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserSegmentsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    homeSuperSegId?: IntNullableWithAggregatesFilter | number | null
    homeSuperSegName?: StringNullableWithAggregatesFilter | string | null
    workSuperSegId?: IntNullableWithAggregatesFilter | number | null
    workSuperSegName?: StringNullableWithAggregatesFilter | string | null
    schoolSuperSegId?: IntNullableWithAggregatesFilter | number | null
    schoolSuperSegName?: StringNullableWithAggregatesFilter | string | null
    homeSegmentId?: IntNullableWithAggregatesFilter | number | null
    homeSegmentName?: StringNullableWithAggregatesFilter | string | null
    workSegmentId?: IntNullableWithAggregatesFilter | number | null
    workSegmentName?: StringNullableWithAggregatesFilter | string | null
    schoolSegmentId?: IntNullableWithAggregatesFilter | number | null
    schoolSegmentName?: StringNullableWithAggregatesFilter | string | null
    homeSubSegmentId?: IntNullableWithAggregatesFilter | number | null
    homeSubSegmentName?: StringNullableWithAggregatesFilter | string | null
    workSubSegmentId?: IntNullableWithAggregatesFilter | number | null
    workSubSegmentName?: StringNullableWithAggregatesFilter | string | null
    schoolSubSegmentId?: IntNullableWithAggregatesFilter | number | null
    schoolSubSegmentName?: StringNullableWithAggregatesFilter | string | null
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    ideas?: IdeaListRelationFilter
    proposals?: ProposalListRelationFilter
  }

  export type CategoryOrderByInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryWhereUniqueInput = {
    id?: number
    title?: string
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GeoWhereInput = {
    AND?: Enumerable<GeoWhereInput>
    OR?: Enumerable<GeoWhereInput>
    NOT?: Enumerable<GeoWhereInput>
    id?: IntFilter | number
    ideaId?: IntNullableFilter | number | null
    proposalId?: IntNullableFilter | number | null
    lat?: DecimalNullableFilter | Decimal | number | string | null
    lon?: DecimalNullableFilter | Decimal | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    idea?: XOR<IdeaRelationFilter, IdeaWhereInput> | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput> | null
  }

  export type GeoOrderByInput = {
    id?: SortOrder
    ideaId?: SortOrder
    proposalId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeoWhereUniqueInput = {
    id?: number
  }

  export type GeoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GeoScalarWhereWithAggregatesInput>
    OR?: Enumerable<GeoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GeoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaId?: IntNullableWithAggregatesFilter | number | null
    proposalId?: IntNullableWithAggregatesFilter | number | null
    lat?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    lon?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: IntFilter | number
    ideaId?: IntNullableFilter | number | null
    proposalId?: IntNullableFilter | number | null
    streetAddress?: StringNullableFilter | string | null
    streetAddress2?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    postalCode?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    idea?: XOR<IdeaRelationFilter, IdeaWhereInput> | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput> | null
  }

  export type AddressOrderByInput = {
    id?: SortOrder
    ideaId?: SortOrder
    proposalId?: SortOrder
    streetAddress?: SortOrder
    streetAddress2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    id?: number
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaId?: IntNullableWithAggregatesFilter | number | null
    proposalId?: IntNullableWithAggregatesFilter | number | null
    streetAddress?: StringNullableWithAggregatesFilter | string | null
    streetAddress2?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    postalCode?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type IdeaWhereInput = {
    AND?: Enumerable<IdeaWhereInput>
    OR?: Enumerable<IdeaWhereInput>
    NOT?: Enumerable<IdeaWhereInput>
    id?: IntFilter | number
    authorId?: StringFilter | string
    championId?: StringNullableFilter | string | null
    categoryId?: IntFilter | number
    superSegmentId?: IntFilter | number
    segmentId?: IntNullableFilter | number | null
    subSegmentId?: IntNullableFilter | number | null
    title?: StringFilter | string
    description?: StringFilter | string
    userType?: StringFilter | string
    communityImpact?: StringNullableFilter | string | null
    natureImpact?: StringNullableFilter | string | null
    artsImpact?: StringNullableFilter | string | null
    energyImpact?: StringNullableFilter | string | null
    manufacturingImpact?: StringNullableFilter | string | null
    state?: EnumIdeaStateFilter | IdeaState
    active?: BoolFilter | boolean
    imagePath?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    comments?: CommentListRelationFilter
    ratings?: RatingListRelationFilter
    projectInfo?: XOR<ProjectRelationFilter, ProjectWhereInput> | null
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
    geo?: XOR<GeoRelationFilter, GeoWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    champion?: XOR<UserRelationFilter, UserWhereInput> | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    superSegment?: XOR<SuperSegmentRelationFilter, SuperSegmentWhereInput>
    segment?: XOR<SegmentsRelationFilter, SegmentsWhereInput> | null
    subSegment?: XOR<SubSegmentsRelationFilter, SubSegmentsWhereInput> | null
  }

  export type IdeaOrderByInput = {
    id?: SortOrder
    authorId?: SortOrder
    championId?: SortOrder
    categoryId?: SortOrder
    superSegmentId?: SortOrder
    segmentId?: SortOrder
    subSegmentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userType?: SortOrder
    communityImpact?: SortOrder
    natureImpact?: SortOrder
    artsImpact?: SortOrder
    energyImpact?: SortOrder
    manufacturingImpact?: SortOrder
    state?: SortOrder
    active?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaWhereUniqueInput = {
    id?: number
  }

  export type IdeaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IdeaScalarWhereWithAggregatesInput>
    OR?: Enumerable<IdeaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IdeaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    authorId?: StringWithAggregatesFilter | string
    championId?: StringNullableWithAggregatesFilter | string | null
    categoryId?: IntWithAggregatesFilter | number
    superSegmentId?: IntWithAggregatesFilter | number
    segmentId?: IntNullableWithAggregatesFilter | number | null
    subSegmentId?: IntNullableWithAggregatesFilter | number | null
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    userType?: StringWithAggregatesFilter | string
    communityImpact?: StringNullableWithAggregatesFilter | string | null
    natureImpact?: StringNullableWithAggregatesFilter | string | null
    artsImpact?: StringNullableWithAggregatesFilter | string | null
    energyImpact?: StringNullableWithAggregatesFilter | string | null
    manufacturingImpact?: StringNullableWithAggregatesFilter | string | null
    state?: EnumIdeaStateWithAggregatesFilter | IdeaState
    active?: BoolWithAggregatesFilter | boolean
    imagePath?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProposalWhereInput = {
    AND?: Enumerable<ProposalWhereInput>
    OR?: Enumerable<ProposalWhereInput>
    NOT?: Enumerable<ProposalWhereInput>
    id?: IntFilter | number
    authorId?: StringFilter | string
    championId?: StringNullableFilter | string | null
    categoryId?: IntFilter | number
    superSegmentId?: IntFilter | number
    segmentId?: IntNullableFilter | number | null
    subSegmentId?: IntNullableFilter | number | null
    title?: StringFilter | string
    description?: StringFilter | string
    userType?: StringFilter | string
    communityImpact?: StringNullableFilter | string | null
    natureImpact?: StringNullableFilter | string | null
    artsImpact?: StringNullableFilter | string | null
    energyImpact?: StringNullableFilter | string | null
    manufacturingImpact?: StringNullableFilter | string | null
    state?: EnumIdeaStateFilter | IdeaState
    active?: BoolFilter | boolean
    imagePath?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    comments?: CommentListRelationFilter
    ratings?: RatingListRelationFilter
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
    geo?: XOR<GeoRelationFilter, GeoWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    champion?: XOR<UserRelationFilter, UserWhereInput> | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    superSegment?: XOR<SuperSegmentRelationFilter, SuperSegmentWhereInput>
    segment?: XOR<SegmentsRelationFilter, SegmentsWhereInput> | null
    subSegment?: XOR<SubSegmentsRelationFilter, SubSegmentsWhereInput> | null
  }

  export type ProposalOrderByInput = {
    id?: SortOrder
    authorId?: SortOrder
    championId?: SortOrder
    categoryId?: SortOrder
    superSegmentId?: SortOrder
    segmentId?: SortOrder
    subSegmentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userType?: SortOrder
    communityImpact?: SortOrder
    natureImpact?: SortOrder
    artsImpact?: SortOrder
    energyImpact?: SortOrder
    manufacturingImpact?: SortOrder
    state?: SortOrder
    active?: SortOrder
    imagePath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalWhereUniqueInput = {
    id?: number
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProposalScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProposalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProposalScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    authorId?: StringWithAggregatesFilter | string
    championId?: StringNullableWithAggregatesFilter | string | null
    categoryId?: IntWithAggregatesFilter | number
    superSegmentId?: IntWithAggregatesFilter | number
    segmentId?: IntNullableWithAggregatesFilter | number | null
    subSegmentId?: IntNullableWithAggregatesFilter | number | null
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    userType?: StringWithAggregatesFilter | string
    communityImpact?: StringNullableWithAggregatesFilter | string | null
    natureImpact?: StringNullableWithAggregatesFilter | string | null
    artsImpact?: StringNullableWithAggregatesFilter | string | null
    energyImpact?: StringNullableWithAggregatesFilter | string | null
    manufacturingImpact?: StringNullableWithAggregatesFilter | string | null
    state?: EnumIdeaStateWithAggregatesFilter | IdeaState
    active?: BoolWithAggregatesFilter | boolean
    imagePath?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProjectWhereInput = {
    AND?: Enumerable<ProjectWhereInput>
    OR?: Enumerable<ProjectWhereInput>
    NOT?: Enumerable<ProjectWhereInput>
    id?: IntFilter | number
    ideaId?: IntFilter | number
    description?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    idea?: XOR<IdeaRelationFilter, IdeaWhereInput>
  }

  export type ProjectOrderByInput = {
    id?: SortOrder
    ideaId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectWhereUniqueInput = {
    id?: number
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProjectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaId?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RatingWhereInput = {
    AND?: Enumerable<RatingWhereInput>
    OR?: Enumerable<RatingWhereInput>
    NOT?: Enumerable<RatingWhereInput>
    id?: IntFilter | number
    ideaId?: IntNullableFilter | number | null
    proposalId?: IntNullableFilter | number | null
    authorId?: StringFilter | string
    rating?: IntFilter | number
    ratingExplanation?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    idea?: XOR<IdeaRelationFilter, IdeaWhereInput> | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput> | null
  }

  export type RatingOrderByInput = {
    id?: SortOrder
    ideaId?: SortOrder
    proposalId?: SortOrder
    authorId?: SortOrder
    rating?: SortOrder
    ratingExplanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RatingWhereUniqueInput = {
    id?: number
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RatingScalarWhereWithAggregatesInput>
    OR?: Enumerable<RatingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RatingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaId?: IntNullableWithAggregatesFilter | number | null
    proposalId?: IntNullableWithAggregatesFilter | number | null
    authorId?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    ratingExplanation?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: IntFilter | number
    ideaId?: IntNullableFilter | number | null
    proposalId?: IntNullableFilter | number | null
    authorId?: StringFilter | string
    userSegId?: StringFilter | string
    superSegmentId?: IntNullableFilter | number | null
    segmentId?: IntNullableFilter | number | null
    subSegmentId?: IntNullableFilter | number | null
    content?: StringFilter | string
    active?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    idea?: XOR<IdeaRelationFilter, IdeaWhereInput> | null
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput> | null
    userSeg?: XOR<UserSegmentsRelationFilter, UserSegmentsWhereInput>
    likes?: UserCommentLikesListRelationFilter
    dislikes?: UserCommentDislikesListRelationFilter
  }

  export type CommentOrderByInput = {
    id?: SortOrder
    ideaId?: SortOrder
    proposalId?: SortOrder
    authorId?: SortOrder
    userSegId?: SortOrder
    superSegmentId?: SortOrder
    segmentId?: SortOrder
    subSegmentId?: SortOrder
    content?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentWhereUniqueInput = {
    id?: number
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaId?: IntNullableWithAggregatesFilter | number | null
    proposalId?: IntNullableWithAggregatesFilter | number | null
    authorId?: StringWithAggregatesFilter | string
    userSegId?: StringWithAggregatesFilter | string
    superSegmentId?: IntNullableWithAggregatesFilter | number | null
    segmentId?: IntNullableWithAggregatesFilter | number | null
    subSegmentId?: IntNullableWithAggregatesFilter | number | null
    content?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCommentLikesWhereInput = {
    AND?: Enumerable<UserCommentLikesWhereInput>
    OR?: Enumerable<UserCommentLikesWhereInput>
    NOT?: Enumerable<UserCommentLikesWhereInput>
    id?: IntFilter | number
    ideaCommentId?: IntNullableFilter | number | null
    authorId?: StringNullableFilter | string | null
    ideaComment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type UserCommentLikesOrderByInput = {
    id?: SortOrder
    ideaCommentId?: SortOrder
    authorId?: SortOrder
  }

  export type UserCommentLikesWhereUniqueInput = {
    id?: number
  }

  export type UserCommentLikesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserCommentLikesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserCommentLikesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserCommentLikesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaCommentId?: IntNullableWithAggregatesFilter | number | null
    authorId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserCommentDislikesWhereInput = {
    AND?: Enumerable<UserCommentDislikesWhereInput>
    OR?: Enumerable<UserCommentDislikesWhereInput>
    NOT?: Enumerable<UserCommentDislikesWhereInput>
    id?: IntFilter | number
    ideaCommentId?: IntNullableFilter | number | null
    authorId?: StringNullableFilter | string | null
    ideaComment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    author?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type UserCommentDislikesOrderByInput = {
    id?: SortOrder
    ideaCommentId?: SortOrder
    authorId?: SortOrder
  }

  export type UserCommentDislikesWhereUniqueInput = {
    id?: number
  }

  export type UserCommentDislikesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserCommentDislikesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserCommentDislikesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserCommentDislikesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ideaCommentId?: IntNullableWithAggregatesFilter | number | null
    authorId?: StringNullableWithAggregatesFilter | string | null
  }

  export type AdvertisementsWhereInput = {
    AND?: Enumerable<AdvertisementsWhereInput>
    OR?: Enumerable<AdvertisementsWhereInput>
    NOT?: Enumerable<AdvertisementsWhereInput>
    id?: IntFilter | number
    ownerId?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeNullableFilter | Date | string | null
    adTitle?: StringFilter | string
    adType?: EnumAdTypeFilter | AdType
    duration?: DateTimeNullableFilter | Date | string | null
    adPosition?: StringFilter | string
    imagePath?: StringFilter | string
    externalLink?: StringFilter | string
    published?: BoolFilter | boolean
    author?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AdvertisementsOrderByInput = {
    id?: SortOrder
    ownerId?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    adTitle?: SortOrder
    adType?: SortOrder
    duration?: SortOrder
    adPosition?: SortOrder
    imagePath?: SortOrder
    externalLink?: SortOrder
    published?: SortOrder
  }

  export type AdvertisementsWhereUniqueInput = {
    id?: number
  }

  export type AdvertisementsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdvertisementsScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdvertisementsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdvertisementsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ownerId?: StringWithAggregatesFilter | string
    createAt?: DateTimeWithAggregatesFilter | Date | string
    updateAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    adTitle?: StringWithAggregatesFilter | string
    adType?: EnumAdTypeWithAggregatesFilter | AdType
    duration?: DateTimeNullableWithAggregatesFilter | Date | string | null
    adPosition?: StringWithAggregatesFilter | string
    imagePath?: StringWithAggregatesFilter | string
    externalLink?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
  }

  export type SuperSegmentWhereInput = {
    AND?: Enumerable<SuperSegmentWhereInput>
    OR?: Enumerable<SuperSegmentWhereInput>
    NOT?: Enumerable<SuperSegmentWhereInput>
    superSegId?: IntFilter | number
    name?: StringFilter | string
    country?: StringFilter | string
    province?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    Segments?: SegmentsListRelationFilter
    Idea?: IdeaListRelationFilter
    Proposal?: ProposalListRelationFilter
    homeUserSegments?: UserSegmentsListRelationFilter
    workUserSegments?: UserSegmentsListRelationFilter
    schoolUserSegments?: UserSegmentsListRelationFilter
  }

  export type SuperSegmentOrderByInput = {
    superSegId?: SortOrder
    name?: SortOrder
    country?: SortOrder
    province?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperSegmentWhereUniqueInput = {
    superSegId?: number
  }

  export type SuperSegmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SuperSegmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<SuperSegmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SuperSegmentScalarWhereWithAggregatesInput>
    superSegId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    province?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SegmentsWhereInput = {
    AND?: Enumerable<SegmentsWhereInput>
    OR?: Enumerable<SegmentsWhereInput>
    NOT?: Enumerable<SegmentsWhereInput>
    segId?: IntFilter | number
    superSegId?: IntFilter | number
    country?: StringFilter | string
    province?: StringFilter | string
    name?: StringFilter | string
    superSegName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    superSegment?: XOR<SuperSegmentRelationFilter, SuperSegmentWhereInput>
    SubSegments?: SubSegmentsListRelationFilter
    homeSegments?: UserSegmentsListRelationFilter
    workSegments?: UserSegmentsListRelationFilter
    schoolSegments?: UserSegmentsListRelationFilter
    Idea?: IdeaListRelationFilter
    Proposal?: ProposalListRelationFilter
  }

  export type SegmentsOrderByInput = {
    segId?: SortOrder
    superSegId?: SortOrder
    country?: SortOrder
    province?: SortOrder
    name?: SortOrder
    superSegName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentsWhereUniqueInput = {
    segId?: number
  }

  export type SegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SegmentsScalarWhereWithAggregatesInput>
    segId?: IntWithAggregatesFilter | number
    superSegId?: IntWithAggregatesFilter | number
    country?: StringWithAggregatesFilter | string
    province?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    superSegName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SubSegmentsWhereInput = {
    AND?: Enumerable<SubSegmentsWhereInput>
    OR?: Enumerable<SubSegmentsWhereInput>
    NOT?: Enumerable<SubSegmentsWhereInput>
    id?: IntFilter | number
    segId?: IntFilter | number
    name?: StringFilter | string
    lat?: DecimalNullableFilter | Decimal | number | string | null
    lon?: DecimalNullableFilter | Decimal | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    segRef?: XOR<SegmentsRelationFilter, SegmentsWhereInput>
    homeSubSegments?: UserSegmentsListRelationFilter
    workSubSegments?: UserSegmentsListRelationFilter
    schoolSubSegments?: UserSegmentsListRelationFilter
    Idea?: IdeaListRelationFilter
    Proposal?: ProposalListRelationFilter
  }

  export type SubSegmentsOrderByInput = {
    id?: SortOrder
    segId?: SortOrder
    name?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubSegmentsWhereUniqueInput = {
    id?: number
  }

  export type SubSegmentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubSegmentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubSegmentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubSegmentsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    segId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    lat?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    lon?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type segmentRequestWhereInput = {
    AND?: Enumerable<segmentRequestWhereInput>
    OR?: Enumerable<segmentRequestWhereInput>
    NOT?: Enumerable<segmentRequestWhereInput>
    id?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    country?: StringFilter | string
    province?: StringFilter | string
    segmentName?: StringFilter | string
    subSegmentName?: StringNullableFilter | string | null
    requester?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type segmentRequestOrderByInput = {
    id?: SortOrder
    createAt?: SortOrder
    userId?: SortOrder
    country?: SortOrder
    province?: SortOrder
    segmentName?: SortOrder
    subSegmentName?: SortOrder
  }

  export type segmentRequestWhereUniqueInput = {
    id?: number
  }

  export type segmentRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<segmentRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<segmentRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<segmentRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    province?: StringWithAggregatesFilter | string
    segmentName?: StringWithAggregatesFilter | string
    subSegmentName?: StringNullableWithAggregatesFilter | string | null
  }

  export type ReportCreateInput = {
    email: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    email: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: number
    email: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGeoCreateInput = {
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    work_lat?: Decimal | number | string | null
    work_lon?: Decimal | number | string | null
    school_lat?: Decimal | number | string | null
    school_lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGeoInput
  }

  export type UserGeoUncheckedCreateInput = {
    id?: number
    userId: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    work_lat?: Decimal | number | string | null
    work_lon?: Decimal | number | string | null
    school_lat?: Decimal | number | string | null
    school_lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGeoUpdateInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGeoInput
  }

  export type UserGeoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGeoCreateManyInput = {
    id?: number
    userId: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    work_lat?: Decimal | number | string | null
    work_lon?: Decimal | number | string | null
    school_lat?: Decimal | number | string | null
    school_lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGeoUpdateManyMutationInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGeoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressCreateInput = {
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAddressInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: number
    userId: string
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressUpdateInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressCreateManyInput = {
    id?: number
    userId: string
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressUpdateManyMutationInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateManyInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSegmentsCreateInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsCreateManyInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ideas?: IdeaCreateNestedManyWithoutCategoryInput
    proposals?: ProposalCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ideas?: IdeaUncheckedCreateNestedManyWithoutCategoryInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: IdeaUpdateManyWithoutCategoryInput
    proposals?: ProposalUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: IdeaUncheckedUpdateManyWithoutCategoryInput
    proposals?: ProposalUncheckedUpdateManyWithoutCategoryInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCreateInput = {
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idea?: IdeaCreateNestedOneWithoutGeoInput
    proposal?: ProposalCreateNestedOneWithoutGeoInput
  }

  export type GeoUncheckedCreateInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeoUpdateInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneWithoutGeoInput
    proposal?: ProposalUpdateOneWithoutGeoInput
  }

  export type GeoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoCreateManyInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeoUpdateManyMutationInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idea?: IdeaCreateNestedOneWithoutAddressInput
    proposal?: ProposalCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneWithoutAddressInput
    proposal?: ProposalUpdateOneWithoutAddressInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaCreateInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type IdeaCreateManyInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCreateInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type ProposalCreateManyInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idea: IdeaCreateNestedOneWithoutProjectInfoInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    ideaId: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneRequiredWithoutProjectInfoInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyInput = {
    id?: number
    ideaId: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaRatingsInput
    idea?: IdeaCreateNestedOneWithoutRatingsInput
    proposal?: ProposalCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaRatingsInput
    idea?: IdeaUpdateOneWithoutRatingsInput
    proposal?: ProposalUpdateOneWithoutRatingsInput
  }

  export type RatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManyInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaCommentsInput
    idea?: IdeaCreateNestedOneWithoutCommentsInput
    proposal?: ProposalCreateNestedOneWithoutCommentsInput
    userSeg: UserSegmentsCreateNestedOneWithoutIdeaCommentInput
    likes?: UserCommentLikesCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUpdateInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaCommentsInput
    idea?: IdeaUpdateOneWithoutCommentsInput
    proposal?: ProposalUpdateOneWithoutCommentsInput
    userSeg?: UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput
    likes?: UserCommentLikesUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type CommentCreateManyInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCommentLikesCreateInput = {
    ideaComment?: CommentCreateNestedOneWithoutLikesInput
    author?: UserCreateNestedOneWithoutIdeaCommentLikesInput
  }

  export type UserCommentLikesUncheckedCreateInput = {
    id?: number
    ideaCommentId?: number | null
    authorId?: string | null
  }

  export type UserCommentLikesUpdateInput = {
    ideaComment?: CommentUpdateOneWithoutLikesInput
    author?: UserUpdateOneWithoutIdeaCommentLikesInput
  }

  export type UserCommentLikesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentLikesCreateManyInput = {
    id?: number
    ideaCommentId?: number | null
    authorId?: string | null
  }

  export type UserCommentLikesUpdateManyMutationInput = {

  }

  export type UserCommentLikesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentDislikesCreateInput = {
    ideaComment?: CommentCreateNestedOneWithoutDislikesInput
    author?: UserCreateNestedOneWithoutIdeaCommentDislikesInput
  }

  export type UserCommentDislikesUncheckedCreateInput = {
    id?: number
    ideaCommentId?: number | null
    authorId?: string | null
  }

  export type UserCommentDislikesUpdateInput = {
    ideaComment?: CommentUpdateOneWithoutDislikesInput
    author?: UserUpdateOneWithoutIdeaCommentDislikesInput
  }

  export type UserCommentDislikesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentDislikesCreateManyInput = {
    id?: number
    ideaCommentId?: number | null
    authorId?: string | null
  }

  export type UserCommentDislikesUpdateManyMutationInput = {

  }

  export type UserCommentDislikesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdvertisementsCreateInput = {
    createAt?: Date | string
    updateAt?: Date | string | null
    adTitle: string
    adType?: AdType
    duration?: Date | string | null
    adPosition: string
    imagePath: string
    externalLink: string
    published?: boolean
    author?: UserCreateNestedOneWithoutAdvertisementsInput
  }

  export type AdvertisementsUncheckedCreateInput = {
    id?: number
    ownerId: string
    createAt?: Date | string
    updateAt?: Date | string | null
    adTitle: string
    adType?: AdType
    duration?: Date | string | null
    adPosition: string
    imagePath: string
    externalLink: string
    published?: boolean
  }

  export type AdvertisementsUpdateInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutAdvertisementsInput
  }

  export type AdvertisementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvertisementsCreateManyInput = {
    id?: number
    ownerId: string
    createAt?: Date | string
    updateAt?: Date | string | null
    adTitle: string
    adType?: AdType
    duration?: Date | string | null
    adPosition: string
    imagePath: string
    externalLink: string
    published?: boolean
  }

  export type AdvertisementsUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvertisementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SuperSegmentCreateInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedCreateInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUncheckedUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentCreateManyInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SuperSegmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SuperSegmentUncheckedUpdateManyInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SegmentsCreateInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type SegmentsCreateManyInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SegmentsUpdateManyMutationInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SegmentsUncheckedUpdateManyInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubSegmentsCreateInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    segRef: SegmentsCreateNestedOneWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segRef?: SegmentsUpdateOneRequiredWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateManyInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SubSegmentsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubSegmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type segmentRequestCreateInput = {
    createAt?: Date | string
    country: string
    province: string
    segmentName: string
    subSegmentName?: string | null
    requester: UserCreateNestedOneWithoutSegmentRequestInput
  }

  export type segmentRequestUncheckedCreateInput = {
    id?: number
    createAt?: Date | string
    userId: string
    country: string
    province: string
    segmentName: string
    subSegmentName?: string | null
  }

  export type segmentRequestUpdateInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    requester?: UserUpdateOneRequiredWithoutSegmentRequestInput
  }

  export type segmentRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type segmentRequestCreateManyInput = {
    id?: number
    createAt?: Date | string
    userId: string
    country: string
    province: string
    segmentName: string
    subSegmentName?: string | null
  }

  export type segmentRequestUpdateManyMutationInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type segmentRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | number | string | null
    count?: NestedIntNullableFilter
    avg?: NestedDecimalNullableFilter
    sum?: NestedDecimalNullableFilter
    min?: NestedDecimalNullableFilter
    max?: NestedDecimalNullableFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type EnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type UserAddressRelationFilter = {
    is?: UserAddressWhereInput | null
    isNot?: UserAddressWhereInput | null
  }

  export type UserGeoRelationFilter = {
    is?: UserGeoWhereInput | null
    isNot?: UserGeoWhereInput | null
  }

  export type IdeaListRelationFilter = {
    every?: IdeaWhereInput
    some?: IdeaWhereInput
    none?: IdeaWhereInput
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type UserCommentLikesListRelationFilter = {
    every?: UserCommentLikesWhereInput
    some?: UserCommentLikesWhereInput
    none?: UserCommentLikesWhereInput
  }

  export type UserCommentDislikesListRelationFilter = {
    every?: UserCommentDislikesWhereInput
    some?: UserCommentDislikesWhereInput
    none?: UserCommentDislikesWhereInput
  }

  export type AdvertisementsListRelationFilter = {
    every?: AdvertisementsWhereInput
    some?: AdvertisementsWhereInput
    none?: AdvertisementsWhereInput
  }

  export type SegmentRequestListRelationFilter = {
    every?: segmentRequestWhereInput
    some?: segmentRequestWhereInput
    none?: segmentRequestWhereInput
  }

  export type UserSegmentsRelationFilter = {
    is?: UserSegmentsWhereInput | null
    isNot?: UserSegmentsWhereInput | null
  }

  export type EnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    count?: NestedIntFilter
    min?: NestedEnumUserTypeFilter
    max?: NestedEnumUserTypeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type SuperSegmentRelationFilter = {
    is?: SuperSegmentWhereInput
    isNot?: SuperSegmentWhereInput
  }

  export type SegmentsRelationFilter = {
    is?: SegmentsWhereInput
    isNot?: SegmentsWhereInput
  }

  export type SubSegmentsRelationFilter = {
    is?: SubSegmentsWhereInput | null
    isNot?: SubSegmentsWhereInput | null
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type IdeaRelationFilter = {
    is?: IdeaWhereInput | null
    isNot?: IdeaWhereInput | null
  }

  export type ProposalRelationFilter = {
    is?: ProposalWhereInput | null
    isNot?: ProposalWhereInput | null
  }

  export type EnumIdeaStateFilter = {
    equals?: IdeaState
    in?: Enumerable<IdeaState>
    notIn?: Enumerable<IdeaState>
    not?: NestedEnumIdeaStateFilter | IdeaState
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type GeoRelationFilter = {
    is?: GeoWhereInput | null
    isNot?: GeoWhereInput | null
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type EnumIdeaStateWithAggregatesFilter = {
    equals?: IdeaState
    in?: Enumerable<IdeaState>
    notIn?: Enumerable<IdeaState>
    not?: NestedEnumIdeaStateWithAggregatesFilter | IdeaState
    count?: NestedIntFilter
    min?: NestedEnumIdeaStateFilter
    max?: NestedEnumIdeaStateFilter
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumAdTypeFilter = {
    equals?: AdType
    in?: Enumerable<AdType>
    notIn?: Enumerable<AdType>
    not?: NestedEnumAdTypeFilter | AdType
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    count?: NestedIntNullableFilter
    min?: NestedDateTimeNullableFilter
    max?: NestedDateTimeNullableFilter
  }

  export type EnumAdTypeWithAggregatesFilter = {
    equals?: AdType
    in?: Enumerable<AdType>
    notIn?: Enumerable<AdType>
    not?: NestedEnumAdTypeWithAggregatesFilter | AdType
    count?: NestedIntFilter
    min?: NestedEnumAdTypeFilter
    max?: NestedEnumAdTypeFilter
  }

  export type SegmentsListRelationFilter = {
    every?: SegmentsWhereInput
    some?: SegmentsWhereInput
    none?: SegmentsWhereInput
  }

  export type UserSegmentsListRelationFilter = {
    every?: UserSegmentsWhereInput
    some?: UserSegmentsWhereInput
    none?: UserSegmentsWhereInput
  }

  export type SubSegmentsListRelationFilter = {
    every?: SubSegmentsWhereInput
    some?: SubSegmentsWhereInput
    none?: SubSegmentsWhereInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutGeoInput = {
    create?: XOR<UserCreateWithoutGeoInput, UserUncheckedCreateWithoutGeoInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeoInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string | null
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type UserUpdateOneRequiredWithoutGeoInput = {
    create?: XOR<UserCreateWithoutGeoInput, UserUncheckedCreateWithoutGeoInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeoInput
    upsert?: UserUpsertWithoutGeoInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGeoInput, UserUncheckedUpdateWithoutGeoInput>
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserAddressCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    connect?: UserAddressWhereUniqueInput
  }

  export type UserGeoCreateNestedOneWithoutUserInput = {
    create?: XOR<UserGeoCreateWithoutUserInput, UserGeoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGeoCreateOrConnectWithoutUserInput
    connect?: UserGeoWhereUniqueInput
  }

  export type IdeaCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutAuthorInput>, Enumerable<IdeaUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutAuthorInput>
    createMany?: IdeaCreateManyAuthorInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutAuthorInput>, Enumerable<ProposalUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutAuthorInput>
    createMany?: ProposalCreateManyAuthorInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type ProposalCreateNestedManyWithoutChampionInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutChampionInput>, Enumerable<ProposalUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutChampionInput>
    createMany?: ProposalCreateManyChampionInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type IdeaCreateNestedManyWithoutChampionInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutChampionInput>, Enumerable<IdeaUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutChampionInput>
    createMany?: IdeaCreateManyChampionInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type RatingCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<RatingCreateWithoutAuthorInput>, Enumerable<RatingUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutAuthorInput>
    createMany?: RatingCreateManyAuthorInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserCommentLikesCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutAuthorInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutAuthorInput>
    createMany?: UserCommentLikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
  }

  export type UserCommentDislikesCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutAuthorInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutAuthorInput>
    createMany?: UserCommentDislikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
  }

  export type AdvertisementsCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<AdvertisementsCreateWithoutAuthorInput>, Enumerable<AdvertisementsUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<AdvertisementsCreateOrConnectWithoutAuthorInput>
    createMany?: AdvertisementsCreateManyAuthorInputEnvelope
    connect?: Enumerable<AdvertisementsWhereUniqueInput>
  }

  export type segmentRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<segmentRequestCreateWithoutRequesterInput>, Enumerable<segmentRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<segmentRequestCreateOrConnectWithoutRequesterInput>
    createMany?: segmentRequestCreateManyRequesterInputEnvelope
    connect?: Enumerable<segmentRequestWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSegmentsCreateWithoutUserInput, UserSegmentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSegmentsCreateOrConnectWithoutUserInput
    connect?: UserSegmentsWhereUniqueInput
  }

  export type UserAddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    connect?: UserAddressWhereUniqueInput
  }

  export type UserGeoUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserGeoCreateWithoutUserInput, UserGeoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGeoCreateOrConnectWithoutUserInput
    connect?: UserGeoWhereUniqueInput
  }

  export type IdeaUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutAuthorInput>, Enumerable<IdeaUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutAuthorInput>
    createMany?: IdeaCreateManyAuthorInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutAuthorInput>, Enumerable<ProposalUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutAuthorInput>
    createMany?: ProposalCreateManyAuthorInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type ProposalUncheckedCreateNestedManyWithoutChampionInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutChampionInput>, Enumerable<ProposalUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutChampionInput>
    createMany?: ProposalCreateManyChampionInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type IdeaUncheckedCreateNestedManyWithoutChampionInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutChampionInput>, Enumerable<IdeaUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutChampionInput>
    createMany?: IdeaCreateManyChampionInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type RatingUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<RatingCreateWithoutAuthorInput>, Enumerable<RatingUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutAuthorInput>
    createMany?: RatingCreateManyAuthorInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutAuthorInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutAuthorInput>
    createMany?: UserCommentLikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
  }

  export type UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutAuthorInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutAuthorInput>
    createMany?: UserCommentDislikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
  }

  export type AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<AdvertisementsCreateWithoutAuthorInput>, Enumerable<AdvertisementsUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<AdvertisementsCreateOrConnectWithoutAuthorInput>
    createMany?: AdvertisementsCreateManyAuthorInputEnvelope
    connect?: Enumerable<AdvertisementsWhereUniqueInput>
  }

  export type segmentRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<Enumerable<segmentRequestCreateWithoutRequesterInput>, Enumerable<segmentRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<segmentRequestCreateOrConnectWithoutRequesterInput>
    createMany?: segmentRequestCreateManyRequesterInputEnvelope
    connect?: Enumerable<segmentRequestWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSegmentsCreateWithoutUserInput, UserSegmentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSegmentsCreateOrConnectWithoutUserInput
    connect?: UserSegmentsWhereUniqueInput
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: UserType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserAddressUpdateOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    upsert?: UserAddressUpsertWithoutUserInput
    connect?: UserAddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserGeoUpdateOneWithoutUserInput = {
    create?: XOR<UserGeoCreateWithoutUserInput, UserGeoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGeoCreateOrConnectWithoutUserInput
    upsert?: UserGeoUpsertWithoutUserInput
    connect?: UserGeoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserGeoUpdateWithoutUserInput, UserGeoUncheckedUpdateWithoutUserInput>
  }

  export type IdeaUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutAuthorInput>, Enumerable<IdeaUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: IdeaCreateManyAuthorInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutAuthorInput>, Enumerable<ProposalUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ProposalCreateManyAuthorInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type ProposalUpdateManyWithoutChampionInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutChampionInput>, Enumerable<ProposalUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutChampionInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutChampionInput>
    createMany?: ProposalCreateManyChampionInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutChampionInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutChampionInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type IdeaUpdateManyWithoutChampionInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutChampionInput>, Enumerable<IdeaUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutChampionInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutChampionInput>
    createMany?: IdeaCreateManyChampionInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutChampionInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutChampionInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type RatingUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<RatingCreateWithoutAuthorInput>, Enumerable<RatingUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<RatingUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: RatingCreateManyAuthorInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
    set?: Enumerable<RatingWhereUniqueInput>
    disconnect?: Enumerable<RatingWhereUniqueInput>
    delete?: Enumerable<RatingWhereUniqueInput>
    update?: Enumerable<RatingUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<RatingUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<RatingScalarWhereInput>
  }

  export type CommentUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserCommentLikesUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutAuthorInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<UserCommentLikesUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: UserCommentLikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
    set?: Enumerable<UserCommentLikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentLikesWhereUniqueInput>
    delete?: Enumerable<UserCommentLikesWhereUniqueInput>
    update?: Enumerable<UserCommentLikesUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<UserCommentLikesUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<UserCommentLikesScalarWhereInput>
  }

  export type UserCommentDislikesUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutAuthorInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<UserCommentDislikesUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: UserCommentDislikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    set?: Enumerable<UserCommentDislikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    delete?: Enumerable<UserCommentDislikesWhereUniqueInput>
    update?: Enumerable<UserCommentDislikesUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<UserCommentDislikesUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<UserCommentDislikesScalarWhereInput>
  }

  export type AdvertisementsUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<AdvertisementsCreateWithoutAuthorInput>, Enumerable<AdvertisementsUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<AdvertisementsCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<AdvertisementsUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: AdvertisementsCreateManyAuthorInputEnvelope
    connect?: Enumerable<AdvertisementsWhereUniqueInput>
    set?: Enumerable<AdvertisementsWhereUniqueInput>
    disconnect?: Enumerable<AdvertisementsWhereUniqueInput>
    delete?: Enumerable<AdvertisementsWhereUniqueInput>
    update?: Enumerable<AdvertisementsUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<AdvertisementsUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<AdvertisementsScalarWhereInput>
  }

  export type segmentRequestUpdateManyWithoutRequesterInput = {
    create?: XOR<Enumerable<segmentRequestCreateWithoutRequesterInput>, Enumerable<segmentRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<segmentRequestCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<segmentRequestUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: segmentRequestCreateManyRequesterInputEnvelope
    connect?: Enumerable<segmentRequestWhereUniqueInput>
    set?: Enumerable<segmentRequestWhereUniqueInput>
    disconnect?: Enumerable<segmentRequestWhereUniqueInput>
    delete?: Enumerable<segmentRequestWhereUniqueInput>
    update?: Enumerable<segmentRequestUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<segmentRequestUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<segmentRequestScalarWhereInput>
  }

  export type UserSegmentsUpdateOneWithoutUserInput = {
    create?: XOR<UserSegmentsCreateWithoutUserInput, UserSegmentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSegmentsCreateOrConnectWithoutUserInput
    upsert?: UserSegmentsUpsertWithoutUserInput
    connect?: UserSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserSegmentsUpdateWithoutUserInput, UserSegmentsUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    upsert?: UserAddressUpsertWithoutUserInput
    connect?: UserAddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserGeoUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<UserGeoCreateWithoutUserInput, UserGeoUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserGeoCreateOrConnectWithoutUserInput
    upsert?: UserGeoUpsertWithoutUserInput
    connect?: UserGeoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserGeoUpdateWithoutUserInput, UserGeoUncheckedUpdateWithoutUserInput>
  }

  export type IdeaUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutAuthorInput>, Enumerable<IdeaUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: IdeaCreateManyAuthorInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutAuthorInput>, Enumerable<ProposalUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: ProposalCreateManyAuthorInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type ProposalUncheckedUpdateManyWithoutChampionInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutChampionInput>, Enumerable<ProposalUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutChampionInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutChampionInput>
    createMany?: ProposalCreateManyChampionInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutChampionInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutChampionInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type IdeaUncheckedUpdateManyWithoutChampionInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutChampionInput>, Enumerable<IdeaUncheckedCreateWithoutChampionInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutChampionInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutChampionInput>
    createMany?: IdeaCreateManyChampionInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutChampionInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutChampionInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type RatingUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<RatingCreateWithoutAuthorInput>, Enumerable<RatingUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<RatingUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: RatingCreateManyAuthorInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
    set?: Enumerable<RatingWhereUniqueInput>
    disconnect?: Enumerable<RatingWhereUniqueInput>
    delete?: Enumerable<RatingWhereUniqueInput>
    update?: Enumerable<RatingUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<RatingUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<RatingScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserCommentLikesUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutAuthorInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<UserCommentLikesUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: UserCommentLikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
    set?: Enumerable<UserCommentLikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentLikesWhereUniqueInput>
    delete?: Enumerable<UserCommentLikesWhereUniqueInput>
    update?: Enumerable<UserCommentLikesUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<UserCommentLikesUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<UserCommentLikesScalarWhereInput>
  }

  export type UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutAuthorInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<UserCommentDislikesUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: UserCommentDislikesCreateManyAuthorInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    set?: Enumerable<UserCommentDislikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    delete?: Enumerable<UserCommentDislikesWhereUniqueInput>
    update?: Enumerable<UserCommentDislikesUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<UserCommentDislikesUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<UserCommentDislikesScalarWhereInput>
  }

  export type AdvertisementsUncheckedUpdateManyWithoutAuthorInput = {
    create?: XOR<Enumerable<AdvertisementsCreateWithoutAuthorInput>, Enumerable<AdvertisementsUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<AdvertisementsCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<AdvertisementsUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: AdvertisementsCreateManyAuthorInputEnvelope
    connect?: Enumerable<AdvertisementsWhereUniqueInput>
    set?: Enumerable<AdvertisementsWhereUniqueInput>
    disconnect?: Enumerable<AdvertisementsWhereUniqueInput>
    delete?: Enumerable<AdvertisementsWhereUniqueInput>
    update?: Enumerable<AdvertisementsUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<AdvertisementsUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<AdvertisementsScalarWhereInput>
  }

  export type segmentRequestUncheckedUpdateManyWithoutRequesterInput = {
    create?: XOR<Enumerable<segmentRequestCreateWithoutRequesterInput>, Enumerable<segmentRequestUncheckedCreateWithoutRequesterInput>>
    connectOrCreate?: Enumerable<segmentRequestCreateOrConnectWithoutRequesterInput>
    upsert?: Enumerable<segmentRequestUpsertWithWhereUniqueWithoutRequesterInput>
    createMany?: segmentRequestCreateManyRequesterInputEnvelope
    connect?: Enumerable<segmentRequestWhereUniqueInput>
    set?: Enumerable<segmentRequestWhereUniqueInput>
    disconnect?: Enumerable<segmentRequestWhereUniqueInput>
    delete?: Enumerable<segmentRequestWhereUniqueInput>
    update?: Enumerable<segmentRequestUpdateWithWhereUniqueWithoutRequesterInput>
    updateMany?: Enumerable<segmentRequestUpdateManyWithWhereWithoutRequesterInput>
    deleteMany?: Enumerable<segmentRequestScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<UserSegmentsCreateWithoutUserInput, UserSegmentsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSegmentsCreateOrConnectWithoutUserInput
    upsert?: UserSegmentsUpsertWithoutUserInput
    connect?: UserSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserSegmentsUpdateWithoutUserInput, UserSegmentsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUserSegmentsInput = {
    create?: XOR<UserCreateWithoutUserSegmentsInput, UserUncheckedCreateWithoutUserSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSegmentsInput
    connect?: UserWhereUniqueInput
  }

  export type SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutHomeUserSegmentsInput, SuperSegmentUncheckedCreateWithoutHomeUserSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutHomeUserSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
  }

  export type SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutWorkUserSegmentsInput, SuperSegmentUncheckedCreateWithoutWorkUserSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutWorkUserSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
  }

  export type SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutSchoolUserSegmentsInput, SuperSegmentUncheckedCreateWithoutSchoolUserSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutSchoolUserSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
  }

  export type SegmentsCreateNestedOneWithoutHomeSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutHomeSegmentsInput, SegmentsUncheckedCreateWithoutHomeSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutHomeSegmentsInput
    connect?: SegmentsWhereUniqueInput
  }

  export type SegmentsCreateNestedOneWithoutWorkSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutWorkSegmentsInput, SegmentsUncheckedCreateWithoutWorkSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutWorkSegmentsInput
    connect?: SegmentsWhereUniqueInput
  }

  export type SegmentsCreateNestedOneWithoutSchoolSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutSchoolSegmentsInput, SegmentsUncheckedCreateWithoutSchoolSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutSchoolSegmentsInput
    connect?: SegmentsWhereUniqueInput
  }

  export type SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput = {
    create?: XOR<SubSegmentsCreateWithoutHomeSubSegmentsInput, SubSegmentsUncheckedCreateWithoutHomeSubSegmentsInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutHomeSubSegmentsInput
    connect?: SubSegmentsWhereUniqueInput
  }

  export type SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput = {
    create?: XOR<SubSegmentsCreateWithoutWorkSubSegmentsInput, SubSegmentsUncheckedCreateWithoutWorkSubSegmentsInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutWorkSubSegmentsInput
    connect?: SubSegmentsWhereUniqueInput
  }

  export type SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput = {
    create?: XOR<SubSegmentsCreateWithoutSchoolSubSegmentsInput, SubSegmentsUncheckedCreateWithoutSchoolSubSegmentsInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutSchoolSubSegmentsInput
    connect?: SubSegmentsWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutUserSegInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserSegInput>, Enumerable<CommentUncheckedCreateWithoutUserSegInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserSegInput>
    createMany?: CommentCreateManyUserSegInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutUserSegInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserSegInput>, Enumerable<CommentUncheckedCreateWithoutUserSegInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserSegInput>
    createMany?: CommentCreateManyUserSegInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserUpdateOneWithoutUserSegmentsInput = {
    create?: XOR<UserCreateWithoutUserSegmentsInput, UserUncheckedCreateWithoutUserSegmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSegmentsInput
    upsert?: UserUpsertWithoutUserSegmentsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutUserSegmentsInput, UserUncheckedUpdateWithoutUserSegmentsInput>
  }

  export type SuperSegmentUpdateOneWithoutHomeUserSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutHomeUserSegmentsInput, SuperSegmentUncheckedCreateWithoutHomeUserSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutHomeUserSegmentsInput
    upsert?: SuperSegmentUpsertWithoutHomeUserSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SuperSegmentUpdateWithoutHomeUserSegmentsInput, SuperSegmentUncheckedUpdateWithoutHomeUserSegmentsInput>
  }

  export type SuperSegmentUpdateOneWithoutWorkUserSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutWorkUserSegmentsInput, SuperSegmentUncheckedCreateWithoutWorkUserSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutWorkUserSegmentsInput
    upsert?: SuperSegmentUpsertWithoutWorkUserSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SuperSegmentUpdateWithoutWorkUserSegmentsInput, SuperSegmentUncheckedUpdateWithoutWorkUserSegmentsInput>
  }

  export type SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutSchoolUserSegmentsInput, SuperSegmentUncheckedCreateWithoutSchoolUserSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutSchoolUserSegmentsInput
    upsert?: SuperSegmentUpsertWithoutSchoolUserSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SuperSegmentUpdateWithoutSchoolUserSegmentsInput, SuperSegmentUncheckedUpdateWithoutSchoolUserSegmentsInput>
  }

  export type SegmentsUpdateOneWithoutHomeSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutHomeSegmentsInput, SegmentsUncheckedCreateWithoutHomeSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutHomeSegmentsInput
    upsert?: SegmentsUpsertWithoutHomeSegmentsInput
    connect?: SegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SegmentsUpdateWithoutHomeSegmentsInput, SegmentsUncheckedUpdateWithoutHomeSegmentsInput>
  }

  export type SegmentsUpdateOneWithoutWorkSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutWorkSegmentsInput, SegmentsUncheckedCreateWithoutWorkSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutWorkSegmentsInput
    upsert?: SegmentsUpsertWithoutWorkSegmentsInput
    connect?: SegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SegmentsUpdateWithoutWorkSegmentsInput, SegmentsUncheckedUpdateWithoutWorkSegmentsInput>
  }

  export type SegmentsUpdateOneWithoutSchoolSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutSchoolSegmentsInput, SegmentsUncheckedCreateWithoutSchoolSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutSchoolSegmentsInput
    upsert?: SegmentsUpsertWithoutSchoolSegmentsInput
    connect?: SegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SegmentsUpdateWithoutSchoolSegmentsInput, SegmentsUncheckedUpdateWithoutSchoolSegmentsInput>
  }

  export type SubSegmentsUpdateOneWithoutHomeSubSegmentsInput = {
    create?: XOR<SubSegmentsCreateWithoutHomeSubSegmentsInput, SubSegmentsUncheckedCreateWithoutHomeSubSegmentsInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutHomeSubSegmentsInput
    upsert?: SubSegmentsUpsertWithoutHomeSubSegmentsInput
    connect?: SubSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubSegmentsUpdateWithoutHomeSubSegmentsInput, SubSegmentsUncheckedUpdateWithoutHomeSubSegmentsInput>
  }

  export type SubSegmentsUpdateOneWithoutWorkSubSegmentsInput = {
    create?: XOR<SubSegmentsCreateWithoutWorkSubSegmentsInput, SubSegmentsUncheckedCreateWithoutWorkSubSegmentsInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutWorkSubSegmentsInput
    upsert?: SubSegmentsUpsertWithoutWorkSubSegmentsInput
    connect?: SubSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubSegmentsUpdateWithoutWorkSubSegmentsInput, SubSegmentsUncheckedUpdateWithoutWorkSubSegmentsInput>
  }

  export type SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput = {
    create?: XOR<SubSegmentsCreateWithoutSchoolSubSegmentsInput, SubSegmentsUncheckedCreateWithoutSchoolSubSegmentsInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutSchoolSubSegmentsInput
    upsert?: SubSegmentsUpsertWithoutSchoolSubSegmentsInput
    connect?: SubSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubSegmentsUpdateWithoutSchoolSubSegmentsInput, SubSegmentsUncheckedUpdateWithoutSchoolSubSegmentsInput>
  }

  export type CommentUpdateManyWithoutUserSegInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserSegInput>, Enumerable<CommentUncheckedCreateWithoutUserSegInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserSegInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutUserSegInput>
    createMany?: CommentCreateManyUserSegInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutUserSegInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutUserSegInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUncheckedUpdateManyWithoutUserSegInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserSegInput>, Enumerable<CommentUncheckedCreateWithoutUserSegInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserSegInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutUserSegInput>
    createMany?: CommentCreateManyUserSegInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutUserSegInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutUserSegInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type IdeaCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutCategoryInput>, Enumerable<IdeaUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutCategoryInput>
    createMany?: IdeaCreateManyCategoryInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutCategoryInput>, Enumerable<ProposalUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutCategoryInput>
    createMany?: ProposalCreateManyCategoryInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type IdeaUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutCategoryInput>, Enumerable<IdeaUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutCategoryInput>
    createMany?: IdeaCreateManyCategoryInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutCategoryInput>, Enumerable<ProposalUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutCategoryInput>
    createMany?: ProposalCreateManyCategoryInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type IdeaUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutCategoryInput>, Enumerable<IdeaUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: IdeaCreateManyCategoryInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutCategoryInput>, Enumerable<ProposalUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ProposalCreateManyCategoryInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type IdeaUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutCategoryInput>, Enumerable<IdeaUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: IdeaCreateManyCategoryInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutCategoryInput>, Enumerable<ProposalUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ProposalCreateManyCategoryInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type IdeaCreateNestedOneWithoutGeoInput = {
    create?: XOR<IdeaCreateWithoutGeoInput, IdeaUncheckedCreateWithoutGeoInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutGeoInput
    connect?: IdeaWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutGeoInput = {
    create?: XOR<ProposalCreateWithoutGeoInput, ProposalUncheckedCreateWithoutGeoInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutGeoInput
    connect?: ProposalWhereUniqueInput
  }

  export type IdeaUpdateOneWithoutGeoInput = {
    create?: XOR<IdeaCreateWithoutGeoInput, IdeaUncheckedCreateWithoutGeoInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutGeoInput
    upsert?: IdeaUpsertWithoutGeoInput
    connect?: IdeaWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<IdeaUpdateWithoutGeoInput, IdeaUncheckedUpdateWithoutGeoInput>
  }

  export type ProposalUpdateOneWithoutGeoInput = {
    create?: XOR<ProposalCreateWithoutGeoInput, ProposalUncheckedCreateWithoutGeoInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutGeoInput
    upsert?: ProposalUpsertWithoutGeoInput
    connect?: ProposalWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProposalUpdateWithoutGeoInput, ProposalUncheckedUpdateWithoutGeoInput>
  }

  export type IdeaCreateNestedOneWithoutAddressInput = {
    create?: XOR<IdeaCreateWithoutAddressInput, IdeaUncheckedCreateWithoutAddressInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutAddressInput
    connect?: IdeaWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutAddressInput = {
    create?: XOR<ProposalCreateWithoutAddressInput, ProposalUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutAddressInput
    connect?: ProposalWhereUniqueInput
  }

  export type IdeaUpdateOneWithoutAddressInput = {
    create?: XOR<IdeaCreateWithoutAddressInput, IdeaUncheckedCreateWithoutAddressInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutAddressInput
    upsert?: IdeaUpsertWithoutAddressInput
    connect?: IdeaWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<IdeaUpdateWithoutAddressInput, IdeaUncheckedUpdateWithoutAddressInput>
  }

  export type ProposalUpdateOneWithoutAddressInput = {
    create?: XOR<ProposalCreateWithoutAddressInput, ProposalUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutAddressInput
    upsert?: ProposalUpsertWithoutAddressInput
    connect?: ProposalWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProposalUpdateWithoutAddressInput, ProposalUncheckedUpdateWithoutAddressInput>
  }

  export type CommentCreateNestedManyWithoutIdeaInput = {
    create?: XOR<Enumerable<CommentCreateWithoutIdeaInput>, Enumerable<CommentUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutIdeaInput>
    createMany?: CommentCreateManyIdeaInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type RatingCreateNestedManyWithoutIdeaInput = {
    create?: XOR<Enumerable<RatingCreateWithoutIdeaInput>, Enumerable<RatingUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutIdeaInput>
    createMany?: RatingCreateManyIdeaInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
  }

  export type ProjectCreateNestedOneWithoutIdeaInput = {
    create?: XOR<ProjectCreateWithoutIdeaInput, ProjectUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutIdeaInput
    connect?: ProjectWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutIdeaInput = {
    create?: XOR<AddressCreateWithoutIdeaInput, AddressUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: AddressCreateOrConnectWithoutIdeaInput
    connect?: AddressWhereUniqueInput
  }

  export type GeoCreateNestedOneWithoutIdeaInput = {
    create?: XOR<GeoCreateWithoutIdeaInput, GeoUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: GeoCreateOrConnectWithoutIdeaInput
    connect?: GeoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIdeasInput = {
    create?: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeasInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChampionedIdeasInput = {
    create?: XOR<UserCreateWithoutChampionedIdeasInput, UserUncheckedCreateWithoutChampionedIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionedIdeasInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutIdeasInput = {
    create?: XOR<CategoryCreateWithoutIdeasInput, CategoryUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutIdeasInput
    connect?: CategoryWhereUniqueInput
  }

  export type SuperSegmentCreateNestedOneWithoutIdeaInput = {
    create?: XOR<SuperSegmentCreateWithoutIdeaInput, SuperSegmentUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutIdeaInput
    connect?: SuperSegmentWhereUniqueInput
  }

  export type SegmentsCreateNestedOneWithoutIdeaInput = {
    create?: XOR<SegmentsCreateWithoutIdeaInput, SegmentsUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutIdeaInput
    connect?: SegmentsWhereUniqueInput
  }

  export type SubSegmentsCreateNestedOneWithoutIdeaInput = {
    create?: XOR<SubSegmentsCreateWithoutIdeaInput, SubSegmentsUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutIdeaInput
    connect?: SubSegmentsWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutIdeaInput = {
    create?: XOR<Enumerable<CommentCreateWithoutIdeaInput>, Enumerable<CommentUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutIdeaInput>
    createMany?: CommentCreateManyIdeaInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type RatingUncheckedCreateNestedManyWithoutIdeaInput = {
    create?: XOR<Enumerable<RatingCreateWithoutIdeaInput>, Enumerable<RatingUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutIdeaInput>
    createMany?: RatingCreateManyIdeaInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
  }

  export type ProjectUncheckedCreateNestedOneWithoutIdeaInput = {
    create?: XOR<ProjectCreateWithoutIdeaInput, ProjectUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutIdeaInput
    connect?: ProjectWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedOneWithoutIdeaInput = {
    create?: XOR<AddressCreateWithoutIdeaInput, AddressUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: AddressCreateOrConnectWithoutIdeaInput
    connect?: AddressWhereUniqueInput
  }

  export type GeoUncheckedCreateNestedOneWithoutIdeaInput = {
    create?: XOR<GeoCreateWithoutIdeaInput, GeoUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: GeoCreateOrConnectWithoutIdeaInput
    connect?: GeoWhereUniqueInput
  }

  export type EnumIdeaStateFieldUpdateOperationsInput = {
    set?: IdeaState
  }

  export type CommentUpdateManyWithoutIdeaInput = {
    create?: XOR<Enumerable<CommentCreateWithoutIdeaInput>, Enumerable<CommentUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutIdeaInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutIdeaInput>
    createMany?: CommentCreateManyIdeaInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutIdeaInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutIdeaInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type RatingUpdateManyWithoutIdeaInput = {
    create?: XOR<Enumerable<RatingCreateWithoutIdeaInput>, Enumerable<RatingUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutIdeaInput>
    upsert?: Enumerable<RatingUpsertWithWhereUniqueWithoutIdeaInput>
    createMany?: RatingCreateManyIdeaInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
    set?: Enumerable<RatingWhereUniqueInput>
    disconnect?: Enumerable<RatingWhereUniqueInput>
    delete?: Enumerable<RatingWhereUniqueInput>
    update?: Enumerable<RatingUpdateWithWhereUniqueWithoutIdeaInput>
    updateMany?: Enumerable<RatingUpdateManyWithWhereWithoutIdeaInput>
    deleteMany?: Enumerable<RatingScalarWhereInput>
  }

  export type ProjectUpdateOneWithoutIdeaInput = {
    create?: XOR<ProjectCreateWithoutIdeaInput, ProjectUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutIdeaInput
    upsert?: ProjectUpsertWithoutIdeaInput
    connect?: ProjectWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProjectUpdateWithoutIdeaInput, ProjectUncheckedUpdateWithoutIdeaInput>
  }

  export type AddressUpdateOneWithoutIdeaInput = {
    create?: XOR<AddressCreateWithoutIdeaInput, AddressUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: AddressCreateOrConnectWithoutIdeaInput
    upsert?: AddressUpsertWithoutIdeaInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutIdeaInput, AddressUncheckedUpdateWithoutIdeaInput>
  }

  export type GeoUpdateOneWithoutIdeaInput = {
    create?: XOR<GeoCreateWithoutIdeaInput, GeoUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: GeoCreateOrConnectWithoutIdeaInput
    upsert?: GeoUpsertWithoutIdeaInput
    connect?: GeoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GeoUpdateWithoutIdeaInput, GeoUncheckedUpdateWithoutIdeaInput>
  }

  export type UserUpdateOneRequiredWithoutIdeasInput = {
    create?: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeasInput
    upsert?: UserUpsertWithoutIdeasInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIdeasInput, UserUncheckedUpdateWithoutIdeasInput>
  }

  export type UserUpdateOneWithoutChampionedIdeasInput = {
    create?: XOR<UserCreateWithoutChampionedIdeasInput, UserUncheckedCreateWithoutChampionedIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionedIdeasInput
    upsert?: UserUpsertWithoutChampionedIdeasInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutChampionedIdeasInput, UserUncheckedUpdateWithoutChampionedIdeasInput>
  }

  export type CategoryUpdateOneRequiredWithoutIdeasInput = {
    create?: XOR<CategoryCreateWithoutIdeasInput, CategoryUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutIdeasInput
    upsert?: CategoryUpsertWithoutIdeasInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutIdeasInput, CategoryUncheckedUpdateWithoutIdeasInput>
  }

  export type SuperSegmentUpdateOneRequiredWithoutIdeaInput = {
    create?: XOR<SuperSegmentCreateWithoutIdeaInput, SuperSegmentUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutIdeaInput
    upsert?: SuperSegmentUpsertWithoutIdeaInput
    connect?: SuperSegmentWhereUniqueInput
    update?: XOR<SuperSegmentUpdateWithoutIdeaInput, SuperSegmentUncheckedUpdateWithoutIdeaInput>
  }

  export type SegmentsUpdateOneWithoutIdeaInput = {
    create?: XOR<SegmentsCreateWithoutIdeaInput, SegmentsUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutIdeaInput
    upsert?: SegmentsUpsertWithoutIdeaInput
    connect?: SegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SegmentsUpdateWithoutIdeaInput, SegmentsUncheckedUpdateWithoutIdeaInput>
  }

  export type SubSegmentsUpdateOneWithoutIdeaInput = {
    create?: XOR<SubSegmentsCreateWithoutIdeaInput, SubSegmentsUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutIdeaInput
    upsert?: SubSegmentsUpsertWithoutIdeaInput
    connect?: SubSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubSegmentsUpdateWithoutIdeaInput, SubSegmentsUncheckedUpdateWithoutIdeaInput>
  }

  export type CommentUncheckedUpdateManyWithoutIdeaInput = {
    create?: XOR<Enumerable<CommentCreateWithoutIdeaInput>, Enumerable<CommentUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutIdeaInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutIdeaInput>
    createMany?: CommentCreateManyIdeaInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutIdeaInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutIdeaInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type RatingUncheckedUpdateManyWithoutIdeaInput = {
    create?: XOR<Enumerable<RatingCreateWithoutIdeaInput>, Enumerable<RatingUncheckedCreateWithoutIdeaInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutIdeaInput>
    upsert?: Enumerable<RatingUpsertWithWhereUniqueWithoutIdeaInput>
    createMany?: RatingCreateManyIdeaInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
    set?: Enumerable<RatingWhereUniqueInput>
    disconnect?: Enumerable<RatingWhereUniqueInput>
    delete?: Enumerable<RatingWhereUniqueInput>
    update?: Enumerable<RatingUpdateWithWhereUniqueWithoutIdeaInput>
    updateMany?: Enumerable<RatingUpdateManyWithWhereWithoutIdeaInput>
    deleteMany?: Enumerable<RatingScalarWhereInput>
  }

  export type ProjectUncheckedUpdateOneWithoutIdeaInput = {
    create?: XOR<ProjectCreateWithoutIdeaInput, ProjectUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutIdeaInput
    upsert?: ProjectUpsertWithoutIdeaInput
    connect?: ProjectWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProjectUpdateWithoutIdeaInput, ProjectUncheckedUpdateWithoutIdeaInput>
  }

  export type AddressUncheckedUpdateOneWithoutIdeaInput = {
    create?: XOR<AddressCreateWithoutIdeaInput, AddressUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: AddressCreateOrConnectWithoutIdeaInput
    upsert?: AddressUpsertWithoutIdeaInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutIdeaInput, AddressUncheckedUpdateWithoutIdeaInput>
  }

  export type GeoUncheckedUpdateOneWithoutIdeaInput = {
    create?: XOR<GeoCreateWithoutIdeaInput, GeoUncheckedCreateWithoutIdeaInput>
    connectOrCreate?: GeoCreateOrConnectWithoutIdeaInput
    upsert?: GeoUpsertWithoutIdeaInput
    connect?: GeoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GeoUpdateWithoutIdeaInput, GeoUncheckedUpdateWithoutIdeaInput>
  }

  export type CommentCreateNestedManyWithoutProposalInput = {
    create?: XOR<Enumerable<CommentCreateWithoutProposalInput>, Enumerable<CommentUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutProposalInput>
    createMany?: CommentCreateManyProposalInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type RatingCreateNestedManyWithoutProposalInput = {
    create?: XOR<Enumerable<RatingCreateWithoutProposalInput>, Enumerable<RatingUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutProposalInput>
    createMany?: RatingCreateManyProposalInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
  }

  export type AddressCreateNestedOneWithoutProposalInput = {
    create?: XOR<AddressCreateWithoutProposalInput, AddressUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProposalInput
    connect?: AddressWhereUniqueInput
  }

  export type GeoCreateNestedOneWithoutProposalInput = {
    create?: XOR<GeoCreateWithoutProposalInput, GeoUncheckedCreateWithoutProposalInput>
    connectOrCreate?: GeoCreateOrConnectWithoutProposalInput
    connect?: GeoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProposalsInput = {
    create?: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProposalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChampionedProposalsInput = {
    create?: XOR<UserCreateWithoutChampionedProposalsInput, UserUncheckedCreateWithoutChampionedProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionedProposalsInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProposalsInput = {
    create?: XOR<CategoryCreateWithoutProposalsInput, CategoryUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProposalsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SuperSegmentCreateNestedOneWithoutProposalInput = {
    create?: XOR<SuperSegmentCreateWithoutProposalInput, SuperSegmentUncheckedCreateWithoutProposalInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutProposalInput
    connect?: SuperSegmentWhereUniqueInput
  }

  export type SegmentsCreateNestedOneWithoutProposalInput = {
    create?: XOR<SegmentsCreateWithoutProposalInput, SegmentsUncheckedCreateWithoutProposalInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutProposalInput
    connect?: SegmentsWhereUniqueInput
  }

  export type SubSegmentsCreateNestedOneWithoutProposalInput = {
    create?: XOR<SubSegmentsCreateWithoutProposalInput, SubSegmentsUncheckedCreateWithoutProposalInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutProposalInput
    connect?: SubSegmentsWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<Enumerable<CommentCreateWithoutProposalInput>, Enumerable<CommentUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutProposalInput>
    createMany?: CommentCreateManyProposalInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type RatingUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<Enumerable<RatingCreateWithoutProposalInput>, Enumerable<RatingUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutProposalInput>
    createMany?: RatingCreateManyProposalInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedOneWithoutProposalInput = {
    create?: XOR<AddressCreateWithoutProposalInput, AddressUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProposalInput
    connect?: AddressWhereUniqueInput
  }

  export type GeoUncheckedCreateNestedOneWithoutProposalInput = {
    create?: XOR<GeoCreateWithoutProposalInput, GeoUncheckedCreateWithoutProposalInput>
    connectOrCreate?: GeoCreateOrConnectWithoutProposalInput
    connect?: GeoWhereUniqueInput
  }

  export type CommentUpdateManyWithoutProposalInput = {
    create?: XOR<Enumerable<CommentCreateWithoutProposalInput>, Enumerable<CommentUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutProposalInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutProposalInput>
    createMany?: CommentCreateManyProposalInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutProposalInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutProposalInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type RatingUpdateManyWithoutProposalInput = {
    create?: XOR<Enumerable<RatingCreateWithoutProposalInput>, Enumerable<RatingUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutProposalInput>
    upsert?: Enumerable<RatingUpsertWithWhereUniqueWithoutProposalInput>
    createMany?: RatingCreateManyProposalInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
    set?: Enumerable<RatingWhereUniqueInput>
    disconnect?: Enumerable<RatingWhereUniqueInput>
    delete?: Enumerable<RatingWhereUniqueInput>
    update?: Enumerable<RatingUpdateWithWhereUniqueWithoutProposalInput>
    updateMany?: Enumerable<RatingUpdateManyWithWhereWithoutProposalInput>
    deleteMany?: Enumerable<RatingScalarWhereInput>
  }

  export type AddressUpdateOneWithoutProposalInput = {
    create?: XOR<AddressCreateWithoutProposalInput, AddressUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProposalInput
    upsert?: AddressUpsertWithoutProposalInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutProposalInput, AddressUncheckedUpdateWithoutProposalInput>
  }

  export type GeoUpdateOneWithoutProposalInput = {
    create?: XOR<GeoCreateWithoutProposalInput, GeoUncheckedCreateWithoutProposalInput>
    connectOrCreate?: GeoCreateOrConnectWithoutProposalInput
    upsert?: GeoUpsertWithoutProposalInput
    connect?: GeoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GeoUpdateWithoutProposalInput, GeoUncheckedUpdateWithoutProposalInput>
  }

  export type UserUpdateOneRequiredWithoutProposalsInput = {
    create?: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProposalsInput
    upsert?: UserUpsertWithoutProposalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProposalsInput, UserUncheckedUpdateWithoutProposalsInput>
  }

  export type UserUpdateOneWithoutChampionedProposalsInput = {
    create?: XOR<UserCreateWithoutChampionedProposalsInput, UserUncheckedCreateWithoutChampionedProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChampionedProposalsInput
    upsert?: UserUpsertWithoutChampionedProposalsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutChampionedProposalsInput, UserUncheckedUpdateWithoutChampionedProposalsInput>
  }

  export type CategoryUpdateOneRequiredWithoutProposalsInput = {
    create?: XOR<CategoryCreateWithoutProposalsInput, CategoryUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProposalsInput
    upsert?: CategoryUpsertWithoutProposalsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutProposalsInput, CategoryUncheckedUpdateWithoutProposalsInput>
  }

  export type SuperSegmentUpdateOneRequiredWithoutProposalInput = {
    create?: XOR<SuperSegmentCreateWithoutProposalInput, SuperSegmentUncheckedCreateWithoutProposalInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutProposalInput
    upsert?: SuperSegmentUpsertWithoutProposalInput
    connect?: SuperSegmentWhereUniqueInput
    update?: XOR<SuperSegmentUpdateWithoutProposalInput, SuperSegmentUncheckedUpdateWithoutProposalInput>
  }

  export type SegmentsUpdateOneWithoutProposalInput = {
    create?: XOR<SegmentsCreateWithoutProposalInput, SegmentsUncheckedCreateWithoutProposalInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutProposalInput
    upsert?: SegmentsUpsertWithoutProposalInput
    connect?: SegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SegmentsUpdateWithoutProposalInput, SegmentsUncheckedUpdateWithoutProposalInput>
  }

  export type SubSegmentsUpdateOneWithoutProposalInput = {
    create?: XOR<SubSegmentsCreateWithoutProposalInput, SubSegmentsUncheckedCreateWithoutProposalInput>
    connectOrCreate?: SubSegmentsCreateOrConnectWithoutProposalInput
    upsert?: SubSegmentsUpsertWithoutProposalInput
    connect?: SubSegmentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SubSegmentsUpdateWithoutProposalInput, SubSegmentsUncheckedUpdateWithoutProposalInput>
  }

  export type CommentUncheckedUpdateManyWithoutProposalInput = {
    create?: XOR<Enumerable<CommentCreateWithoutProposalInput>, Enumerable<CommentUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutProposalInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutProposalInput>
    createMany?: CommentCreateManyProposalInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutProposalInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutProposalInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type RatingUncheckedUpdateManyWithoutProposalInput = {
    create?: XOR<Enumerable<RatingCreateWithoutProposalInput>, Enumerable<RatingUncheckedCreateWithoutProposalInput>>
    connectOrCreate?: Enumerable<RatingCreateOrConnectWithoutProposalInput>
    upsert?: Enumerable<RatingUpsertWithWhereUniqueWithoutProposalInput>
    createMany?: RatingCreateManyProposalInputEnvelope
    connect?: Enumerable<RatingWhereUniqueInput>
    set?: Enumerable<RatingWhereUniqueInput>
    disconnect?: Enumerable<RatingWhereUniqueInput>
    delete?: Enumerable<RatingWhereUniqueInput>
    update?: Enumerable<RatingUpdateWithWhereUniqueWithoutProposalInput>
    updateMany?: Enumerable<RatingUpdateManyWithWhereWithoutProposalInput>
    deleteMany?: Enumerable<RatingScalarWhereInput>
  }

  export type AddressUncheckedUpdateOneWithoutProposalInput = {
    create?: XOR<AddressCreateWithoutProposalInput, AddressUncheckedCreateWithoutProposalInput>
    connectOrCreate?: AddressCreateOrConnectWithoutProposalInput
    upsert?: AddressUpsertWithoutProposalInput
    connect?: AddressWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<AddressUpdateWithoutProposalInput, AddressUncheckedUpdateWithoutProposalInput>
  }

  export type GeoUncheckedUpdateOneWithoutProposalInput = {
    create?: XOR<GeoCreateWithoutProposalInput, GeoUncheckedCreateWithoutProposalInput>
    connectOrCreate?: GeoCreateOrConnectWithoutProposalInput
    upsert?: GeoUpsertWithoutProposalInput
    connect?: GeoWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GeoUpdateWithoutProposalInput, GeoUncheckedUpdateWithoutProposalInput>
  }

  export type IdeaCreateNestedOneWithoutProjectInfoInput = {
    create?: XOR<IdeaCreateWithoutProjectInfoInput, IdeaUncheckedCreateWithoutProjectInfoInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutProjectInfoInput
    connect?: IdeaWhereUniqueInput
  }

  export type IdeaUpdateOneRequiredWithoutProjectInfoInput = {
    create?: XOR<IdeaCreateWithoutProjectInfoInput, IdeaUncheckedCreateWithoutProjectInfoInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutProjectInfoInput
    upsert?: IdeaUpsertWithoutProjectInfoInput
    connect?: IdeaWhereUniqueInput
    update?: XOR<IdeaUpdateWithoutProjectInfoInput, IdeaUncheckedUpdateWithoutProjectInfoInput>
  }

  export type UserCreateNestedOneWithoutIdeaRatingsInput = {
    create?: XOR<UserCreateWithoutIdeaRatingsInput, UserUncheckedCreateWithoutIdeaRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type IdeaCreateNestedOneWithoutRatingsInput = {
    create?: XOR<IdeaCreateWithoutRatingsInput, IdeaUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutRatingsInput
    connect?: IdeaWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ProposalCreateWithoutRatingsInput, ProposalUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutRatingsInput
    connect?: ProposalWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIdeaRatingsInput = {
    create?: XOR<UserCreateWithoutIdeaRatingsInput, UserUncheckedCreateWithoutIdeaRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaRatingsInput
    upsert?: UserUpsertWithoutIdeaRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIdeaRatingsInput, UserUncheckedUpdateWithoutIdeaRatingsInput>
  }

  export type IdeaUpdateOneWithoutRatingsInput = {
    create?: XOR<IdeaCreateWithoutRatingsInput, IdeaUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutRatingsInput
    upsert?: IdeaUpsertWithoutRatingsInput
    connect?: IdeaWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<IdeaUpdateWithoutRatingsInput, IdeaUncheckedUpdateWithoutRatingsInput>
  }

  export type ProposalUpdateOneWithoutRatingsInput = {
    create?: XOR<ProposalCreateWithoutRatingsInput, ProposalUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutRatingsInput
    upsert?: ProposalUpsertWithoutRatingsInput
    connect?: ProposalWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProposalUpdateWithoutRatingsInput, ProposalUncheckedUpdateWithoutRatingsInput>
  }

  export type UserCreateNestedOneWithoutIdeaCommentsInput = {
    create?: XOR<UserCreateWithoutIdeaCommentsInput, UserUncheckedCreateWithoutIdeaCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type IdeaCreateNestedOneWithoutCommentsInput = {
    create?: XOR<IdeaCreateWithoutCommentsInput, IdeaUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutCommentsInput
    connect?: IdeaWhereUniqueInput
  }

  export type ProposalCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProposalCreateWithoutCommentsInput, ProposalUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutCommentsInput
    connect?: ProposalWhereUniqueInput
  }

  export type UserSegmentsCreateNestedOneWithoutIdeaCommentInput = {
    create?: XOR<UserSegmentsCreateWithoutIdeaCommentInput, UserSegmentsUncheckedCreateWithoutIdeaCommentInput>
    connectOrCreate?: UserSegmentsCreateOrConnectWithoutIdeaCommentInput
    connect?: UserSegmentsWhereUniqueInput
  }

  export type UserCommentLikesCreateNestedManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutIdeaCommentInput>
    createMany?: UserCommentLikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
  }

  export type UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutIdeaCommentInput>
    createMany?: UserCommentDislikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
  }

  export type UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutIdeaCommentInput>
    createMany?: UserCommentLikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
  }

  export type UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutIdeaCommentInput>
    createMany?: UserCommentDislikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutIdeaCommentsInput = {
    create?: XOR<UserCreateWithoutIdeaCommentsInput, UserUncheckedCreateWithoutIdeaCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaCommentsInput
    upsert?: UserUpsertWithoutIdeaCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIdeaCommentsInput, UserUncheckedUpdateWithoutIdeaCommentsInput>
  }

  export type IdeaUpdateOneWithoutCommentsInput = {
    create?: XOR<IdeaCreateWithoutCommentsInput, IdeaUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutCommentsInput
    upsert?: IdeaUpsertWithoutCommentsInput
    connect?: IdeaWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<IdeaUpdateWithoutCommentsInput, IdeaUncheckedUpdateWithoutCommentsInput>
  }

  export type ProposalUpdateOneWithoutCommentsInput = {
    create?: XOR<ProposalCreateWithoutCommentsInput, ProposalUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutCommentsInput
    upsert?: ProposalUpsertWithoutCommentsInput
    connect?: ProposalWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProposalUpdateWithoutCommentsInput, ProposalUncheckedUpdateWithoutCommentsInput>
  }

  export type UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput = {
    create?: XOR<UserSegmentsCreateWithoutIdeaCommentInput, UserSegmentsUncheckedCreateWithoutIdeaCommentInput>
    connectOrCreate?: UserSegmentsCreateOrConnectWithoutIdeaCommentInput
    upsert?: UserSegmentsUpsertWithoutIdeaCommentInput
    connect?: UserSegmentsWhereUniqueInput
    update?: XOR<UserSegmentsUpdateWithoutIdeaCommentInput, UserSegmentsUncheckedUpdateWithoutIdeaCommentInput>
  }

  export type UserCommentLikesUpdateManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutIdeaCommentInput>
    upsert?: Enumerable<UserCommentLikesUpsertWithWhereUniqueWithoutIdeaCommentInput>
    createMany?: UserCommentLikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
    set?: Enumerable<UserCommentLikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentLikesWhereUniqueInput>
    delete?: Enumerable<UserCommentLikesWhereUniqueInput>
    update?: Enumerable<UserCommentLikesUpdateWithWhereUniqueWithoutIdeaCommentInput>
    updateMany?: Enumerable<UserCommentLikesUpdateManyWithWhereWithoutIdeaCommentInput>
    deleteMany?: Enumerable<UserCommentLikesScalarWhereInput>
  }

  export type UserCommentDislikesUpdateManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutIdeaCommentInput>
    upsert?: Enumerable<UserCommentDislikesUpsertWithWhereUniqueWithoutIdeaCommentInput>
    createMany?: UserCommentDislikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    set?: Enumerable<UserCommentDislikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    delete?: Enumerable<UserCommentDislikesWhereUniqueInput>
    update?: Enumerable<UserCommentDislikesUpdateWithWhereUniqueWithoutIdeaCommentInput>
    updateMany?: Enumerable<UserCommentDislikesUpdateManyWithWhereWithoutIdeaCommentInput>
    deleteMany?: Enumerable<UserCommentDislikesScalarWhereInput>
  }

  export type UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentLikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentLikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentLikesCreateOrConnectWithoutIdeaCommentInput>
    upsert?: Enumerable<UserCommentLikesUpsertWithWhereUniqueWithoutIdeaCommentInput>
    createMany?: UserCommentLikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentLikesWhereUniqueInput>
    set?: Enumerable<UserCommentLikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentLikesWhereUniqueInput>
    delete?: Enumerable<UserCommentLikesWhereUniqueInput>
    update?: Enumerable<UserCommentLikesUpdateWithWhereUniqueWithoutIdeaCommentInput>
    updateMany?: Enumerable<UserCommentLikesUpdateManyWithWhereWithoutIdeaCommentInput>
    deleteMany?: Enumerable<UserCommentLikesScalarWhereInput>
  }

  export type UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput = {
    create?: XOR<Enumerable<UserCommentDislikesCreateWithoutIdeaCommentInput>, Enumerable<UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput>>
    connectOrCreate?: Enumerable<UserCommentDislikesCreateOrConnectWithoutIdeaCommentInput>
    upsert?: Enumerable<UserCommentDislikesUpsertWithWhereUniqueWithoutIdeaCommentInput>
    createMany?: UserCommentDislikesCreateManyIdeaCommentInputEnvelope
    connect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    set?: Enumerable<UserCommentDislikesWhereUniqueInput>
    disconnect?: Enumerable<UserCommentDislikesWhereUniqueInput>
    delete?: Enumerable<UserCommentDislikesWhereUniqueInput>
    update?: Enumerable<UserCommentDislikesUpdateWithWhereUniqueWithoutIdeaCommentInput>
    updateMany?: Enumerable<UserCommentDislikesUpdateManyWithWhereWithoutIdeaCommentInput>
    deleteMany?: Enumerable<UserCommentDislikesScalarWhereInput>
  }

  export type CommentCreateNestedOneWithoutLikesInput = {
    create?: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIdeaCommentLikesInput = {
    create?: XOR<UserCreateWithoutIdeaCommentLikesInput, UserUncheckedCreateWithoutIdeaCommentLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaCommentLikesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneWithoutLikesInput = {
    create?: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutLikesInput
    upsert?: CommentUpsertWithoutLikesInput
    connect?: CommentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CommentUpdateWithoutLikesInput, CommentUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneWithoutIdeaCommentLikesInput = {
    create?: XOR<UserCreateWithoutIdeaCommentLikesInput, UserUncheckedCreateWithoutIdeaCommentLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaCommentLikesInput
    upsert?: UserUpsertWithoutIdeaCommentLikesInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutIdeaCommentLikesInput, UserUncheckedUpdateWithoutIdeaCommentLikesInput>
  }

  export type CommentCreateNestedOneWithoutDislikesInput = {
    create?: XOR<CommentCreateWithoutDislikesInput, CommentUncheckedCreateWithoutDislikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutDislikesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIdeaCommentDislikesInput = {
    create?: XOR<UserCreateWithoutIdeaCommentDislikesInput, UserUncheckedCreateWithoutIdeaCommentDislikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaCommentDislikesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneWithoutDislikesInput = {
    create?: XOR<CommentCreateWithoutDislikesInput, CommentUncheckedCreateWithoutDislikesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutDislikesInput
    upsert?: CommentUpsertWithoutDislikesInput
    connect?: CommentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CommentUpdateWithoutDislikesInput, CommentUncheckedUpdateWithoutDislikesInput>
  }

  export type UserUpdateOneWithoutIdeaCommentDislikesInput = {
    create?: XOR<UserCreateWithoutIdeaCommentDislikesInput, UserUncheckedCreateWithoutIdeaCommentDislikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeaCommentDislikesInput
    upsert?: UserUpsertWithoutIdeaCommentDislikesInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutIdeaCommentDislikesInput, UserUncheckedUpdateWithoutIdeaCommentDislikesInput>
  }

  export type UserCreateNestedOneWithoutAdvertisementsInput = {
    create?: XOR<UserCreateWithoutAdvertisementsInput, UserUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvertisementsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumAdTypeFieldUpdateOperationsInput = {
    set?: AdType
  }

  export type UserUpdateOneWithoutAdvertisementsInput = {
    create?: XOR<UserCreateWithoutAdvertisementsInput, UserUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdvertisementsInput
    upsert?: UserUpsertWithoutAdvertisementsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutAdvertisementsInput, UserUncheckedUpdateWithoutAdvertisementsInput>
  }

  export type SegmentsCreateNestedManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<SegmentsCreateWithoutSuperSegmentInput>, Enumerable<SegmentsUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<SegmentsCreateOrConnectWithoutSuperSegmentInput>
    createMany?: SegmentsCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<SegmentsWhereUniqueInput>
  }

  export type IdeaCreateNestedManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSuperSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSuperSegmentInput>
    createMany?: IdeaCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalCreateNestedManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSuperSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSuperSegmentInput>
    createMany?: ProposalCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutHomeSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSuperSegInput>
    createMany?: UserSegmentsCreateManyHomeSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutWorkSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSuperSegInput>
    createMany?: UserSegmentsCreateManyWorkSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSuperSegInput>
    createMany?: UserSegmentsCreateManySchoolSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<SegmentsCreateWithoutSuperSegmentInput>, Enumerable<SegmentsUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<SegmentsCreateOrConnectWithoutSuperSegmentInput>
    createMany?: SegmentsCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<SegmentsWhereUniqueInput>
  }

  export type IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSuperSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSuperSegmentInput>
    createMany?: IdeaCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSuperSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSuperSegmentInput>
    createMany?: ProposalCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSuperSegInput>
    createMany?: UserSegmentsCreateManyHomeSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSuperSegInput>
    createMany?: UserSegmentsCreateManyWorkSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSuperSegInput>
    createMany?: UserSegmentsCreateManySchoolSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type SegmentsUpdateManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<SegmentsCreateWithoutSuperSegmentInput>, Enumerable<SegmentsUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<SegmentsCreateOrConnectWithoutSuperSegmentInput>
    upsert?: Enumerable<SegmentsUpsertWithWhereUniqueWithoutSuperSegmentInput>
    createMany?: SegmentsCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<SegmentsWhereUniqueInput>
    set?: Enumerable<SegmentsWhereUniqueInput>
    disconnect?: Enumerable<SegmentsWhereUniqueInput>
    delete?: Enumerable<SegmentsWhereUniqueInput>
    update?: Enumerable<SegmentsUpdateWithWhereUniqueWithoutSuperSegmentInput>
    updateMany?: Enumerable<SegmentsUpdateManyWithWhereWithoutSuperSegmentInput>
    deleteMany?: Enumerable<SegmentsScalarWhereInput>
  }

  export type IdeaUpdateManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSuperSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSuperSegmentInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutSuperSegmentInput>
    createMany?: IdeaCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutSuperSegmentInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutSuperSegmentInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUpdateManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSuperSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSuperSegmentInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutSuperSegmentInput>
    createMany?: ProposalCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutSuperSegmentInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutSuperSegmentInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutHomeSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSuperSegInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutHomeSuperSegInput>
    createMany?: UserSegmentsCreateManyHomeSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutHomeSuperSegInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutHomeSuperSegInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutWorkSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSuperSegInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutWorkSuperSegInput>
    createMany?: UserSegmentsCreateManyWorkSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutWorkSuperSegInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutWorkSuperSegInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutSchoolSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSuperSegInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutSchoolSuperSegInput>
    createMany?: UserSegmentsCreateManySchoolSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutSchoolSuperSegInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutSchoolSuperSegInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type SegmentsUncheckedUpdateManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<SegmentsCreateWithoutSuperSegmentInput>, Enumerable<SegmentsUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<SegmentsCreateOrConnectWithoutSuperSegmentInput>
    upsert?: Enumerable<SegmentsUpsertWithWhereUniqueWithoutSuperSegmentInput>
    createMany?: SegmentsCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<SegmentsWhereUniqueInput>
    set?: Enumerable<SegmentsWhereUniqueInput>
    disconnect?: Enumerable<SegmentsWhereUniqueInput>
    delete?: Enumerable<SegmentsWhereUniqueInput>
    update?: Enumerable<SegmentsUpdateWithWhereUniqueWithoutSuperSegmentInput>
    updateMany?: Enumerable<SegmentsUpdateManyWithWhereWithoutSuperSegmentInput>
    deleteMany?: Enumerable<SegmentsScalarWhereInput>
  }

  export type IdeaUncheckedUpdateManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSuperSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSuperSegmentInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutSuperSegmentInput>
    createMany?: IdeaCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutSuperSegmentInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutSuperSegmentInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUncheckedUpdateManyWithoutSuperSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSuperSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSuperSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSuperSegmentInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutSuperSegmentInput>
    createMany?: ProposalCreateManySuperSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutSuperSegmentInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutSuperSegmentInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSuperSegInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutHomeSuperSegInput>
    createMany?: UserSegmentsCreateManyHomeSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutHomeSuperSegInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutHomeSuperSegInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSuperSegInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutWorkSuperSegInput>
    createMany?: UserSegmentsCreateManyWorkSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutWorkSuperSegInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutWorkSuperSegInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSuperSegInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSuperSegInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutSchoolSuperSegInput>
    createMany?: UserSegmentsCreateManySchoolSuperSegInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutSchoolSuperSegInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutSchoolSuperSegInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type SuperSegmentCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutSegmentsInput, SuperSegmentUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
  }

  export type SubSegmentsCreateNestedManyWithoutSegRefInput = {
    create?: XOR<Enumerable<SubSegmentsCreateWithoutSegRefInput>, Enumerable<SubSegmentsUncheckedCreateWithoutSegRefInput>>
    connectOrCreate?: Enumerable<SubSegmentsCreateOrConnectWithoutSegRefInput>
    createMany?: SubSegmentsCreateManySegRefInputEnvelope
    connect?: Enumerable<SubSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutHomeSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutWorkSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutSchoolSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type IdeaCreateNestedManyWithoutSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSegmentInput>
    createMany?: IdeaCreateManySegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalCreateNestedManyWithoutSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSegmentInput>
    createMany?: ProposalCreateManySegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput = {
    create?: XOR<Enumerable<SubSegmentsCreateWithoutSegRefInput>, Enumerable<SubSegmentsUncheckedCreateWithoutSegRefInput>>
    connectOrCreate?: Enumerable<SubSegmentsCreateOrConnectWithoutSegRefInput>
    createMany?: SubSegmentsCreateManySegRefInputEnvelope
    connect?: Enumerable<SubSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type IdeaUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSegmentInput>
    createMany?: IdeaCreateManySegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSegmentInput>
    createMany?: ProposalCreateManySegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type SuperSegmentUpdateOneRequiredWithoutSegmentsInput = {
    create?: XOR<SuperSegmentCreateWithoutSegmentsInput, SuperSegmentUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: SuperSegmentCreateOrConnectWithoutSegmentsInput
    upsert?: SuperSegmentUpsertWithoutSegmentsInput
    connect?: SuperSegmentWhereUniqueInput
    update?: XOR<SuperSegmentUpdateWithoutSegmentsInput, SuperSegmentUncheckedUpdateWithoutSegmentsInput>
  }

  export type SubSegmentsUpdateManyWithoutSegRefInput = {
    create?: XOR<Enumerable<SubSegmentsCreateWithoutSegRefInput>, Enumerable<SubSegmentsUncheckedCreateWithoutSegRefInput>>
    connectOrCreate?: Enumerable<SubSegmentsCreateOrConnectWithoutSegRefInput>
    upsert?: Enumerable<SubSegmentsUpsertWithWhereUniqueWithoutSegRefInput>
    createMany?: SubSegmentsCreateManySegRefInputEnvelope
    connect?: Enumerable<SubSegmentsWhereUniqueInput>
    set?: Enumerable<SubSegmentsWhereUniqueInput>
    disconnect?: Enumerable<SubSegmentsWhereUniqueInput>
    delete?: Enumerable<SubSegmentsWhereUniqueInput>
    update?: Enumerable<SubSegmentsUpdateWithWhereUniqueWithoutSegRefInput>
    updateMany?: Enumerable<SubSegmentsUpdateManyWithWhereWithoutSegRefInput>
    deleteMany?: Enumerable<SubSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutHomeSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutHomeSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutHomeSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutHomeSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutWorkSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutWorkSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutWorkSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutWorkSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutSchoolSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutSchoolSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutSchoolSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutSchoolSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type IdeaUpdateManyWithoutSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSegmentInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutSegmentInput>
    createMany?: IdeaCreateManySegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutSegmentInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutSegmentInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUpdateManyWithoutSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSegmentInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutSegmentInput>
    createMany?: ProposalCreateManySegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutSegmentInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutSegmentInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type SubSegmentsUncheckedUpdateManyWithoutSegRefInput = {
    create?: XOR<Enumerable<SubSegmentsCreateWithoutSegRefInput>, Enumerable<SubSegmentsUncheckedCreateWithoutSegRefInput>>
    connectOrCreate?: Enumerable<SubSegmentsCreateOrConnectWithoutSegRefInput>
    upsert?: Enumerable<SubSegmentsUpsertWithWhereUniqueWithoutSegRefInput>
    createMany?: SubSegmentsCreateManySegRefInputEnvelope
    connect?: Enumerable<SubSegmentsWhereUniqueInput>
    set?: Enumerable<SubSegmentsWhereUniqueInput>
    disconnect?: Enumerable<SubSegmentsWhereUniqueInput>
    delete?: Enumerable<SubSegmentsWhereUniqueInput>
    update?: Enumerable<SubSegmentsUpdateWithWhereUniqueWithoutSegRefInput>
    updateMany?: Enumerable<SubSegmentsUpdateManyWithWhereWithoutSegRefInput>
    deleteMany?: Enumerable<SubSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutHomeSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutHomeSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutHomeSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutWorkSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutWorkSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutWorkSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutSchoolSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutSchoolSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutSchoolSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type IdeaUncheckedUpdateManyWithoutSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSegmentInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutSegmentInput>
    createMany?: IdeaCreateManySegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutSegmentInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutSegmentInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUncheckedUpdateManyWithoutSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSegmentInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutSegmentInput>
    createMany?: ProposalCreateManySegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutSegmentInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutSegmentInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type SegmentsCreateNestedOneWithoutSubSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutSubSegmentsInput, SegmentsUncheckedCreateWithoutSubSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutSubSegmentsInput
    connect?: SegmentsWhereUniqueInput
  }

  export type UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSubSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSubSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSubSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type IdeaCreateNestedManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSubSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSubSegmentInput>
    createMany?: IdeaCreateManySubSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalCreateNestedManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSubSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSubSegmentInput>
    createMany?: ProposalCreateManySubSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSubSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSubSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSubSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
  }

  export type IdeaUncheckedCreateNestedManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSubSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSubSegmentInput>
    createMany?: IdeaCreateManySubSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
  }

  export type ProposalUncheckedCreateNestedManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSubSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSubSegmentInput>
    createMany?: ProposalCreateManySubSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
  }

  export type SegmentsUpdateOneRequiredWithoutSubSegmentsInput = {
    create?: XOR<SegmentsCreateWithoutSubSegmentsInput, SegmentsUncheckedCreateWithoutSubSegmentsInput>
    connectOrCreate?: SegmentsCreateOrConnectWithoutSubSegmentsInput
    upsert?: SegmentsUpsertWithoutSubSegmentsInput
    connect?: SegmentsWhereUniqueInput
    update?: XOR<SegmentsUpdateWithoutSubSegmentsInput, SegmentsUncheckedUpdateWithoutSubSegmentsInput>
  }

  export type UserSegmentsUpdateManyWithoutHomeSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSubSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutHomeSubSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutHomeSubSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutHomeSubSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutWorkSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSubSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutWorkSubSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutWorkSubSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutWorkSubSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUpdateManyWithoutSchoolSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSubSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutSchoolSubSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutSchoolSubSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutSchoolSubSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type IdeaUpdateManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSubSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSubSegmentInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutSubSegmentInput>
    createMany?: IdeaCreateManySubSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutSubSegmentInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutSubSegmentInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUpdateManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSubSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSubSegmentInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutSubSegmentInput>
    createMany?: ProposalCreateManySubSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutSubSegmentInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutSubSegmentInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutHomeSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutHomeSubSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutHomeSubSegmentInput>
    createMany?: UserSegmentsCreateManyHomeSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutHomeSubSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutHomeSubSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutWorkSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutWorkSubSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutWorkSubSegmentInput>
    createMany?: UserSegmentsCreateManyWorkSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutWorkSubSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutWorkSubSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput = {
    create?: XOR<Enumerable<UserSegmentsCreateWithoutSchoolSubSegmentInput>, Enumerable<UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput>>
    connectOrCreate?: Enumerable<UserSegmentsCreateOrConnectWithoutSchoolSubSegmentInput>
    upsert?: Enumerable<UserSegmentsUpsertWithWhereUniqueWithoutSchoolSubSegmentInput>
    createMany?: UserSegmentsCreateManySchoolSubSegmentInputEnvelope
    connect?: Enumerable<UserSegmentsWhereUniqueInput>
    set?: Enumerable<UserSegmentsWhereUniqueInput>
    disconnect?: Enumerable<UserSegmentsWhereUniqueInput>
    delete?: Enumerable<UserSegmentsWhereUniqueInput>
    update?: Enumerable<UserSegmentsUpdateWithWhereUniqueWithoutSchoolSubSegmentInput>
    updateMany?: Enumerable<UserSegmentsUpdateManyWithWhereWithoutSchoolSubSegmentInput>
    deleteMany?: Enumerable<UserSegmentsScalarWhereInput>
  }

  export type IdeaUncheckedUpdateManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<IdeaCreateWithoutSubSegmentInput>, Enumerable<IdeaUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<IdeaCreateOrConnectWithoutSubSegmentInput>
    upsert?: Enumerable<IdeaUpsertWithWhereUniqueWithoutSubSegmentInput>
    createMany?: IdeaCreateManySubSegmentInputEnvelope
    connect?: Enumerable<IdeaWhereUniqueInput>
    set?: Enumerable<IdeaWhereUniqueInput>
    disconnect?: Enumerable<IdeaWhereUniqueInput>
    delete?: Enumerable<IdeaWhereUniqueInput>
    update?: Enumerable<IdeaUpdateWithWhereUniqueWithoutSubSegmentInput>
    updateMany?: Enumerable<IdeaUpdateManyWithWhereWithoutSubSegmentInput>
    deleteMany?: Enumerable<IdeaScalarWhereInput>
  }

  export type ProposalUncheckedUpdateManyWithoutSubSegmentInput = {
    create?: XOR<Enumerable<ProposalCreateWithoutSubSegmentInput>, Enumerable<ProposalUncheckedCreateWithoutSubSegmentInput>>
    connectOrCreate?: Enumerable<ProposalCreateOrConnectWithoutSubSegmentInput>
    upsert?: Enumerable<ProposalUpsertWithWhereUniqueWithoutSubSegmentInput>
    createMany?: ProposalCreateManySubSegmentInputEnvelope
    connect?: Enumerable<ProposalWhereUniqueInput>
    set?: Enumerable<ProposalWhereUniqueInput>
    disconnect?: Enumerable<ProposalWhereUniqueInput>
    delete?: Enumerable<ProposalWhereUniqueInput>
    update?: Enumerable<ProposalUpdateWithWhereUniqueWithoutSubSegmentInput>
    updateMany?: Enumerable<ProposalUpdateManyWithWhereWithoutSubSegmentInput>
    deleteMany?: Enumerable<ProposalScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutSegmentRequestInput = {
    create?: XOR<UserCreateWithoutSegmentRequestInput, UserUncheckedCreateWithoutSegmentRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutSegmentRequestInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSegmentRequestInput = {
    create?: XOR<UserCreateWithoutSegmentRequestInput, UserUncheckedCreateWithoutSegmentRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutSegmentRequestInput
    upsert?: UserUpsertWithoutSegmentRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSegmentRequestInput, UserUncheckedUpdateWithoutSegmentRequestInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | number | string | null
    count?: NestedIntNullableFilter
    avg?: NestedDecimalNullableFilter
    sum?: NestedDecimalNullableFilter
    min?: NestedDecimalNullableFilter
    max?: NestedDecimalNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type NestedEnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    count?: NestedIntFilter
    min?: NestedEnumUserTypeFilter
    max?: NestedEnumUserTypeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    count?: NestedIntNullableFilter
    avg?: NestedFloatNullableFilter
    sum?: NestedIntNullableFilter
    min?: NestedIntNullableFilter
    max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumIdeaStateFilter = {
    equals?: IdeaState
    in?: Enumerable<IdeaState>
    notIn?: Enumerable<IdeaState>
    not?: NestedEnumIdeaStateFilter | IdeaState
  }

  export type NestedEnumIdeaStateWithAggregatesFilter = {
    equals?: IdeaState
    in?: Enumerable<IdeaState>
    notIn?: Enumerable<IdeaState>
    not?: NestedEnumIdeaStateWithAggregatesFilter | IdeaState
    count?: NestedIntFilter
    min?: NestedEnumIdeaStateFilter
    max?: NestedEnumIdeaStateFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumAdTypeFilter = {
    equals?: AdType
    in?: Enumerable<AdType>
    notIn?: Enumerable<AdType>
    not?: NestedEnumAdTypeFilter | AdType
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    count?: NestedIntNullableFilter
    min?: NestedDateTimeNullableFilter
    max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumAdTypeWithAggregatesFilter = {
    equals?: AdType
    in?: Enumerable<AdType>
    notIn?: Enumerable<AdType>
    not?: NestedEnumAdTypeWithAggregatesFilter | AdType
    count?: NestedIntFilter
    min?: NestedEnumAdTypeFilter
    max?: NestedEnumAdTypeFilter
  }

  export type UserCreateWithoutGeoInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeoInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeoInput, UserUncheckedCreateWithoutGeoInput>
  }

  export type UserUpsertWithoutGeoInput = {
    update: XOR<UserUpdateWithoutGeoInput, UserUncheckedUpdateWithoutGeoInput>
    create: XOR<UserCreateWithoutGeoInput, UserUncheckedCreateWithoutGeoInput>
  }

  export type UserUpdateWithoutGeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutGeoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type UserAddressCreateWithoutUserInput = {
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: number
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserGeoCreateWithoutUserInput = {
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    work_lat?: Decimal | number | string | null
    work_lon?: Decimal | number | string | null
    school_lat?: Decimal | number | string | null
    school_lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGeoUncheckedCreateWithoutUserInput = {
    id?: number
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    work_lat?: Decimal | number | string | null
    work_lon?: Decimal | number | string | null
    school_lat?: Decimal | number | string | null
    school_lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserGeoCreateOrConnectWithoutUserInput = {
    where: UserGeoWhereUniqueInput
    create: XOR<UserGeoCreateWithoutUserInput, UserGeoUncheckedCreateWithoutUserInput>
  }

  export type IdeaCreateWithoutAuthorInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutAuthorInput = {
    id?: number
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutAuthorInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutAuthorInput, IdeaUncheckedCreateWithoutAuthorInput>
  }

  export type IdeaCreateManyAuthorInputEnvelope = {
    data: Enumerable<IdeaCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutAuthorInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutAuthorInput = {
    id?: number
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutAuthorInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutAuthorInput, ProposalUncheckedCreateWithoutAuthorInput>
  }

  export type ProposalCreateManyAuthorInputEnvelope = {
    data: Enumerable<ProposalCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutChampionInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutChampionInput = {
    id?: number
    authorId: string
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutChampionInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutChampionInput, ProposalUncheckedCreateWithoutChampionInput>
  }

  export type ProposalCreateManyChampionInputEnvelope = {
    data: Enumerable<ProposalCreateManyChampionInput>
    skipDuplicates?: boolean
  }

  export type IdeaCreateWithoutChampionInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutChampionInput = {
    id?: number
    authorId: string
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutChampionInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutChampionInput, IdeaUncheckedCreateWithoutChampionInput>
  }

  export type IdeaCreateManyChampionInputEnvelope = {
    data: Enumerable<IdeaCreateManyChampionInput>
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutAuthorInput = {
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idea?: IdeaCreateNestedOneWithoutRatingsInput
    proposal?: ProposalCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutAuthorInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutAuthorInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutAuthorInput, RatingUncheckedCreateWithoutAuthorInput>
  }

  export type RatingCreateManyAuthorInputEnvelope = {
    data: Enumerable<RatingCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    idea?: IdeaCreateNestedOneWithoutCommentsInput
    proposal?: ProposalCreateNestedOneWithoutCommentsInput
    userSeg: UserSegmentsCreateNestedOneWithoutIdeaCommentInput
    likes?: UserCommentLikesCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: Enumerable<CommentCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type UserCommentLikesCreateWithoutAuthorInput = {
    ideaComment?: CommentCreateNestedOneWithoutLikesInput
  }

  export type UserCommentLikesUncheckedCreateWithoutAuthorInput = {
    id?: number
    ideaCommentId?: number | null
  }

  export type UserCommentLikesCreateOrConnectWithoutAuthorInput = {
    where: UserCommentLikesWhereUniqueInput
    create: XOR<UserCommentLikesCreateWithoutAuthorInput, UserCommentLikesUncheckedCreateWithoutAuthorInput>
  }

  export type UserCommentLikesCreateManyAuthorInputEnvelope = {
    data: Enumerable<UserCommentLikesCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type UserCommentDislikesCreateWithoutAuthorInput = {
    ideaComment?: CommentCreateNestedOneWithoutDislikesInput
  }

  export type UserCommentDislikesUncheckedCreateWithoutAuthorInput = {
    id?: number
    ideaCommentId?: number | null
  }

  export type UserCommentDislikesCreateOrConnectWithoutAuthorInput = {
    where: UserCommentDislikesWhereUniqueInput
    create: XOR<UserCommentDislikesCreateWithoutAuthorInput, UserCommentDislikesUncheckedCreateWithoutAuthorInput>
  }

  export type UserCommentDislikesCreateManyAuthorInputEnvelope = {
    data: Enumerable<UserCommentDislikesCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type AdvertisementsCreateWithoutAuthorInput = {
    createAt?: Date | string
    updateAt?: Date | string | null
    adTitle: string
    adType?: AdType
    duration?: Date | string | null
    adPosition: string
    imagePath: string
    externalLink: string
    published?: boolean
  }

  export type AdvertisementsUncheckedCreateWithoutAuthorInput = {
    id?: number
    createAt?: Date | string
    updateAt?: Date | string | null
    adTitle: string
    adType?: AdType
    duration?: Date | string | null
    adPosition: string
    imagePath: string
    externalLink: string
    published?: boolean
  }

  export type AdvertisementsCreateOrConnectWithoutAuthorInput = {
    where: AdvertisementsWhereUniqueInput
    create: XOR<AdvertisementsCreateWithoutAuthorInput, AdvertisementsUncheckedCreateWithoutAuthorInput>
  }

  export type AdvertisementsCreateManyAuthorInputEnvelope = {
    data: Enumerable<AdvertisementsCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type segmentRequestCreateWithoutRequesterInput = {
    createAt?: Date | string
    country: string
    province: string
    segmentName: string
    subSegmentName?: string | null
  }

  export type segmentRequestUncheckedCreateWithoutRequesterInput = {
    id?: number
    createAt?: Date | string
    country: string
    province: string
    segmentName: string
    subSegmentName?: string | null
  }

  export type segmentRequestCreateOrConnectWithoutRequesterInput = {
    where: segmentRequestWhereUniqueInput
    create: XOR<segmentRequestCreateWithoutRequesterInput, segmentRequestUncheckedCreateWithoutRequesterInput>
  }

  export type segmentRequestCreateManyRequesterInputEnvelope = {
    data: Enumerable<segmentRequestCreateManyRequesterInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutUserInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutUserInput = {
    id?: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutUserInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutUserInput, UserSegmentsUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpsertWithoutUserInput = {
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithoutUserInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGeoUpsertWithoutUserInput = {
    update: XOR<UserGeoUpdateWithoutUserInput, UserGeoUncheckedUpdateWithoutUserInput>
    create: XOR<UserGeoCreateWithoutUserInput, UserGeoUncheckedCreateWithoutUserInput>
  }

  export type UserGeoUpdateWithoutUserInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGeoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    work_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    school_lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUpsertWithWhereUniqueWithoutAuthorInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutAuthorInput, IdeaUncheckedUpdateWithoutAuthorInput>
    create: XOR<IdeaCreateWithoutAuthorInput, IdeaUncheckedCreateWithoutAuthorInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutAuthorInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutAuthorInput, IdeaUncheckedUpdateWithoutAuthorInput>
  }

  export type IdeaUpdateManyWithWhereWithoutAuthorInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutIdeasInput>
  }

  export type IdeaScalarWhereInput = {
    AND?: Enumerable<IdeaScalarWhereInput>
    OR?: Enumerable<IdeaScalarWhereInput>
    NOT?: Enumerable<IdeaScalarWhereInput>
    id?: IntFilter | number
    authorId?: StringFilter | string
    championId?: StringNullableFilter | string | null
    categoryId?: IntFilter | number
    superSegmentId?: IntFilter | number
    segmentId?: IntNullableFilter | number | null
    subSegmentId?: IntNullableFilter | number | null
    title?: StringFilter | string
    description?: StringFilter | string
    userType?: StringFilter | string
    communityImpact?: StringNullableFilter | string | null
    natureImpact?: StringNullableFilter | string | null
    artsImpact?: StringNullableFilter | string | null
    energyImpact?: StringNullableFilter | string | null
    manufacturingImpact?: StringNullableFilter | string | null
    state?: EnumIdeaStateFilter | IdeaState
    active?: BoolFilter | boolean
    imagePath?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProposalUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutAuthorInput, ProposalUncheckedUpdateWithoutAuthorInput>
    create: XOR<ProposalCreateWithoutAuthorInput, ProposalUncheckedCreateWithoutAuthorInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutAuthorInput, ProposalUncheckedUpdateWithoutAuthorInput>
  }

  export type ProposalUpdateManyWithWhereWithoutAuthorInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProposalsInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: Enumerable<ProposalScalarWhereInput>
    OR?: Enumerable<ProposalScalarWhereInput>
    NOT?: Enumerable<ProposalScalarWhereInput>
    id?: IntFilter | number
    authorId?: StringFilter | string
    championId?: StringNullableFilter | string | null
    categoryId?: IntFilter | number
    superSegmentId?: IntFilter | number
    segmentId?: IntNullableFilter | number | null
    subSegmentId?: IntNullableFilter | number | null
    title?: StringFilter | string
    description?: StringFilter | string
    userType?: StringFilter | string
    communityImpact?: StringNullableFilter | string | null
    natureImpact?: StringNullableFilter | string | null
    artsImpact?: StringNullableFilter | string | null
    energyImpact?: StringNullableFilter | string | null
    manufacturingImpact?: StringNullableFilter | string | null
    state?: EnumIdeaStateFilter | IdeaState
    active?: BoolFilter | boolean
    imagePath?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProposalUpsertWithWhereUniqueWithoutChampionInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutChampionInput, ProposalUncheckedUpdateWithoutChampionInput>
    create: XOR<ProposalCreateWithoutChampionInput, ProposalUncheckedCreateWithoutChampionInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutChampionInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutChampionInput, ProposalUncheckedUpdateWithoutChampionInput>
  }

  export type ProposalUpdateManyWithWhereWithoutChampionInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutChampionedProposalsInput>
  }

  export type IdeaUpsertWithWhereUniqueWithoutChampionInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutChampionInput, IdeaUncheckedUpdateWithoutChampionInput>
    create: XOR<IdeaCreateWithoutChampionInput, IdeaUncheckedCreateWithoutChampionInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutChampionInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutChampionInput, IdeaUncheckedUpdateWithoutChampionInput>
  }

  export type IdeaUpdateManyWithWhereWithoutChampionInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutChampionedIdeasInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutAuthorInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutAuthorInput, RatingUncheckedUpdateWithoutAuthorInput>
    create: XOR<RatingCreateWithoutAuthorInput, RatingUncheckedCreateWithoutAuthorInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutAuthorInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutAuthorInput, RatingUncheckedUpdateWithoutAuthorInput>
  }

  export type RatingUpdateManyWithWhereWithoutAuthorInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutIdeaRatingsInput>
  }

  export type RatingScalarWhereInput = {
    AND?: Enumerable<RatingScalarWhereInput>
    OR?: Enumerable<RatingScalarWhereInput>
    NOT?: Enumerable<RatingScalarWhereInput>
    id?: IntFilter | number
    ideaId?: IntNullableFilter | number | null
    proposalId?: IntNullableFilter | number | null
    authorId?: StringFilter | string
    rating?: IntFilter | number
    ratingExplanation?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutIdeaCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: IntFilter | number
    ideaId?: IntNullableFilter | number | null
    proposalId?: IntNullableFilter | number | null
    authorId?: StringFilter | string
    userSegId?: StringFilter | string
    superSegmentId?: IntNullableFilter | number | null
    segmentId?: IntNullableFilter | number | null
    subSegmentId?: IntNullableFilter | number | null
    content?: StringFilter | string
    active?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserCommentLikesUpsertWithWhereUniqueWithoutAuthorInput = {
    where: UserCommentLikesWhereUniqueInput
    update: XOR<UserCommentLikesUpdateWithoutAuthorInput, UserCommentLikesUncheckedUpdateWithoutAuthorInput>
    create: XOR<UserCommentLikesCreateWithoutAuthorInput, UserCommentLikesUncheckedCreateWithoutAuthorInput>
  }

  export type UserCommentLikesUpdateWithWhereUniqueWithoutAuthorInput = {
    where: UserCommentLikesWhereUniqueInput
    data: XOR<UserCommentLikesUpdateWithoutAuthorInput, UserCommentLikesUncheckedUpdateWithoutAuthorInput>
  }

  export type UserCommentLikesUpdateManyWithWhereWithoutAuthorInput = {
    where: UserCommentLikesScalarWhereInput
    data: XOR<UserCommentLikesUpdateManyMutationInput, UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentLikesInput>
  }

  export type UserCommentLikesScalarWhereInput = {
    AND?: Enumerable<UserCommentLikesScalarWhereInput>
    OR?: Enumerable<UserCommentLikesScalarWhereInput>
    NOT?: Enumerable<UserCommentLikesScalarWhereInput>
    id?: IntFilter | number
    ideaCommentId?: IntNullableFilter | number | null
    authorId?: StringNullableFilter | string | null
  }

  export type UserCommentDislikesUpsertWithWhereUniqueWithoutAuthorInput = {
    where: UserCommentDislikesWhereUniqueInput
    update: XOR<UserCommentDislikesUpdateWithoutAuthorInput, UserCommentDislikesUncheckedUpdateWithoutAuthorInput>
    create: XOR<UserCommentDislikesCreateWithoutAuthorInput, UserCommentDislikesUncheckedCreateWithoutAuthorInput>
  }

  export type UserCommentDislikesUpdateWithWhereUniqueWithoutAuthorInput = {
    where: UserCommentDislikesWhereUniqueInput
    data: XOR<UserCommentDislikesUpdateWithoutAuthorInput, UserCommentDislikesUncheckedUpdateWithoutAuthorInput>
  }

  export type UserCommentDislikesUpdateManyWithWhereWithoutAuthorInput = {
    where: UserCommentDislikesScalarWhereInput
    data: XOR<UserCommentDislikesUpdateManyMutationInput, UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentDislikesInput>
  }

  export type UserCommentDislikesScalarWhereInput = {
    AND?: Enumerable<UserCommentDislikesScalarWhereInput>
    OR?: Enumerable<UserCommentDislikesScalarWhereInput>
    NOT?: Enumerable<UserCommentDislikesScalarWhereInput>
    id?: IntFilter | number
    ideaCommentId?: IntNullableFilter | number | null
    authorId?: StringNullableFilter | string | null
  }

  export type AdvertisementsUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AdvertisementsWhereUniqueInput
    update: XOR<AdvertisementsUpdateWithoutAuthorInput, AdvertisementsUncheckedUpdateWithoutAuthorInput>
    create: XOR<AdvertisementsCreateWithoutAuthorInput, AdvertisementsUncheckedCreateWithoutAuthorInput>
  }

  export type AdvertisementsUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AdvertisementsWhereUniqueInput
    data: XOR<AdvertisementsUpdateWithoutAuthorInput, AdvertisementsUncheckedUpdateWithoutAuthorInput>
  }

  export type AdvertisementsUpdateManyWithWhereWithoutAuthorInput = {
    where: AdvertisementsScalarWhereInput
    data: XOR<AdvertisementsUpdateManyMutationInput, AdvertisementsUncheckedUpdateManyWithoutAdvertisementsInput>
  }

  export type AdvertisementsScalarWhereInput = {
    AND?: Enumerable<AdvertisementsScalarWhereInput>
    OR?: Enumerable<AdvertisementsScalarWhereInput>
    NOT?: Enumerable<AdvertisementsScalarWhereInput>
    id?: IntFilter | number
    ownerId?: StringFilter | string
    createAt?: DateTimeFilter | Date | string
    updateAt?: DateTimeNullableFilter | Date | string | null
    adTitle?: StringFilter | string
    adType?: EnumAdTypeFilter | AdType
    duration?: DateTimeNullableFilter | Date | string | null
    adPosition?: StringFilter | string
    imagePath?: StringFilter | string
    externalLink?: StringFilter | string
    published?: BoolFilter | boolean
  }

  export type segmentRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: segmentRequestWhereUniqueInput
    update: XOR<segmentRequestUpdateWithoutRequesterInput, segmentRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<segmentRequestCreateWithoutRequesterInput, segmentRequestUncheckedCreateWithoutRequesterInput>
  }

  export type segmentRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: segmentRequestWhereUniqueInput
    data: XOR<segmentRequestUpdateWithoutRequesterInput, segmentRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type segmentRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: segmentRequestScalarWhereInput
    data: XOR<segmentRequestUpdateManyMutationInput, segmentRequestUncheckedUpdateManyWithoutSegmentRequestInput>
  }

  export type segmentRequestScalarWhereInput = {
    AND?: Enumerable<segmentRequestScalarWhereInput>
    OR?: Enumerable<segmentRequestScalarWhereInput>
    NOT?: Enumerable<segmentRequestScalarWhereInput>
    id?: IntFilter | number
    createAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    country?: StringFilter | string
    province?: StringFilter | string
    segmentName?: StringFilter | string
    subSegmentName?: StringNullableFilter | string | null
  }

  export type UserSegmentsUpsertWithoutUserInput = {
    update: XOR<UserSegmentsUpdateWithoutUserInput, UserSegmentsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSegmentsCreateWithoutUserInput, UserSegmentsUncheckedCreateWithoutUserInput>
  }

  export type UserSegmentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserCreateWithoutUserSegmentsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
  }

  export type UserUncheckedCreateWithoutUserSegmentsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
  }

  export type UserCreateOrConnectWithoutUserSegmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSegmentsInput, UserUncheckedCreateWithoutUserSegmentsInput>
  }

  export type SuperSegmentCreateWithoutHomeUserSegmentsInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSuperSegmentInput
    workUserSegments?: UserSegmentsCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedCreateWithoutHomeUserSegmentsInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput
    workUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentCreateOrConnectWithoutHomeUserSegmentsInput = {
    where: SuperSegmentWhereUniqueInput
    create: XOR<SuperSegmentCreateWithoutHomeUserSegmentsInput, SuperSegmentUncheckedCreateWithoutHomeUserSegmentsInput>
  }

  export type SuperSegmentCreateWithoutWorkUserSegmentsInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsCreateNestedManyWithoutHomeSuperSegInput
    schoolUserSegments?: UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedCreateWithoutWorkUserSegmentsInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentCreateOrConnectWithoutWorkUserSegmentsInput = {
    where: SuperSegmentWhereUniqueInput
    create: XOR<SuperSegmentCreateWithoutWorkUserSegmentsInput, SuperSegmentUncheckedCreateWithoutWorkUserSegmentsInput>
  }

  export type SuperSegmentCreateWithoutSchoolUserSegmentsInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsCreateNestedManyWithoutWorkSuperSegInput
  }

  export type SuperSegmentUncheckedCreateWithoutSchoolUserSegmentsInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput
  }

  export type SuperSegmentCreateOrConnectWithoutSchoolUserSegmentsInput = {
    where: SuperSegmentWhereUniqueInput
    create: XOR<SuperSegmentCreateWithoutSchoolUserSegmentsInput, SuperSegmentUncheckedCreateWithoutSchoolUserSegmentsInput>
  }

  export type SegmentsCreateWithoutHomeSegmentsInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutHomeSegmentsInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutHomeSegmentsInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutHomeSegmentsInput, SegmentsUncheckedCreateWithoutHomeSegmentsInput>
  }

  export type SegmentsCreateWithoutWorkSegmentsInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutWorkSegmentsInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutWorkSegmentsInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutWorkSegmentsInput, SegmentsUncheckedCreateWithoutWorkSegmentsInput>
  }

  export type SegmentsCreateWithoutSchoolSegmentsInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutSchoolSegmentsInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutSchoolSegmentsInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutSchoolSegmentsInput, SegmentsUncheckedCreateWithoutSchoolSegmentsInput>
  }

  export type SubSegmentsCreateWithoutHomeSubSegmentsInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    segRef: SegmentsCreateNestedOneWithoutSubSegmentsInput
    workSubSegments?: UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateWithoutHomeSubSegmentsInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    workSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateOrConnectWithoutHomeSubSegmentsInput = {
    where: SubSegmentsWhereUniqueInput
    create: XOR<SubSegmentsCreateWithoutHomeSubSegmentsInput, SubSegmentsUncheckedCreateWithoutHomeSubSegmentsInput>
  }

  export type SubSegmentsCreateWithoutWorkSubSegmentsInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    segRef: SegmentsCreateNestedOneWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput
    schoolSubSegments?: UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateWithoutWorkSubSegmentsInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateOrConnectWithoutWorkSubSegmentsInput = {
    where: SubSegmentsWhereUniqueInput
    create: XOR<SubSegmentsCreateWithoutWorkSubSegmentsInput, SubSegmentsUncheckedCreateWithoutWorkSubSegmentsInput>
  }

  export type SubSegmentsCreateWithoutSchoolSubSegmentsInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    segRef: SegmentsCreateNestedOneWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateWithoutSchoolSubSegmentsInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateOrConnectWithoutSchoolSubSegmentsInput = {
    where: SubSegmentsWhereUniqueInput
    create: XOR<SubSegmentsCreateWithoutSchoolSubSegmentsInput, SubSegmentsUncheckedCreateWithoutSchoolSubSegmentsInput>
  }

  export type CommentCreateWithoutUserSegInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaCommentsInput
    idea?: IdeaCreateNestedOneWithoutCommentsInput
    proposal?: ProposalCreateNestedOneWithoutCommentsInput
    likes?: UserCommentLikesCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateWithoutUserSegInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentCreateOrConnectWithoutUserSegInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserSegInput, CommentUncheckedCreateWithoutUserSegInput>
  }

  export type CommentCreateManyUserSegInputEnvelope = {
    data: Enumerable<CommentCreateManyUserSegInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserSegmentsInput = {
    update: XOR<UserUpdateWithoutUserSegmentsInput, UserUncheckedUpdateWithoutUserSegmentsInput>
    create: XOR<UserCreateWithoutUserSegmentsInput, UserUncheckedCreateWithoutUserSegmentsInput>
  }

  export type UserUpdateWithoutUserSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
  }

  export type UserUncheckedUpdateWithoutUserSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
  }

  export type SuperSegmentUpsertWithoutHomeUserSegmentsInput = {
    update: XOR<SuperSegmentUpdateWithoutHomeUserSegmentsInput, SuperSegmentUncheckedUpdateWithoutHomeUserSegmentsInput>
    create: XOR<SuperSegmentCreateWithoutHomeUserSegmentsInput, SuperSegmentUncheckedCreateWithoutHomeUserSegmentsInput>
  }

  export type SuperSegmentUpdateWithoutHomeUserSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUpdateManyWithoutSuperSegmentInput
    workUserSegments?: UserSegmentsUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateWithoutHomeUserSegmentsInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUncheckedUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSuperSegmentInput
    workUserSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUpsertWithoutWorkUserSegmentsInput = {
    update: XOR<SuperSegmentUpdateWithoutWorkUserSegmentsInput, SuperSegmentUncheckedUpdateWithoutWorkUserSegmentsInput>
    create: XOR<SuperSegmentCreateWithoutWorkUserSegmentsInput, SuperSegmentUncheckedCreateWithoutWorkUserSegmentsInput>
  }

  export type SuperSegmentUpdateWithoutWorkUserSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUpdateManyWithoutHomeSuperSegInput
    schoolUserSegments?: UserSegmentsUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateWithoutWorkUserSegmentsInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUncheckedUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUpsertWithoutSchoolUserSegmentsInput = {
    update: XOR<SuperSegmentUpdateWithoutSchoolUserSegmentsInput, SuperSegmentUncheckedUpdateWithoutSchoolUserSegmentsInput>
    create: XOR<SuperSegmentCreateWithoutSchoolUserSegmentsInput, SuperSegmentUncheckedCreateWithoutSchoolUserSegmentsInput>
  }

  export type SuperSegmentUpdateWithoutSchoolUserSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUpdateManyWithoutWorkSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateWithoutSchoolUserSegmentsInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUncheckedUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput
  }

  export type SegmentsUpsertWithoutHomeSegmentsInput = {
    update: XOR<SegmentsUpdateWithoutHomeSegmentsInput, SegmentsUncheckedUpdateWithoutHomeSegmentsInput>
    create: XOR<SegmentsCreateWithoutHomeSegmentsInput, SegmentsUncheckedCreateWithoutHomeSegmentsInput>
  }

  export type SegmentsUpdateWithoutHomeSegmentsInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutHomeSegmentsInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type SegmentsUpsertWithoutWorkSegmentsInput = {
    update: XOR<SegmentsUpdateWithoutWorkSegmentsInput, SegmentsUncheckedUpdateWithoutWorkSegmentsInput>
    create: XOR<SegmentsCreateWithoutWorkSegmentsInput, SegmentsUncheckedCreateWithoutWorkSegmentsInput>
  }

  export type SegmentsUpdateWithoutWorkSegmentsInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutWorkSegmentsInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type SegmentsUpsertWithoutSchoolSegmentsInput = {
    update: XOR<SegmentsUpdateWithoutSchoolSegmentsInput, SegmentsUncheckedUpdateWithoutSchoolSegmentsInput>
    create: XOR<SegmentsCreateWithoutSchoolSegmentsInput, SegmentsUncheckedCreateWithoutSchoolSegmentsInput>
  }

  export type SegmentsUpdateWithoutSchoolSegmentsInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutSchoolSegmentsInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type SubSegmentsUpsertWithoutHomeSubSegmentsInput = {
    update: XOR<SubSegmentsUpdateWithoutHomeSubSegmentsInput, SubSegmentsUncheckedUpdateWithoutHomeSubSegmentsInput>
    create: XOR<SubSegmentsCreateWithoutHomeSubSegmentsInput, SubSegmentsUncheckedCreateWithoutHomeSubSegmentsInput>
  }

  export type SubSegmentsUpdateWithoutHomeSubSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segRef?: SegmentsUpdateOneRequiredWithoutSubSegmentsInput
    workSubSegments?: UserSegmentsUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateWithoutHomeSubSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workSubSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUpsertWithoutWorkSubSegmentsInput = {
    update: XOR<SubSegmentsUpdateWithoutWorkSubSegmentsInput, SubSegmentsUncheckedUpdateWithoutWorkSubSegmentsInput>
    create: XOR<SubSegmentsCreateWithoutWorkSubSegmentsInput, SubSegmentsUncheckedCreateWithoutWorkSubSegmentsInput>
  }

  export type SubSegmentsUpdateWithoutWorkSubSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segRef?: SegmentsUpdateOneRequiredWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsUpdateManyWithoutHomeSubSegmentInput
    schoolSubSegments?: UserSegmentsUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateWithoutWorkSubSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUpsertWithoutSchoolSubSegmentsInput = {
    update: XOR<SubSegmentsUpdateWithoutSchoolSubSegmentsInput, SubSegmentsUncheckedUpdateWithoutSchoolSubSegmentsInput>
    create: XOR<SubSegmentsCreateWithoutSchoolSubSegmentsInput, SubSegmentsUncheckedCreateWithoutSchoolSubSegmentsInput>
  }

  export type SubSegmentsUpdateWithoutSchoolSubSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segRef?: SegmentsUpdateOneRequiredWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUpdateManyWithoutWorkSubSegmentInput
    Idea?: IdeaUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateWithoutSchoolSubSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type CommentUpsertWithWhereUniqueWithoutUserSegInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserSegInput, CommentUncheckedUpdateWithoutUserSegInput>
    create: XOR<CommentCreateWithoutUserSegInput, CommentUncheckedCreateWithoutUserSegInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserSegInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserSegInput, CommentUncheckedUpdateWithoutUserSegInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserSegInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutIdeaCommentInput>
  }

  export type IdeaCreateWithoutCategoryInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutCategoryInput = {
    id?: number
    authorId: string
    championId?: string | null
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutCategoryInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutCategoryInput, IdeaUncheckedCreateWithoutCategoryInput>
  }

  export type IdeaCreateManyCategoryInputEnvelope = {
    data: Enumerable<IdeaCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutCategoryInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutCategoryInput = {
    id?: number
    authorId: string
    championId?: string | null
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutCategoryInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutCategoryInput, ProposalUncheckedCreateWithoutCategoryInput>
  }

  export type ProposalCreateManyCategoryInputEnvelope = {
    data: Enumerable<ProposalCreateManyCategoryInput>
    skipDuplicates?: boolean
  }

  export type IdeaUpsertWithWhereUniqueWithoutCategoryInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutCategoryInput, IdeaUncheckedUpdateWithoutCategoryInput>
    create: XOR<IdeaCreateWithoutCategoryInput, IdeaUncheckedCreateWithoutCategoryInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutCategoryInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutCategoryInput, IdeaUncheckedUpdateWithoutCategoryInput>
  }

  export type IdeaUpdateManyWithWhereWithoutCategoryInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutIdeasInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutCategoryInput, ProposalUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProposalCreateWithoutCategoryInput, ProposalUncheckedCreateWithoutCategoryInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutCategoryInput, ProposalUncheckedUpdateWithoutCategoryInput>
  }

  export type ProposalUpdateManyWithWhereWithoutCategoryInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProposalsInput>
  }

  export type IdeaCreateWithoutGeoInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutGeoInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutGeoInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutGeoInput, IdeaUncheckedCreateWithoutGeoInput>
  }

  export type ProposalCreateWithoutGeoInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutGeoInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutGeoInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutGeoInput, ProposalUncheckedCreateWithoutGeoInput>
  }

  export type IdeaUpsertWithoutGeoInput = {
    update: XOR<IdeaUpdateWithoutGeoInput, IdeaUncheckedUpdateWithoutGeoInput>
    create: XOR<IdeaCreateWithoutGeoInput, IdeaUncheckedCreateWithoutGeoInput>
  }

  export type IdeaUpdateWithoutGeoInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutGeoInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpsertWithoutGeoInput = {
    update: XOR<ProposalUpdateWithoutGeoInput, ProposalUncheckedUpdateWithoutGeoInput>
    create: XOR<ProposalCreateWithoutGeoInput, ProposalUncheckedCreateWithoutGeoInput>
  }

  export type ProposalUpdateWithoutGeoInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutGeoInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
  }

  export type IdeaCreateWithoutAddressInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutAddressInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutAddressInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutAddressInput, IdeaUncheckedCreateWithoutAddressInput>
  }

  export type ProposalCreateWithoutAddressInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutAddressInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutAddressInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutAddressInput, ProposalUncheckedCreateWithoutAddressInput>
  }

  export type IdeaUpsertWithoutAddressInput = {
    update: XOR<IdeaUpdateWithoutAddressInput, IdeaUncheckedUpdateWithoutAddressInput>
    create: XOR<IdeaCreateWithoutAddressInput, IdeaUncheckedCreateWithoutAddressInput>
  }

  export type IdeaUpdateWithoutAddressInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpsertWithoutAddressInput = {
    update: XOR<ProposalUpdateWithoutAddressInput, ProposalUncheckedUpdateWithoutAddressInput>
    create: XOR<ProposalCreateWithoutAddressInput, ProposalUncheckedCreateWithoutAddressInput>
  }

  export type ProposalUpdateWithoutAddressInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type CommentCreateWithoutIdeaInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaCommentsInput
    proposal?: ProposalCreateNestedOneWithoutCommentsInput
    userSeg: UserSegmentsCreateNestedOneWithoutIdeaCommentInput
    likes?: UserCommentLikesCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateWithoutIdeaInput = {
    id?: number
    proposalId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentCreateOrConnectWithoutIdeaInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutIdeaInput, CommentUncheckedCreateWithoutIdeaInput>
  }

  export type CommentCreateManyIdeaInputEnvelope = {
    data: Enumerable<CommentCreateManyIdeaInput>
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutIdeaInput = {
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaRatingsInput
    proposal?: ProposalCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutIdeaInput = {
    id?: number
    proposalId?: number | null
    authorId: string
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutIdeaInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutIdeaInput, RatingUncheckedCreateWithoutIdeaInput>
  }

  export type RatingCreateManyIdeaInputEnvelope = {
    data: Enumerable<RatingCreateManyIdeaInput>
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutIdeaInput = {
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutIdeaInput = {
    id?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutIdeaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutIdeaInput, ProjectUncheckedCreateWithoutIdeaInput>
  }

  export type AddressCreateWithoutIdeaInput = {
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal?: ProposalCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutIdeaInput = {
    id?: number
    proposalId?: number | null
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutIdeaInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutIdeaInput, AddressUncheckedCreateWithoutIdeaInput>
  }

  export type GeoCreateWithoutIdeaInput = {
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposal?: ProposalCreateNestedOneWithoutGeoInput
  }

  export type GeoUncheckedCreateWithoutIdeaInput = {
    id?: number
    proposalId?: number | null
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeoCreateOrConnectWithoutIdeaInput = {
    where: GeoWhereUniqueInput
    create: XOR<GeoCreateWithoutIdeaInput, GeoUncheckedCreateWithoutIdeaInput>
  }

  export type UserCreateWithoutIdeasInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdeasInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdeasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
  }

  export type UserCreateWithoutChampionedIdeasInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChampionedIdeasInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChampionedIdeasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChampionedIdeasInput, UserUncheckedCreateWithoutChampionedIdeasInput>
  }

  export type CategoryCreateWithoutIdeasInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposals?: ProposalCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutIdeasInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proposals?: ProposalUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutIdeasInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutIdeasInput, CategoryUncheckedCreateWithoutIdeasInput>
  }

  export type SuperSegmentCreateWithoutIdeaInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedCreateWithoutIdeaInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentCreateOrConnectWithoutIdeaInput = {
    where: SuperSegmentWhereUniqueInput
    create: XOR<SuperSegmentCreateWithoutIdeaInput, SuperSegmentUncheckedCreateWithoutIdeaInput>
  }

  export type SegmentsCreateWithoutIdeaInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutIdeaInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutIdeaInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutIdeaInput, SegmentsUncheckedCreateWithoutIdeaInput>
  }

  export type SubSegmentsCreateWithoutIdeaInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    segRef: SegmentsCreateNestedOneWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateWithoutIdeaInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateOrConnectWithoutIdeaInput = {
    where: SubSegmentsWhereUniqueInput
    create: XOR<SubSegmentsCreateWithoutIdeaInput, SubSegmentsUncheckedCreateWithoutIdeaInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutIdeaInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutIdeaInput, CommentUncheckedUpdateWithoutIdeaInput>
    create: XOR<CommentCreateWithoutIdeaInput, CommentUncheckedCreateWithoutIdeaInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutIdeaInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutIdeaInput, CommentUncheckedUpdateWithoutIdeaInput>
  }

  export type CommentUpdateManyWithWhereWithoutIdeaInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutIdeaInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutIdeaInput, RatingUncheckedUpdateWithoutIdeaInput>
    create: XOR<RatingCreateWithoutIdeaInput, RatingUncheckedCreateWithoutIdeaInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutIdeaInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutIdeaInput, RatingUncheckedUpdateWithoutIdeaInput>
  }

  export type RatingUpdateManyWithWhereWithoutIdeaInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutRatingsInput>
  }

  export type ProjectUpsertWithoutIdeaInput = {
    update: XOR<ProjectUpdateWithoutIdeaInput, ProjectUncheckedUpdateWithoutIdeaInput>
    create: XOR<ProjectCreateWithoutIdeaInput, ProjectUncheckedCreateWithoutIdeaInput>
  }

  export type ProjectUpdateWithoutIdeaInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpsertWithoutIdeaInput = {
    update: XOR<AddressUpdateWithoutIdeaInput, AddressUncheckedUpdateWithoutIdeaInput>
    create: XOR<AddressCreateWithoutIdeaInput, AddressUncheckedCreateWithoutIdeaInput>
  }

  export type AddressUpdateWithoutIdeaInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneWithoutAddressInput
  }

  export type AddressUncheckedUpdateWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoUpsertWithoutIdeaInput = {
    update: XOR<GeoUpdateWithoutIdeaInput, GeoUncheckedUpdateWithoutIdeaInput>
    create: XOR<GeoCreateWithoutIdeaInput, GeoUncheckedCreateWithoutIdeaInput>
  }

  export type GeoUpdateWithoutIdeaInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposal?: ProposalUpdateOneWithoutGeoInput
  }

  export type GeoUncheckedUpdateWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutIdeasInput = {
    update: XOR<UserUpdateWithoutIdeasInput, UserUncheckedUpdateWithoutIdeasInput>
    create: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
  }

  export type UserUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type UserUpsertWithoutChampionedIdeasInput = {
    update: XOR<UserUpdateWithoutChampionedIdeasInput, UserUncheckedUpdateWithoutChampionedIdeasInput>
    create: XOR<UserCreateWithoutChampionedIdeasInput, UserUncheckedCreateWithoutChampionedIdeasInput>
  }

  export type UserUpdateWithoutChampionedIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutChampionedIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type CategoryUpsertWithoutIdeasInput = {
    update: XOR<CategoryUpdateWithoutIdeasInput, CategoryUncheckedUpdateWithoutIdeasInput>
    create: XOR<CategoryCreateWithoutIdeasInput, CategoryUncheckedCreateWithoutIdeasInput>
  }

  export type CategoryUpdateWithoutIdeasInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutIdeasInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUncheckedUpdateManyWithoutCategoryInput
  }

  export type SuperSegmentUpsertWithoutIdeaInput = {
    update: XOR<SuperSegmentUpdateWithoutIdeaInput, SuperSegmentUncheckedUpdateWithoutIdeaInput>
    create: XOR<SuperSegmentCreateWithoutIdeaInput, SuperSegmentUncheckedCreateWithoutIdeaInput>
  }

  export type SuperSegmentUpdateWithoutIdeaInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateWithoutIdeaInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUncheckedUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput
  }

  export type SegmentsUpsertWithoutIdeaInput = {
    update: XOR<SegmentsUpdateWithoutIdeaInput, SegmentsUncheckedUpdateWithoutIdeaInput>
    create: XOR<SegmentsCreateWithoutIdeaInput, SegmentsUncheckedCreateWithoutIdeaInput>
  }

  export type SegmentsUpdateWithoutIdeaInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutIdeaInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type SubSegmentsUpsertWithoutIdeaInput = {
    update: XOR<SubSegmentsUpdateWithoutIdeaInput, SubSegmentsUncheckedUpdateWithoutIdeaInput>
    create: XOR<SubSegmentsCreateWithoutIdeaInput, SubSegmentsUncheckedCreateWithoutIdeaInput>
  }

  export type SubSegmentsUpdateWithoutIdeaInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segRef?: SegmentsUpdateOneRequiredWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUpdateManyWithoutSchoolSubSegmentInput
    Proposal?: ProposalUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type CommentCreateWithoutProposalInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaCommentsInput
    idea?: IdeaCreateNestedOneWithoutCommentsInput
    userSeg: UserSegmentsCreateNestedOneWithoutIdeaCommentInput
    likes?: UserCommentLikesCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateWithoutProposalInput = {
    id?: number
    ideaId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentCreateOrConnectWithoutProposalInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProposalInput, CommentUncheckedCreateWithoutProposalInput>
  }

  export type CommentCreateManyProposalInputEnvelope = {
    data: Enumerable<CommentCreateManyProposalInput>
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutProposalInput = {
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaRatingsInput
    idea?: IdeaCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutProposalInput = {
    id?: number
    ideaId?: number | null
    authorId: string
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateOrConnectWithoutProposalInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutProposalInput, RatingUncheckedCreateWithoutProposalInput>
  }

  export type RatingCreateManyProposalInputEnvelope = {
    data: Enumerable<RatingCreateManyProposalInput>
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutProposalInput = {
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idea?: IdeaCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutProposalInput = {
    id?: number
    ideaId?: number | null
    streetAddress?: string | null
    streetAddress2?: string | null
    city?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutProposalInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutProposalInput, AddressUncheckedCreateWithoutProposalInput>
  }

  export type GeoCreateWithoutProposalInput = {
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idea?: IdeaCreateNestedOneWithoutGeoInput
  }

  export type GeoUncheckedCreateWithoutProposalInput = {
    id?: number
    ideaId?: number | null
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GeoCreateOrConnectWithoutProposalInput = {
    where: GeoWhereUniqueInput
    create: XOR<GeoCreateWithoutProposalInput, GeoUncheckedCreateWithoutProposalInput>
  }

  export type UserCreateWithoutProposalsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProposalsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
  }

  export type UserCreateWithoutChampionedProposalsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChampionedProposalsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChampionedProposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChampionedProposalsInput, UserUncheckedCreateWithoutChampionedProposalsInput>
  }

  export type CategoryCreateWithoutProposalsInput = {
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ideas?: IdeaCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProposalsInput = {
    id?: number
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ideas?: IdeaUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProposalsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProposalsInput, CategoryUncheckedCreateWithoutProposalsInput>
  }

  export type SuperSegmentCreateWithoutProposalInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedCreateWithoutProposalInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Segments?: SegmentsUncheckedCreateNestedManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentCreateOrConnectWithoutProposalInput = {
    where: SuperSegmentWhereUniqueInput
    create: XOR<SuperSegmentCreateWithoutProposalInput, SuperSegmentUncheckedCreateWithoutProposalInput>
  }

  export type SegmentsCreateWithoutProposalInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutProposalInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutProposalInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutProposalInput, SegmentsUncheckedCreateWithoutProposalInput>
  }

  export type SubSegmentsCreateWithoutProposalInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    segRef: SegmentsCreateNestedOneWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateWithoutProposalInput = {
    id?: number
    segId: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateOrConnectWithoutProposalInput = {
    where: SubSegmentsWhereUniqueInput
    create: XOR<SubSegmentsCreateWithoutProposalInput, SubSegmentsUncheckedCreateWithoutProposalInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutProposalInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProposalInput, CommentUncheckedUpdateWithoutProposalInput>
    create: XOR<CommentCreateWithoutProposalInput, CommentUncheckedCreateWithoutProposalInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProposalInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProposalInput, CommentUncheckedUpdateWithoutProposalInput>
  }

  export type CommentUpdateManyWithWhereWithoutProposalInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutProposalInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutProposalInput, RatingUncheckedUpdateWithoutProposalInput>
    create: XOR<RatingCreateWithoutProposalInput, RatingUncheckedCreateWithoutProposalInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutProposalInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutProposalInput, RatingUncheckedUpdateWithoutProposalInput>
  }

  export type RatingUpdateManyWithWhereWithoutProposalInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutRatingsInput>
  }

  export type AddressUpsertWithoutProposalInput = {
    update: XOR<AddressUpdateWithoutProposalInput, AddressUncheckedUpdateWithoutProposalInput>
    create: XOR<AddressCreateWithoutProposalInput, AddressUncheckedCreateWithoutProposalInput>
  }

  export type AddressUpdateWithoutProposalInput = {
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneWithoutAddressInput
  }

  export type AddressUncheckedUpdateWithoutProposalInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    streetAddress?: NullableStringFieldUpdateOperationsInput | string | null
    streetAddress2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeoUpsertWithoutProposalInput = {
    update: XOR<GeoUpdateWithoutProposalInput, GeoUncheckedUpdateWithoutProposalInput>
    create: XOR<GeoCreateWithoutProposalInput, GeoUncheckedCreateWithoutProposalInput>
  }

  export type GeoUpdateWithoutProposalInput = {
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneWithoutGeoInput
  }

  export type GeoUncheckedUpdateWithoutProposalInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutProposalsInput = {
    update: XOR<UserUpdateWithoutProposalsInput, UserUncheckedUpdateWithoutProposalsInput>
    create: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
  }

  export type UserUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type UserUpsertWithoutChampionedProposalsInput = {
    update: XOR<UserUpdateWithoutChampionedProposalsInput, UserUncheckedUpdateWithoutChampionedProposalsInput>
    create: XOR<UserCreateWithoutChampionedProposalsInput, UserUncheckedCreateWithoutChampionedProposalsInput>
  }

  export type UserUpdateWithoutChampionedProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutChampionedProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type CategoryUpsertWithoutProposalsInput = {
    update: XOR<CategoryUpdateWithoutProposalsInput, CategoryUncheckedUpdateWithoutProposalsInput>
    create: XOR<CategoryCreateWithoutProposalsInput, CategoryUncheckedCreateWithoutProposalsInput>
  }

  export type CategoryUpdateWithoutProposalsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: IdeaUpdateManyWithoutCategoryInput
  }

  export type CategoryUncheckedUpdateWithoutProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ideas?: IdeaUncheckedUpdateManyWithoutCategoryInput
  }

  export type SuperSegmentUpsertWithoutProposalInput = {
    update: XOR<SuperSegmentUpdateWithoutProposalInput, SuperSegmentUncheckedUpdateWithoutProposalInput>
    create: XOR<SuperSegmentCreateWithoutProposalInput, SuperSegmentUncheckedCreateWithoutProposalInput>
  }

  export type SuperSegmentUpdateWithoutProposalInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateWithoutProposalInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Segments?: SegmentsUncheckedUpdateManyWithoutSuperSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput
  }

  export type SegmentsUpsertWithoutProposalInput = {
    update: XOR<SegmentsUpdateWithoutProposalInput, SegmentsUncheckedUpdateWithoutProposalInput>
    create: XOR<SegmentsCreateWithoutProposalInput, SegmentsUncheckedCreateWithoutProposalInput>
  }

  export type SegmentsUpdateWithoutProposalInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutProposalInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
  }

  export type SubSegmentsUpsertWithoutProposalInput = {
    update: XOR<SubSegmentsUpdateWithoutProposalInput, SubSegmentsUncheckedUpdateWithoutProposalInput>
    create: XOR<SubSegmentsCreateWithoutProposalInput, SubSegmentsUncheckedCreateWithoutProposalInput>
  }

  export type SubSegmentsUpdateWithoutProposalInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    segRef?: SegmentsUpdateOneRequiredWithoutSubSegmentsInput
    homeSubSegments?: UserSegmentsUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateWithoutProposalInput = {
    id?: IntFieldUpdateOperationsInput | number
    segId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type IdeaCreateWithoutProjectInfoInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutProjectInfoInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutProjectInfoInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutProjectInfoInput, IdeaUncheckedCreateWithoutProjectInfoInput>
  }

  export type IdeaUpsertWithoutProjectInfoInput = {
    update: XOR<IdeaUpdateWithoutProjectInfoInput, IdeaUncheckedUpdateWithoutProjectInfoInput>
    create: XOR<IdeaCreateWithoutProjectInfoInput, IdeaUncheckedCreateWithoutProjectInfoInput>
  }

  export type IdeaUpdateWithoutProjectInfoInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutProjectInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type UserCreateWithoutIdeaRatingsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdeaRatingsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdeaRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeaRatingsInput, UserUncheckedCreateWithoutIdeaRatingsInput>
  }

  export type IdeaCreateWithoutRatingsInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutRatingsInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutRatingsInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutRatingsInput, IdeaUncheckedCreateWithoutRatingsInput>
  }

  export type ProposalCreateWithoutRatingsInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutRatingsInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutRatingsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutRatingsInput, ProposalUncheckedCreateWithoutRatingsInput>
  }

  export type UserUpsertWithoutIdeaRatingsInput = {
    update: XOR<UserUpdateWithoutIdeaRatingsInput, UserUncheckedUpdateWithoutIdeaRatingsInput>
    create: XOR<UserCreateWithoutIdeaRatingsInput, UserUncheckedCreateWithoutIdeaRatingsInput>
  }

  export type UserUpdateWithoutIdeaRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutIdeaRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type IdeaUpsertWithoutRatingsInput = {
    update: XOR<IdeaUpdateWithoutRatingsInput, IdeaUncheckedUpdateWithoutRatingsInput>
    create: XOR<IdeaCreateWithoutRatingsInput, IdeaUncheckedCreateWithoutRatingsInput>
  }

  export type IdeaUpdateWithoutRatingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpsertWithoutRatingsInput = {
    update: XOR<ProposalUpdateWithoutRatingsInput, ProposalUncheckedUpdateWithoutRatingsInput>
    create: XOR<ProposalCreateWithoutRatingsInput, ProposalUncheckedCreateWithoutRatingsInput>
  }

  export type ProposalUpdateWithoutRatingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type UserCreateWithoutIdeaCommentsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdeaCommentsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdeaCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeaCommentsInput, UserUncheckedCreateWithoutIdeaCommentsInput>
  }

  export type IdeaCreateWithoutCommentsInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutCommentsInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutCommentsInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutCommentsInput, IdeaUncheckedCreateWithoutCommentsInput>
  }

  export type ProposalCreateWithoutCommentsInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutCommentsInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutCommentsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutCommentsInput, ProposalUncheckedCreateWithoutCommentsInput>
  }

  export type UserSegmentsCreateWithoutIdeaCommentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
  }

  export type UserSegmentsUncheckedCreateWithoutIdeaCommentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateOrConnectWithoutIdeaCommentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutIdeaCommentInput, UserSegmentsUncheckedCreateWithoutIdeaCommentInput>
  }

  export type UserCommentLikesCreateWithoutIdeaCommentInput = {
    author?: UserCreateNestedOneWithoutIdeaCommentLikesInput
  }

  export type UserCommentLikesUncheckedCreateWithoutIdeaCommentInput = {
    id?: number
    authorId?: string | null
  }

  export type UserCommentLikesCreateOrConnectWithoutIdeaCommentInput = {
    where: UserCommentLikesWhereUniqueInput
    create: XOR<UserCommentLikesCreateWithoutIdeaCommentInput, UserCommentLikesUncheckedCreateWithoutIdeaCommentInput>
  }

  export type UserCommentLikesCreateManyIdeaCommentInputEnvelope = {
    data: Enumerable<UserCommentLikesCreateManyIdeaCommentInput>
    skipDuplicates?: boolean
  }

  export type UserCommentDislikesCreateWithoutIdeaCommentInput = {
    author?: UserCreateNestedOneWithoutIdeaCommentDislikesInput
  }

  export type UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput = {
    id?: number
    authorId?: string | null
  }

  export type UserCommentDislikesCreateOrConnectWithoutIdeaCommentInput = {
    where: UserCommentDislikesWhereUniqueInput
    create: XOR<UserCommentDislikesCreateWithoutIdeaCommentInput, UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput>
  }

  export type UserCommentDislikesCreateManyIdeaCommentInputEnvelope = {
    data: Enumerable<UserCommentDislikesCreateManyIdeaCommentInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIdeaCommentsInput = {
    update: XOR<UserUpdateWithoutIdeaCommentsInput, UserUncheckedUpdateWithoutIdeaCommentsInput>
    create: XOR<UserCreateWithoutIdeaCommentsInput, UserUncheckedCreateWithoutIdeaCommentsInput>
  }

  export type UserUpdateWithoutIdeaCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutIdeaCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type IdeaUpsertWithoutCommentsInput = {
    update: XOR<IdeaUpdateWithoutCommentsInput, IdeaUncheckedUpdateWithoutCommentsInput>
    create: XOR<IdeaCreateWithoutCommentsInput, IdeaUncheckedCreateWithoutCommentsInput>
  }

  export type IdeaUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpsertWithoutCommentsInput = {
    update: XOR<ProposalUpdateWithoutCommentsInput, ProposalUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProposalCreateWithoutCommentsInput, ProposalUncheckedCreateWithoutCommentsInput>
  }

  export type ProposalUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type UserSegmentsUpsertWithoutIdeaCommentInput = {
    update: XOR<UserSegmentsUpdateWithoutIdeaCommentInput, UserSegmentsUncheckedUpdateWithoutIdeaCommentInput>
    create: XOR<UserSegmentsCreateWithoutIdeaCommentInput, UserSegmentsUncheckedCreateWithoutIdeaCommentInput>
  }

  export type UserSegmentsUpdateWithoutIdeaCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
  }

  export type UserSegmentsUncheckedUpdateWithoutIdeaCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentLikesUpsertWithWhereUniqueWithoutIdeaCommentInput = {
    where: UserCommentLikesWhereUniqueInput
    update: XOR<UserCommentLikesUpdateWithoutIdeaCommentInput, UserCommentLikesUncheckedUpdateWithoutIdeaCommentInput>
    create: XOR<UserCommentLikesCreateWithoutIdeaCommentInput, UserCommentLikesUncheckedCreateWithoutIdeaCommentInput>
  }

  export type UserCommentLikesUpdateWithWhereUniqueWithoutIdeaCommentInput = {
    where: UserCommentLikesWhereUniqueInput
    data: XOR<UserCommentLikesUpdateWithoutIdeaCommentInput, UserCommentLikesUncheckedUpdateWithoutIdeaCommentInput>
  }

  export type UserCommentLikesUpdateManyWithWhereWithoutIdeaCommentInput = {
    where: UserCommentLikesScalarWhereInput
    data: XOR<UserCommentLikesUpdateManyMutationInput, UserCommentLikesUncheckedUpdateManyWithoutLikesInput>
  }

  export type UserCommentDislikesUpsertWithWhereUniqueWithoutIdeaCommentInput = {
    where: UserCommentDislikesWhereUniqueInput
    update: XOR<UserCommentDislikesUpdateWithoutIdeaCommentInput, UserCommentDislikesUncheckedUpdateWithoutIdeaCommentInput>
    create: XOR<UserCommentDislikesCreateWithoutIdeaCommentInput, UserCommentDislikesUncheckedCreateWithoutIdeaCommentInput>
  }

  export type UserCommentDislikesUpdateWithWhereUniqueWithoutIdeaCommentInput = {
    where: UserCommentDislikesWhereUniqueInput
    data: XOR<UserCommentDislikesUpdateWithoutIdeaCommentInput, UserCommentDislikesUncheckedUpdateWithoutIdeaCommentInput>
  }

  export type UserCommentDislikesUpdateManyWithWhereWithoutIdeaCommentInput = {
    where: UserCommentDislikesScalarWhereInput
    data: XOR<UserCommentDislikesUpdateManyMutationInput, UserCommentDislikesUncheckedUpdateManyWithoutDislikesInput>
  }

  export type CommentCreateWithoutLikesInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaCommentsInput
    idea?: IdeaCreateNestedOneWithoutCommentsInput
    proposal?: ProposalCreateNestedOneWithoutCommentsInput
    userSeg: UserSegmentsCreateNestedOneWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateWithoutLikesInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentCreateOrConnectWithoutLikesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutIdeaCommentLikesInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdeaCommentLikesInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdeaCommentLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeaCommentLikesInput, UserUncheckedCreateWithoutIdeaCommentLikesInput>
  }

  export type CommentUpsertWithoutLikesInput = {
    update: XOR<CommentUpdateWithoutLikesInput, CommentUncheckedUpdateWithoutLikesInput>
    create: XOR<CommentCreateWithoutLikesInput, CommentUncheckedCreateWithoutLikesInput>
  }

  export type CommentUpdateWithoutLikesInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaCommentsInput
    idea?: IdeaUpdateOneWithoutCommentsInput
    proposal?: ProposalUpdateOneWithoutCommentsInput
    userSeg?: UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dislikes?: UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type UserUpsertWithoutIdeaCommentLikesInput = {
    update: XOR<UserUpdateWithoutIdeaCommentLikesInput, UserUncheckedUpdateWithoutIdeaCommentLikesInput>
    create: XOR<UserCreateWithoutIdeaCommentLikesInput, UserUncheckedCreateWithoutIdeaCommentLikesInput>
  }

  export type UserUpdateWithoutIdeaCommentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutIdeaCommentLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type CommentCreateWithoutDislikesInput = {
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutIdeaCommentsInput
    idea?: IdeaCreateNestedOneWithoutCommentsInput
    proposal?: ProposalCreateNestedOneWithoutCommentsInput
    userSeg: UserSegmentsCreateNestedOneWithoutIdeaCommentInput
    likes?: UserCommentLikesCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedCreateWithoutDislikesInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: UserCommentLikesUncheckedCreateNestedManyWithoutIdeaCommentInput
  }

  export type CommentCreateOrConnectWithoutDislikesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutDislikesInput, CommentUncheckedCreateWithoutDislikesInput>
  }

  export type UserCreateWithoutIdeaCommentDislikesInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdeaCommentDislikesInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdeaCommentDislikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeaCommentDislikesInput, UserUncheckedCreateWithoutIdeaCommentDislikesInput>
  }

  export type CommentUpsertWithoutDislikesInput = {
    update: XOR<CommentUpdateWithoutDislikesInput, CommentUncheckedUpdateWithoutDislikesInput>
    create: XOR<CommentCreateWithoutDislikesInput, CommentUncheckedCreateWithoutDislikesInput>
  }

  export type CommentUpdateWithoutDislikesInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaCommentsInput
    idea?: IdeaUpdateOneWithoutCommentsInput
    proposal?: ProposalUpdateOneWithoutCommentsInput
    userSeg?: UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput
    likes?: UserCommentLikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateWithoutDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type UserUpsertWithoutIdeaCommentDislikesInput = {
    update: XOR<UserUpdateWithoutIdeaCommentDislikesInput, UserUncheckedUpdateWithoutIdeaCommentDislikesInput>
    create: XOR<UserCreateWithoutIdeaCommentDislikesInput, UserUncheckedCreateWithoutIdeaCommentDislikesInput>
  }

  export type UserUpdateWithoutIdeaCommentDislikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutIdeaCommentDislikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type UserCreateWithoutAdvertisementsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdvertisementsInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedCreateNestedManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdvertisementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdvertisementsInput, UserUncheckedCreateWithoutAdvertisementsInput>
  }

  export type UserUpsertWithoutAdvertisementsInput = {
    update: XOR<UserUpdateWithoutAdvertisementsInput, UserUncheckedUpdateWithoutAdvertisementsInput>
    create: XOR<UserCreateWithoutAdvertisementsInput, UserUncheckedCreateWithoutAdvertisementsInput>
  }

  export type UserUpdateWithoutAdvertisementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAdvertisementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    segmentRequest?: segmentRequestUncheckedUpdateManyWithoutRequesterInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type SegmentsCreateWithoutSuperSegmentInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutSuperSegmentInput = {
    segId?: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    SubSegments?: SubSegmentsUncheckedCreateNestedManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutSuperSegmentInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutSuperSegmentInput, SegmentsUncheckedCreateWithoutSuperSegmentInput>
  }

  export type SegmentsCreateManySuperSegmentInputEnvelope = {
    data: Enumerable<SegmentsCreateManySuperSegmentInput>
    skipDuplicates?: boolean
  }

  export type IdeaCreateWithoutSuperSegmentInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutSuperSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutSuperSegmentInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutSuperSegmentInput, IdeaUncheckedCreateWithoutSuperSegmentInput>
  }

  export type IdeaCreateManySuperSegmentInputEnvelope = {
    data: Enumerable<IdeaCreateManySuperSegmentInput>
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutSuperSegmentInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutSuperSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutSuperSegmentInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutSuperSegmentInput, ProposalUncheckedCreateWithoutSuperSegmentInput>
  }

  export type ProposalCreateManySuperSegmentInputEnvelope = {
    data: Enumerable<ProposalCreateManySuperSegmentInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutHomeSuperSegInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutHomeSuperSegInput = {
    id?: string
    userId: string
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutHomeSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutHomeSuperSegInput, UserSegmentsUncheckedCreateWithoutHomeSuperSegInput>
  }

  export type UserSegmentsCreateManyHomeSuperSegInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManyHomeSuperSegInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutWorkSuperSegInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutWorkSuperSegInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutWorkSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutWorkSuperSegInput, UserSegmentsUncheckedCreateWithoutWorkSuperSegInput>
  }

  export type UserSegmentsCreateManyWorkSuperSegInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManyWorkSuperSegInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutSchoolSuperSegInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutSchoolSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutSchoolSuperSegInput, UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput>
  }

  export type UserSegmentsCreateManySchoolSuperSegInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManySchoolSuperSegInput>
    skipDuplicates?: boolean
  }

  export type SegmentsUpsertWithWhereUniqueWithoutSuperSegmentInput = {
    where: SegmentsWhereUniqueInput
    update: XOR<SegmentsUpdateWithoutSuperSegmentInput, SegmentsUncheckedUpdateWithoutSuperSegmentInput>
    create: XOR<SegmentsCreateWithoutSuperSegmentInput, SegmentsUncheckedCreateWithoutSuperSegmentInput>
  }

  export type SegmentsUpdateWithWhereUniqueWithoutSuperSegmentInput = {
    where: SegmentsWhereUniqueInput
    data: XOR<SegmentsUpdateWithoutSuperSegmentInput, SegmentsUncheckedUpdateWithoutSuperSegmentInput>
  }

  export type SegmentsUpdateManyWithWhereWithoutSuperSegmentInput = {
    where: SegmentsScalarWhereInput
    data: XOR<SegmentsUpdateManyMutationInput, SegmentsUncheckedUpdateManyWithoutSegmentsInput>
  }

  export type SegmentsScalarWhereInput = {
    AND?: Enumerable<SegmentsScalarWhereInput>
    OR?: Enumerable<SegmentsScalarWhereInput>
    NOT?: Enumerable<SegmentsScalarWhereInput>
    segId?: IntFilter | number
    superSegId?: IntFilter | number
    country?: StringFilter | string
    province?: StringFilter | string
    name?: StringFilter | string
    superSegName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type IdeaUpsertWithWhereUniqueWithoutSuperSegmentInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutSuperSegmentInput, IdeaUncheckedUpdateWithoutSuperSegmentInput>
    create: XOR<IdeaCreateWithoutSuperSegmentInput, IdeaUncheckedCreateWithoutSuperSegmentInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutSuperSegmentInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutSuperSegmentInput, IdeaUncheckedUpdateWithoutSuperSegmentInput>
  }

  export type IdeaUpdateManyWithWhereWithoutSuperSegmentInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutIdeaInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutSuperSegmentInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutSuperSegmentInput, ProposalUncheckedUpdateWithoutSuperSegmentInput>
    create: XOR<ProposalCreateWithoutSuperSegmentInput, ProposalUncheckedCreateWithoutSuperSegmentInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutSuperSegmentInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutSuperSegmentInput, ProposalUncheckedUpdateWithoutSuperSegmentInput>
  }

  export type ProposalUpdateManyWithWhereWithoutSuperSegmentInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProposalInput>
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutHomeSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutHomeSuperSegInput, UserSegmentsUncheckedUpdateWithoutHomeSuperSegInput>
    create: XOR<UserSegmentsCreateWithoutHomeSuperSegInput, UserSegmentsUncheckedCreateWithoutHomeSuperSegInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutHomeSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutHomeSuperSegInput, UserSegmentsUncheckedUpdateWithoutHomeSuperSegInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutHomeSuperSegInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutHomeUserSegmentsInput>
  }

  export type UserSegmentsScalarWhereInput = {
    AND?: Enumerable<UserSegmentsScalarWhereInput>
    OR?: Enumerable<UserSegmentsScalarWhereInput>
    NOT?: Enumerable<UserSegmentsScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    homeSuperSegId?: IntNullableFilter | number | null
    homeSuperSegName?: StringNullableFilter | string | null
    workSuperSegId?: IntNullableFilter | number | null
    workSuperSegName?: StringNullableFilter | string | null
    schoolSuperSegId?: IntNullableFilter | number | null
    schoolSuperSegName?: StringNullableFilter | string | null
    homeSegmentId?: IntNullableFilter | number | null
    homeSegmentName?: StringNullableFilter | string | null
    workSegmentId?: IntNullableFilter | number | null
    workSegmentName?: StringNullableFilter | string | null
    schoolSegmentId?: IntNullableFilter | number | null
    schoolSegmentName?: StringNullableFilter | string | null
    homeSubSegmentId?: IntNullableFilter | number | null
    homeSubSegmentName?: StringNullableFilter | string | null
    workSubSegmentId?: IntNullableFilter | number | null
    workSubSegmentName?: StringNullableFilter | string | null
    schoolSubSegmentId?: IntNullableFilter | number | null
    schoolSubSegmentName?: StringNullableFilter | string | null
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutWorkSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutWorkSuperSegInput, UserSegmentsUncheckedUpdateWithoutWorkSuperSegInput>
    create: XOR<UserSegmentsCreateWithoutWorkSuperSegInput, UserSegmentsUncheckedCreateWithoutWorkSuperSegInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutWorkSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutWorkSuperSegInput, UserSegmentsUncheckedUpdateWithoutWorkSuperSegInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutWorkSuperSegInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutWorkUserSegmentsInput>
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutSchoolSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutSchoolSuperSegInput, UserSegmentsUncheckedUpdateWithoutSchoolSuperSegInput>
    create: XOR<UserSegmentsCreateWithoutSchoolSuperSegInput, UserSegmentsUncheckedCreateWithoutSchoolSuperSegInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutSchoolSuperSegInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutSchoolSuperSegInput, UserSegmentsUncheckedUpdateWithoutSchoolSuperSegInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutSchoolSuperSegInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutSchoolUserSegmentsInput>
  }

  export type SuperSegmentCreateWithoutSegmentsInput = {
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Idea?: IdeaCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedCreateWithoutSegmentsInput = {
    superSegId?: number
    name: string
    country: string
    province: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    Idea?: IdeaUncheckedCreateNestedManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentCreateOrConnectWithoutSegmentsInput = {
    where: SuperSegmentWhereUniqueInput
    create: XOR<SuperSegmentCreateWithoutSegmentsInput, SuperSegmentUncheckedCreateWithoutSegmentsInput>
  }

  export type SubSegmentsCreateWithoutSegRefInput = {
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedCreateWithoutSegRefInput = {
    id?: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSubSegmentInput
  }

  export type SubSegmentsCreateOrConnectWithoutSegRefInput = {
    where: SubSegmentsWhereUniqueInput
    create: XOR<SubSegmentsCreateWithoutSegRefInput, SubSegmentsUncheckedCreateWithoutSegRefInput>
  }

  export type SubSegmentsCreateManySegRefInputEnvelope = {
    data: Enumerable<SubSegmentsCreateManySegRefInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutHomeSegmentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutHomeSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutHomeSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutHomeSegmentInput, UserSegmentsUncheckedCreateWithoutHomeSegmentInput>
  }

  export type UserSegmentsCreateManyHomeSegmentInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManyHomeSegmentInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutWorkSegmentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutWorkSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutWorkSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutWorkSegmentInput, UserSegmentsUncheckedCreateWithoutWorkSegmentInput>
  }

  export type UserSegmentsCreateManyWorkSegmentInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManyWorkSegmentInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutSchoolSegmentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutSchoolSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutSchoolSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutSchoolSegmentInput, UserSegmentsUncheckedCreateWithoutSchoolSegmentInput>
  }

  export type UserSegmentsCreateManySchoolSegmentInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManySchoolSegmentInput>
    skipDuplicates?: boolean
  }

  export type IdeaCreateWithoutSegmentInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    subSegment?: SubSegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutSegmentInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutSegmentInput, IdeaUncheckedCreateWithoutSegmentInput>
  }

  export type IdeaCreateManySegmentInputEnvelope = {
    data: Enumerable<IdeaCreateManySegmentInput>
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutSegmentInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    subSegment?: SubSegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutSegmentInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutSegmentInput, ProposalUncheckedCreateWithoutSegmentInput>
  }

  export type ProposalCreateManySegmentInputEnvelope = {
    data: Enumerable<ProposalCreateManySegmentInput>
    skipDuplicates?: boolean
  }

  export type SuperSegmentUpsertWithoutSegmentsInput = {
    update: XOR<SuperSegmentUpdateWithoutSegmentsInput, SuperSegmentUncheckedUpdateWithoutSegmentsInput>
    create: XOR<SuperSegmentCreateWithoutSegmentsInput, SuperSegmentUncheckedCreateWithoutSegmentsInput>
  }

  export type SuperSegmentUpdateWithoutSegmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Idea?: IdeaUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUpdateManyWithoutSchoolSuperSegInput
  }

  export type SuperSegmentUncheckedUpdateWithoutSegmentsInput = {
    superSegId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Idea?: IdeaUncheckedUpdateManyWithoutSuperSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSuperSegmentInput
    homeUserSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSuperSegInput
    workUserSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSuperSegInput
    schoolUserSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSuperSegInput
  }

  export type SubSegmentsUpsertWithWhereUniqueWithoutSegRefInput = {
    where: SubSegmentsWhereUniqueInput
    update: XOR<SubSegmentsUpdateWithoutSegRefInput, SubSegmentsUncheckedUpdateWithoutSegRefInput>
    create: XOR<SubSegmentsCreateWithoutSegRefInput, SubSegmentsUncheckedCreateWithoutSegRefInput>
  }

  export type SubSegmentsUpdateWithWhereUniqueWithoutSegRefInput = {
    where: SubSegmentsWhereUniqueInput
    data: XOR<SubSegmentsUpdateWithoutSegRefInput, SubSegmentsUncheckedUpdateWithoutSegRefInput>
  }

  export type SubSegmentsUpdateManyWithWhereWithoutSegRefInput = {
    where: SubSegmentsScalarWhereInput
    data: XOR<SubSegmentsUpdateManyMutationInput, SubSegmentsUncheckedUpdateManyWithoutSubSegmentsInput>
  }

  export type SubSegmentsScalarWhereInput = {
    AND?: Enumerable<SubSegmentsScalarWhereInput>
    OR?: Enumerable<SubSegmentsScalarWhereInput>
    NOT?: Enumerable<SubSegmentsScalarWhereInput>
    id?: IntFilter | number
    segId?: IntFilter | number
    name?: StringFilter | string
    lat?: DecimalNullableFilter | Decimal | number | string | null
    lon?: DecimalNullableFilter | Decimal | number | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutHomeSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutHomeSegmentInput, UserSegmentsUncheckedUpdateWithoutHomeSegmentInput>
    create: XOR<UserSegmentsCreateWithoutHomeSegmentInput, UserSegmentsUncheckedCreateWithoutHomeSegmentInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutHomeSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutHomeSegmentInput, UserSegmentsUncheckedUpdateWithoutHomeSegmentInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutHomeSegmentInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutHomeSegmentsInput>
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutWorkSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutWorkSegmentInput, UserSegmentsUncheckedUpdateWithoutWorkSegmentInput>
    create: XOR<UserSegmentsCreateWithoutWorkSegmentInput, UserSegmentsUncheckedCreateWithoutWorkSegmentInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutWorkSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutWorkSegmentInput, UserSegmentsUncheckedUpdateWithoutWorkSegmentInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutWorkSegmentInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutWorkSegmentsInput>
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutSchoolSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutSchoolSegmentInput, UserSegmentsUncheckedUpdateWithoutSchoolSegmentInput>
    create: XOR<UserSegmentsCreateWithoutSchoolSegmentInput, UserSegmentsUncheckedCreateWithoutSchoolSegmentInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutSchoolSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutSchoolSegmentInput, UserSegmentsUncheckedUpdateWithoutSchoolSegmentInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutSchoolSegmentInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentsInput>
  }

  export type IdeaUpsertWithWhereUniqueWithoutSegmentInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutSegmentInput, IdeaUncheckedUpdateWithoutSegmentInput>
    create: XOR<IdeaCreateWithoutSegmentInput, IdeaUncheckedCreateWithoutSegmentInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutSegmentInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutSegmentInput, IdeaUncheckedUpdateWithoutSegmentInput>
  }

  export type IdeaUpdateManyWithWhereWithoutSegmentInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutIdeaInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutSegmentInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutSegmentInput, ProposalUncheckedUpdateWithoutSegmentInput>
    create: XOR<ProposalCreateWithoutSegmentInput, ProposalUncheckedCreateWithoutSegmentInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutSegmentInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutSegmentInput, ProposalUncheckedUpdateWithoutSegmentInput>
  }

  export type ProposalUpdateManyWithWhereWithoutSegmentInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProposalInput>
  }

  export type SegmentsCreateWithoutSubSegmentsInput = {
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    superSegment: SuperSegmentCreateNestedOneWithoutSegmentsInput
    homeSegments?: UserSegmentsCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsUncheckedCreateWithoutSubSegmentsInput = {
    segId?: number
    superSegId: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    homeSegments?: UserSegmentsUncheckedCreateNestedManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedCreateNestedManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedCreateNestedManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedCreateNestedManyWithoutSegmentInput
    Proposal?: ProposalUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type SegmentsCreateOrConnectWithoutSubSegmentsInput = {
    where: SegmentsWhereUniqueInput
    create: XOR<SegmentsCreateWithoutSubSegmentsInput, SegmentsUncheckedCreateWithoutSubSegmentsInput>
  }

  export type UserSegmentsCreateWithoutHomeSubSegmentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutHomeSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutHomeSubSegmentInput, UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput>
  }

  export type UserSegmentsCreateManyHomeSubSegmentInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManyHomeSubSegmentInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutWorkSubSegmentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    schoolSubSegment?: SubSegmentsCreateNestedOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutWorkSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutWorkSubSegmentInput, UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput>
  }

  export type UserSegmentsCreateManyWorkSubSegmentInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManyWorkSubSegmentInput>
    skipDuplicates?: boolean
  }

  export type UserSegmentsCreateWithoutSchoolSubSegmentInput = {
    id?: string
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    user?: UserCreateNestedOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentCreateNestedOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentCreateNestedOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentCreateNestedOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsCreateNestedOneWithoutHomeSegmentsInput
    workSegment?: SegmentsCreateNestedOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsCreateNestedOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsCreateNestedOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsCreateNestedOneWithoutWorkSubSegmentsInput
    IdeaComment?: CommentCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
    IdeaComment?: CommentUncheckedCreateNestedManyWithoutUserSegInput
  }

  export type UserSegmentsCreateOrConnectWithoutSchoolSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    create: XOR<UserSegmentsCreateWithoutSchoolSubSegmentInput, UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput>
  }

  export type UserSegmentsCreateManySchoolSubSegmentInputEnvelope = {
    data: Enumerable<UserSegmentsCreateManySchoolSubSegmentInput>
    skipDuplicates?: boolean
  }

  export type IdeaCreateWithoutSubSegmentInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutIdeaInput
    ratings?: RatingCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectCreateNestedOneWithoutIdeaInput
    address?: AddressCreateNestedOneWithoutIdeaInput
    geo?: GeoCreateNestedOneWithoutIdeaInput
    author: UserCreateNestedOneWithoutIdeasInput
    champion?: UserCreateNestedOneWithoutChampionedIdeasInput
    category: CategoryCreateNestedOneWithoutIdeasInput
    superSegment: SuperSegmentCreateNestedOneWithoutIdeaInput
    segment?: SegmentsCreateNestedOneWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutSubSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutIdeaInput
    ratings?: RatingUncheckedCreateNestedManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedCreateNestedOneWithoutIdeaInput
    address?: AddressUncheckedCreateNestedOneWithoutIdeaInput
    geo?: GeoUncheckedCreateNestedOneWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutSubSegmentInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutSubSegmentInput, IdeaUncheckedCreateWithoutSubSegmentInput>
  }

  export type IdeaCreateManySubSegmentInputEnvelope = {
    data: Enumerable<IdeaCreateManySubSegmentInput>
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutSubSegmentInput = {
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutProposalInput
    ratings?: RatingCreateNestedManyWithoutProposalInput
    address?: AddressCreateNestedOneWithoutProposalInput
    geo?: GeoCreateNestedOneWithoutProposalInput
    author: UserCreateNestedOneWithoutProposalsInput
    champion?: UserCreateNestedOneWithoutChampionedProposalsInput
    category: CategoryCreateNestedOneWithoutProposalsInput
    superSegment: SuperSegmentCreateNestedOneWithoutProposalInput
    segment?: SegmentsCreateNestedOneWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutSubSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutProposalInput
    ratings?: RatingUncheckedCreateNestedManyWithoutProposalInput
    address?: AddressUncheckedCreateNestedOneWithoutProposalInput
    geo?: GeoUncheckedCreateNestedOneWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutSubSegmentInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutSubSegmentInput, ProposalUncheckedCreateWithoutSubSegmentInput>
  }

  export type ProposalCreateManySubSegmentInputEnvelope = {
    data: Enumerable<ProposalCreateManySubSegmentInput>
    skipDuplicates?: boolean
  }

  export type SegmentsUpsertWithoutSubSegmentsInput = {
    update: XOR<SegmentsUpdateWithoutSubSegmentsInput, SegmentsUncheckedUpdateWithoutSubSegmentsInput>
    create: XOR<SegmentsCreateWithoutSubSegmentsInput, SegmentsUncheckedCreateWithoutSubSegmentsInput>
  }

  export type SegmentsUpdateWithoutSubSegmentsInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    superSegment?: SuperSegmentUpdateOneRequiredWithoutSegmentsInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutSubSegmentsInput = {
    segId?: IntFieldUpdateOperationsInput | number
    superSegId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutHomeSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutHomeSubSegmentInput, UserSegmentsUncheckedUpdateWithoutHomeSubSegmentInput>
    create: XOR<UserSegmentsCreateWithoutHomeSubSegmentInput, UserSegmentsUncheckedCreateWithoutHomeSubSegmentInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutHomeSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutHomeSubSegmentInput, UserSegmentsUncheckedUpdateWithoutHomeSubSegmentInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutHomeSubSegmentInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentsInput>
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutWorkSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutWorkSubSegmentInput, UserSegmentsUncheckedUpdateWithoutWorkSubSegmentInput>
    create: XOR<UserSegmentsCreateWithoutWorkSubSegmentInput, UserSegmentsUncheckedCreateWithoutWorkSubSegmentInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutWorkSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutWorkSubSegmentInput, UserSegmentsUncheckedUpdateWithoutWorkSubSegmentInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutWorkSubSegmentInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentsInput>
  }

  export type UserSegmentsUpsertWithWhereUniqueWithoutSchoolSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    update: XOR<UserSegmentsUpdateWithoutSchoolSubSegmentInput, UserSegmentsUncheckedUpdateWithoutSchoolSubSegmentInput>
    create: XOR<UserSegmentsCreateWithoutSchoolSubSegmentInput, UserSegmentsUncheckedCreateWithoutSchoolSubSegmentInput>
  }

  export type UserSegmentsUpdateWithWhereUniqueWithoutSchoolSubSegmentInput = {
    where: UserSegmentsWhereUniqueInput
    data: XOR<UserSegmentsUpdateWithoutSchoolSubSegmentInput, UserSegmentsUncheckedUpdateWithoutSchoolSubSegmentInput>
  }

  export type UserSegmentsUpdateManyWithWhereWithoutSchoolSubSegmentInput = {
    where: UserSegmentsScalarWhereInput
    data: XOR<UserSegmentsUpdateManyMutationInput, UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentsInput>
  }

  export type IdeaUpsertWithWhereUniqueWithoutSubSegmentInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutSubSegmentInput, IdeaUncheckedUpdateWithoutSubSegmentInput>
    create: XOR<IdeaCreateWithoutSubSegmentInput, IdeaUncheckedCreateWithoutSubSegmentInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutSubSegmentInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutSubSegmentInput, IdeaUncheckedUpdateWithoutSubSegmentInput>
  }

  export type IdeaUpdateManyWithWhereWithoutSubSegmentInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutIdeaInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutSubSegmentInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutSubSegmentInput, ProposalUncheckedUpdateWithoutSubSegmentInput>
    create: XOR<ProposalCreateWithoutSubSegmentInput, ProposalUncheckedCreateWithoutSubSegmentInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutSubSegmentInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutSubSegmentInput, ProposalUncheckedUpdateWithoutSubSegmentInput>
  }

  export type ProposalUpdateManyWithWhereWithoutSubSegmentInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutProposalInput>
  }

  export type UserCreateWithoutSegmentRequestInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressCreateNestedOneWithoutUserInput
    geo?: UserGeoCreateNestedOneWithoutUserInput
    ideas?: IdeaCreateNestedManyWithoutAuthorInput
    proposals?: ProposalCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsCreateNestedManyWithoutAuthorInput
    userSegments?: UserSegmentsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSegmentRequestInput = {
    id?: string
    userType?: UserType
    email: string
    password: string
    fname?: string | null
    lname?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    imagePath?: string | null
    passCode?: string | null
    banned?: boolean
    address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    geo?: UserGeoUncheckedCreateNestedOneWithoutUserInput
    ideas?: IdeaUncheckedCreateNestedManyWithoutAuthorInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedCreateNestedManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedCreateNestedManyWithoutChampionInput
    ideaRatings?: RatingUncheckedCreateNestedManyWithoutAuthorInput
    ideaComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedCreateNestedManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedCreateNestedManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedCreateNestedManyWithoutAuthorInput
    userSegments?: UserSegmentsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSegmentRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSegmentRequestInput, UserUncheckedCreateWithoutSegmentRequestInput>
  }

  export type UserUpsertWithoutSegmentRequestInput = {
    update: XOR<UserUpdateWithoutSegmentRequestInput, UserUncheckedUpdateWithoutSegmentRequestInput>
    create: XOR<UserCreateWithoutSegmentRequestInput, UserUncheckedCreateWithoutSegmentRequestInput>
  }

  export type UserUpdateWithoutSegmentRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUpdateOneWithoutUserInput
    geo?: UserGeoUpdateOneWithoutUserInput
    ideas?: IdeaUpdateManyWithoutAuthorInput
    proposals?: ProposalUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUpdateManyWithoutChampionInput
    ideaRatings?: RatingUpdateManyWithoutAuthorInput
    ideaComments?: CommentUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUpdateManyWithoutAuthorInput
    userSegments?: UserSegmentsUpdateOneWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutSegmentRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | UserType
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fname?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    passCode?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: BoolFieldUpdateOperationsInput | boolean
    address?: UserAddressUncheckedUpdateOneWithoutUserInput
    geo?: UserGeoUncheckedUpdateOneWithoutUserInput
    ideas?: IdeaUncheckedUpdateManyWithoutAuthorInput
    proposals?: ProposalUncheckedUpdateManyWithoutAuthorInput
    championedProposals?: ProposalUncheckedUpdateManyWithoutChampionInput
    championedIdeas?: IdeaUncheckedUpdateManyWithoutChampionInput
    ideaRatings?: RatingUncheckedUpdateManyWithoutAuthorInput
    ideaComments?: CommentUncheckedUpdateManyWithoutAuthorInput
    ideaCommentLikes?: UserCommentLikesUncheckedUpdateManyWithoutAuthorInput
    ideaCommentDislikes?: UserCommentDislikesUncheckedUpdateManyWithoutAuthorInput
    Advertisements?: AdvertisementsUncheckedUpdateManyWithoutAuthorInput
    userSegments?: UserSegmentsUncheckedUpdateOneWithoutUserInput
  }

  export type IdeaCreateManyAuthorInput = {
    id?: number
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManyAuthorInput = {
    id?: number
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManyChampionInput = {
    id?: number
    authorId: string
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaCreateManyChampionInput = {
    id?: number
    authorId: string
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyAuthorInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCommentLikesCreateManyAuthorInput = {
    id?: number
    ideaCommentId?: number | null
  }

  export type UserCommentDislikesCreateManyAuthorInput = {
    id?: number
    ideaCommentId?: number | null
  }

  export type AdvertisementsCreateManyAuthorInput = {
    id?: number
    createAt?: Date | string
    updateAt?: Date | string | null
    adTitle: string
    adType?: AdType
    duration?: Date | string | null
    adPosition: string
    imagePath: string
    externalLink: string
    published?: boolean
  }

  export type segmentRequestCreateManyRequesterInput = {
    id?: number
    createAt?: Date | string
    country: string
    province: string
    segmentName: string
    subSegmentName?: string | null
  }

  export type IdeaUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateManyWithoutIdeasInput = {
    id?: IntFieldUpdateOperationsInput | number
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateManyWithoutProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutChampionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutChampionInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateManyWithoutChampionedProposalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUpdateWithoutChampionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutChampionInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateManyWithoutChampionedIdeasInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutAuthorInput = {
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneWithoutRatingsInput
    proposal?: ProposalUpdateOneWithoutRatingsInput
  }

  export type RatingUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutIdeaRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idea?: IdeaUpdateOneWithoutCommentsInput
    proposal?: ProposalUpdateOneWithoutCommentsInput
    userSeg?: UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput
    likes?: UserCommentLikesUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateManyWithoutIdeaCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCommentLikesUpdateWithoutAuthorInput = {
    ideaComment?: CommentUpdateOneWithoutLikesInput
  }

  export type UserCommentLikesUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCommentDislikesUpdateWithoutAuthorInput = {
    ideaComment?: CommentUpdateOneWithoutDislikesInput
  }

  export type UserCommentDislikesUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaCommentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdvertisementsUpdateWithoutAuthorInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvertisementsUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvertisementsUncheckedUpdateManyWithoutAdvertisementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adTitle?: StringFieldUpdateOperationsInput | string
    adType?: EnumAdTypeFieldUpdateOperationsInput | AdType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adPosition?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    externalLink?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type segmentRequestUpdateWithoutRequesterInput = {
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type segmentRequestUncheckedUpdateWithoutRequesterInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type segmentRequestUncheckedUpdateManyWithoutSegmentRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    segmentName?: StringFieldUpdateOperationsInput | string
    subSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyUserSegInput = {
    id?: number
    ideaId?: number | null
    proposalId?: number | null
    authorId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutUserSegInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaCommentsInput
    idea?: IdeaUpdateOneWithoutCommentsInput
    proposal?: ProposalUpdateOneWithoutCommentsInput
    likes?: UserCommentLikesUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateWithoutUserSegInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateManyWithoutIdeaCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaCreateManyCategoryInput = {
    id?: number
    authorId: string
    championId?: string | null
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManyCategoryInput = {
    id?: number
    authorId: string
    championId?: string | null
    superSegmentId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type CommentCreateManyIdeaInput = {
    id?: number
    proposalId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyIdeaInput = {
    id?: number
    proposalId?: number | null
    authorId: string
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutIdeaInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaCommentsInput
    proposal?: ProposalUpdateOneWithoutCommentsInput
    userSeg?: UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput
    likes?: UserCommentLikesUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutIdeaInput = {
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaRatingsInput
    proposal?: ProposalUpdateOneWithoutRatingsInput
  }

  export type RatingUncheckedUpdateWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUncheckedUpdateManyWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    proposalId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyProposalInput = {
    id?: number
    ideaId?: number | null
    authorId: string
    userSegId: string
    superSegmentId?: number | null
    segmentId?: number | null
    subSegmentId?: number | null
    content: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RatingCreateManyProposalInput = {
    id?: number
    ideaId?: number | null
    authorId: string
    rating?: number
    ratingExplanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutProposalInput = {
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaCommentsInput
    idea?: IdeaUpdateOneWithoutCommentsInput
    userSeg?: UserSegmentsUpdateOneRequiredWithoutIdeaCommentInput
    likes?: UserCommentLikesUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUpdateManyWithoutIdeaCommentInput
  }

  export type CommentUncheckedUpdateWithoutProposalInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    userSegId?: StringFieldUpdateOperationsInput | string
    superSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserCommentLikesUncheckedUpdateManyWithoutIdeaCommentInput
    dislikes?: UserCommentDislikesUncheckedUpdateManyWithoutIdeaCommentInput
  }

  export type RatingUpdateWithoutProposalInput = {
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIdeaRatingsInput
    idea?: IdeaUpdateOneWithoutRatingsInput
  }

  export type RatingUncheckedUpdateWithoutProposalInput = {
    id?: IntFieldUpdateOperationsInput | number
    ideaId?: NullableIntFieldUpdateOperationsInput | number | null
    authorId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    ratingExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCommentLikesCreateManyIdeaCommentInput = {
    id?: number
    authorId?: string | null
  }

  export type UserCommentDislikesCreateManyIdeaCommentInput = {
    id?: number
    authorId?: string | null
  }

  export type UserCommentLikesUpdateWithoutIdeaCommentInput = {
    author?: UserUpdateOneWithoutIdeaCommentLikesInput
  }

  export type UserCommentLikesUncheckedUpdateWithoutIdeaCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentLikesUncheckedUpdateManyWithoutLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentDislikesUpdateWithoutIdeaCommentInput = {
    author?: UserUpdateOneWithoutIdeaCommentDislikesInput
  }

  export type UserCommentDislikesUncheckedUpdateWithoutIdeaCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCommentDislikesUncheckedUpdateManyWithoutDislikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SegmentsCreateManySuperSegmentInput = {
    segId?: number
    country: string
    province: string
    name: string
    superSegName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type IdeaCreateManySuperSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManySuperSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    segmentId?: number | null
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSegmentsCreateManyHomeSuperSegInput = {
    id?: string
    userId: string
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateManyWorkSuperSegInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateManySchoolSuperSegInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type SegmentsUpdateWithoutSuperSegmentInput = {
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUpdateManyWithoutSegmentInput
    Proposal?: ProposalUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateWithoutSuperSegmentInput = {
    segId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SubSegments?: SubSegmentsUncheckedUpdateManyWithoutSegRefInput
    homeSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSegmentInput
    workSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSegmentInput
    schoolSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSegmentInput
  }

  export type SegmentsUncheckedUpdateManyWithoutSegmentsInput = {
    segId?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    superSegName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IdeaUpdateWithoutSuperSegmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutSuperSegmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateManyWithoutIdeaInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutSuperSegmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    segment?: SegmentsUpdateOneWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutSuperSegmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateManyWithoutProposalInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSegmentsUpdateWithoutHomeSuperSegInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutHomeSuperSegInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutHomeUserSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUpdateWithoutWorkSuperSegInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutWorkSuperSegInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutWorkUserSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUpdateWithoutSchoolSuperSegInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutSchoolSuperSegInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutSchoolUserSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubSegmentsCreateManySegRefInput = {
    id?: number
    name: string
    lat?: Decimal | number | string | null
    lon?: Decimal | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserSegmentsCreateManyHomeSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateManyWorkSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateManySchoolSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type IdeaCreateManySegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManySegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    subSegmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubSegmentsUpdateWithoutSegRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateWithoutSegRefInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeSubSegments?: UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentInput
    workSubSegments?: UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentInput
    schoolSubSegments?: UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentInput
    Idea?: IdeaUncheckedUpdateManyWithoutSubSegmentInput
    Proposal?: ProposalUncheckedUpdateManyWithoutSubSegmentInput
  }

  export type SubSegmentsUncheckedUpdateManyWithoutSubSegmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    lon?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSegmentsUpdateWithoutHomeSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutHomeSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutHomeSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUpdateWithoutWorkSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutWorkSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutWorkSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUpdateWithoutSchoolSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutSchoolSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutSchoolSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdeaUpdateWithoutSegmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    subSegment?: SubSegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutSegmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpdateWithoutSegmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    subSegment?: SubSegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutSegmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    subSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }

  export type UserSegmentsCreateManyHomeSubSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateManyWorkSubSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentName?: string | null
    schoolSubSegmentId?: number | null
    schoolSubSegmentName?: string | null
  }

  export type UserSegmentsCreateManySchoolSubSegmentInput = {
    id?: string
    userId: string
    homeSuperSegId?: number | null
    homeSuperSegName?: string | null
    workSuperSegId?: number | null
    workSuperSegName?: string | null
    schoolSuperSegId?: number | null
    schoolSuperSegName?: string | null
    homeSegmentId?: number | null
    homeSegmentName?: string | null
    workSegmentId?: number | null
    workSegmentName?: string | null
    schoolSegmentId?: number | null
    schoolSegmentName?: string | null
    homeSubSegmentId?: number | null
    homeSubSegmentName?: string | null
    workSubSegmentId?: number | null
    workSubSegmentName?: string | null
    schoolSubSegmentName?: string | null
  }

  export type IdeaCreateManySubSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManySubSegmentInput = {
    id?: number
    authorId: string
    championId?: string | null
    categoryId: number
    superSegmentId: number
    segmentId?: number | null
    title: string
    description: string
    userType?: string
    communityImpact?: string | null
    natureImpact?: string | null
    artsImpact?: string | null
    energyImpact?: string | null
    manufacturingImpact?: string | null
    state?: IdeaState
    active?: boolean
    imagePath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSegmentsUpdateWithoutHomeSubSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutHomeSubSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutHomeSubSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUpdateWithoutWorkSubSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    schoolSubSegment?: SubSegmentsUpdateOneWithoutSchoolSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutWorkSubSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutWorkSubSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSegmentsUpdateWithoutSchoolSubSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutUserSegmentsInput
    homeSuperSeg?: SuperSegmentUpdateOneWithoutHomeUserSegmentsInput
    workSuperSeg?: SuperSegmentUpdateOneWithoutWorkUserSegmentsInput
    schoolSuperSeg?: SuperSegmentUpdateOneWithoutSchoolUserSegmentsInput
    homeSegment?: SegmentsUpdateOneWithoutHomeSegmentsInput
    workSegment?: SegmentsUpdateOneWithoutWorkSegmentsInput
    schoolSegment?: SegmentsUpdateOneWithoutSchoolSegmentsInput
    homeSubSegment?: SubSegmentsUpdateOneWithoutHomeSubSegmentsInput
    workSubSegment?: SubSegmentsUpdateOneWithoutWorkSubSegmentsInput
    IdeaComment?: CommentUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateWithoutSchoolSubSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    IdeaComment?: CommentUncheckedUpdateManyWithoutUserSegInput
  }

  export type UserSegmentsUncheckedUpdateManyWithoutSchoolSubSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    workSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    workSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSuperSegId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSuperSegName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    homeSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    homeSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    workSubSegmentId?: NullableIntFieldUpdateOperationsInput | number | null
    workSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
    schoolSubSegmentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IdeaUpdateWithoutSubSegmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutIdeaInput
    ratings?: RatingUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUpdateOneWithoutIdeaInput
    address?: AddressUpdateOneWithoutIdeaInput
    geo?: GeoUpdateOneWithoutIdeaInput
    author?: UserUpdateOneRequiredWithoutIdeasInput
    champion?: UserUpdateOneWithoutChampionedIdeasInput
    category?: CategoryUpdateOneRequiredWithoutIdeasInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutIdeaInput
    segment?: SegmentsUpdateOneWithoutIdeaInput
  }

  export type IdeaUncheckedUpdateWithoutSubSegmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutIdeaInput
    ratings?: RatingUncheckedUpdateManyWithoutIdeaInput
    projectInfo?: ProjectUncheckedUpdateOneWithoutIdeaInput
    address?: AddressUncheckedUpdateOneWithoutIdeaInput
    geo?: GeoUncheckedUpdateOneWithoutIdeaInput
  }

  export type ProposalUpdateWithoutSubSegmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutProposalInput
    ratings?: RatingUpdateManyWithoutProposalInput
    address?: AddressUpdateOneWithoutProposalInput
    geo?: GeoUpdateOneWithoutProposalInput
    author?: UserUpdateOneRequiredWithoutProposalsInput
    champion?: UserUpdateOneWithoutChampionedProposalsInput
    category?: CategoryUpdateOneRequiredWithoutProposalsInput
    superSegment?: SuperSegmentUpdateOneRequiredWithoutProposalInput
    segment?: SegmentsUpdateOneWithoutProposalInput
  }

  export type ProposalUncheckedUpdateWithoutSubSegmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: StringFieldUpdateOperationsInput | string
    championId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: IntFieldUpdateOperationsInput | number
    superSegmentId?: IntFieldUpdateOperationsInput | number
    segmentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userType?: StringFieldUpdateOperationsInput | string
    communityImpact?: NullableStringFieldUpdateOperationsInput | string | null
    natureImpact?: NullableStringFieldUpdateOperationsInput | string | null
    artsImpact?: NullableStringFieldUpdateOperationsInput | string | null
    energyImpact?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturingImpact?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumIdeaStateFieldUpdateOperationsInput | IdeaState
    active?: BoolFieldUpdateOperationsInput | boolean
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutProposalInput
    ratings?: RatingUncheckedUpdateManyWithoutProposalInput
    address?: AddressUncheckedUpdateOneWithoutProposalInput
    geo?: GeoUncheckedUpdateOneWithoutProposalInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}